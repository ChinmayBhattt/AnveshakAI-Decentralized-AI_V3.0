(function () { const t = document.createElement("link").relList; if (t && t.supports && t.supports("modulepreload")) return; for (const i of document.querySelectorAll('link[rel="modulepreload"]')) r(i); new MutationObserver(i => { for (const s of i) if (s.type === "childList") for (const o of s.addedNodes) o.tagName === "LINK" && o.rel === "modulepreload" && r(o) }).observe(document, { childList: !0, subtree: !0 }); function n(i) { const s = {}; return i.integrity && (s.integrity = i.integrity), i.referrerPolicy && (s.referrerPolicy = i.referrerPolicy), i.crossOrigin === "use-credentials" ? s.credentials = "include" : i.crossOrigin === "anonymous" ? s.credentials = "omit" : s.credentials = "same-origin", s } function r(i) { if (i.ep) return; i.ep = !0; const s = n(i); fetch(i.href, s) } })(); var ns = typeof globalThis < "u" ? globalThis : typeof window < "u" ? window : typeof global < "u" ? global : typeof self < "u" ? self : {}; function _h(e) { return e && e.__esModule && Object.prototype.hasOwnProperty.call(e, "default") ? e.default : e } var Eh = { exports: {} }, El = {}, bh = { exports: {} }, Ne = {};/**
 * @license React
 * react.production.min.js
 *
 * Copyright (c) Facebook, Inc. and its affiliates.
 *
 * This source code is licensed under the MIT license found in the
 * LICENSE file in the root directory of this source tree.
 */var _o = Symbol.for("react.element"), Jy = Symbol.for("react.portal"), eg = Symbol.for("react.fragment"), tg = Symbol.for("react.strict_mode"), ng = Symbol.for("react.profiler"), rg = Symbol.for("react.provider"), ig = Symbol.for("react.context"), sg = Symbol.for("react.forward_ref"), og = Symbol.for("react.suspense"), ag = Symbol.for("react.memo"), lg = Symbol.for("react.lazy"), xd = Symbol.iterator; function ug(e) { return e === null || typeof e != "object" ? null : (e = xd && e[xd] || e["@@iterator"], typeof e == "function" ? e : null) } var Sh = { isMounted: function () { return !1 }, enqueueForceUpdate: function () { }, enqueueReplaceState: function () { }, enqueueSetState: function () { } }, Nh = Object.assign, Th = {}; function ms(e, t, n) { this.props = e, this.context = t, this.refs = Th, this.updater = n || Sh } ms.prototype.isReactComponent = {}; ms.prototype.setState = function (e, t) { if (typeof e != "object" && typeof e != "function" && e != null) throw Error("setState(...): takes an object of state variables to update or a function which returns an object of state variables."); this.updater.enqueueSetState(this, e, t, "setState") }; ms.prototype.forceUpdate = function (e) { this.updater.enqueueForceUpdate(this, e, "forceUpdate") }; function Bh() { } Bh.prototype = ms.prototype; function ff(e, t, n) { this.props = e, this.context = t, this.refs = Th, this.updater = n || Sh } var df = ff.prototype = new Bh; df.constructor = ff; Nh(df, ms.prototype); df.isPureReactComponent = !0; var vd = Array.isArray, Ah = Object.prototype.hasOwnProperty, hf = { current: null }, kh = { key: !0, ref: !0, __self: !0, __source: !0 }; function Rh(e, t, n) { var r, i = {}, s = null, o = null; if (t != null) for (r in t.ref !== void 0 && (o = t.ref), t.key !== void 0 && (s = "" + t.key), t) Ah.call(t, r) && !kh.hasOwnProperty(r) && (i[r] = t[r]); var a = arguments.length - 2; if (a === 1) i.children = n; else if (1 < a) { for (var f = Array(a), h = 0; h < a; h++)f[h] = arguments[h + 2]; i.children = f } if (e && e.defaultProps) for (r in a = e.defaultProps, a) i[r] === void 0 && (i[r] = a[r]); return { $$typeof: _o, type: e, key: s, ref: o, props: i, _owner: hf.current } } function cg(e, t) { return { $$typeof: _o, type: e.type, key: t, ref: e.ref, props: e.props, _owner: e._owner } } function pf(e) { return typeof e == "object" && e !== null && e.$$typeof === _o } function fg(e) { var t = { "=": "=0", ":": "=2" }; return "$" + e.replace(/[=:]/g, function (n) { return t[n] }) } var _d = /\/+/g; function ou(e, t) { return typeof e == "object" && e !== null && e.key != null ? fg("" + e.key) : t.toString(36) } function ua(e, t, n, r, i) { var s = typeof e; (s === "undefined" || s === "boolean") && (e = null); var o = !1; if (e === null) o = !0; else switch (s) { case "string": case "number": o = !0; break; case "object": switch (e.$$typeof) { case _o: case Jy: o = !0 } }if (o) return o = e, i = i(o), e = r === "" ? "." + ou(o, 0) : r, vd(i) ? (n = "", e != null && (n = e.replace(_d, "$&/") + "/"), ua(i, t, n, "", function (h) { return h })) : i != null && (pf(i) && (i = cg(i, n + (!i.key || o && o.key === i.key ? "" : ("" + i.key).replace(_d, "$&/") + "/") + e)), t.push(i)), 1; if (o = 0, r = r === "" ? "." : r + ":", vd(e)) for (var a = 0; a < e.length; a++) { s = e[a]; var f = r + ou(s, a); o += ua(s, t, n, f, i) } else if (f = ug(e), typeof f == "function") for (e = f.call(e), a = 0; !(s = e.next()).done;)s = s.value, f = r + ou(s, a++), o += ua(s, t, n, f, i); else if (s === "object") throw t = String(e), Error("Objects are not valid as a React child (found: " + (t === "[object Object]" ? "object with keys {" + Object.keys(e).join(", ") + "}" : t) + "). If you meant to render a collection of children, use an array instead."); return o } function Co(e, t, n) { if (e == null) return e; var r = [], i = 0; return ua(e, r, "", "", function (s) { return t.call(n, s, i++) }), r } function dg(e) { if (e._status === -1) { var t = e._result; t = t(), t.then(function (n) { (e._status === 0 || e._status === -1) && (e._status = 1, e._result = n) }, function (n) { (e._status === 0 || e._status === -1) && (e._status = 2, e._result = n) }), e._status === -1 && (e._status = 0, e._result = t) } if (e._status === 1) return e._result.default; throw e._result } var $t = { current: null }, ca = { transition: null }, hg = { ReactCurrentDispatcher: $t, ReactCurrentBatchConfig: ca, ReactCurrentOwner: hf }; function Ih() { throw Error("act(...) is not supported in production builds of React.") } Ne.Children = { map: Co, forEach: function (e, t, n) { Co(e, function () { t.apply(this, arguments) }, n) }, count: function (e) { var t = 0; return Co(e, function () { t++ }), t }, toArray: function (e) { return Co(e, function (t) { return t }) || [] }, only: function (e) { if (!pf(e)) throw Error("React.Children.only expected to receive a single React element child."); return e } }; Ne.Component = ms; Ne.Fragment = eg; Ne.Profiler = ng; Ne.PureComponent = ff; Ne.StrictMode = tg; Ne.Suspense = og; Ne.__SECRET_INTERNALS_DO_NOT_USE_OR_YOU_WILL_BE_FIRED = hg; Ne.act = Ih; Ne.cloneElement = function (e, t, n) { if (e == null) throw Error("React.cloneElement(...): The argument must be a React element, but you passed " + e + "."); var r = Nh({}, e.props), i = e.key, s = e.ref, o = e._owner; if (t != null) { if (t.ref !== void 0 && (s = t.ref, o = hf.current), t.key !== void 0 && (i = "" + t.key), e.type && e.type.defaultProps) var a = e.type.defaultProps; for (f in t) Ah.call(t, f) && !kh.hasOwnProperty(f) && (r[f] = t[f] === void 0 && a !== void 0 ? a[f] : t[f]) } var f = arguments.length - 2; if (f === 1) r.children = n; else if (1 < f) { a = Array(f); for (var h = 0; h < f; h++)a[h] = arguments[h + 2]; r.children = a } return { $$typeof: _o, type: e.type, key: i, ref: s, props: r, _owner: o } }; Ne.createContext = function (e) { return e = { $$typeof: ig, _currentValue: e, _currentValue2: e, _threadCount: 0, Provider: null, Consumer: null, _defaultValue: null, _globalName: null }, e.Provider = { $$typeof: rg, _context: e }, e.Consumer = e }; Ne.createElement = Rh; Ne.createFactory = function (e) { var t = Rh.bind(null, e); return t.type = e, t }; Ne.createRef = function () { return { current: null } }; Ne.forwardRef = function (e) { return { $$typeof: sg, render: e } }; Ne.isValidElement = pf; Ne.lazy = function (e) { return { $$typeof: lg, _payload: { _status: -1, _result: e }, _init: dg } }; Ne.memo = function (e, t) { return { $$typeof: ag, type: e, compare: t === void 0 ? null : t } }; Ne.startTransition = function (e) { var t = ca.transition; ca.transition = {}; try { e() } finally { ca.transition = t } }; Ne.unstable_act = Ih; Ne.useCallback = function (e, t) { return $t.current.useCallback(e, t) }; Ne.useContext = function (e) { return $t.current.useContext(e) }; Ne.useDebugValue = function () { }; Ne.useDeferredValue = function (e) { return $t.current.useDeferredValue(e) }; Ne.useEffect = function (e, t) { return $t.current.useEffect(e, t) }; Ne.useId = function () { return $t.current.useId() }; Ne.useImperativeHandle = function (e, t, n) { return $t.current.useImperativeHandle(e, t, n) }; Ne.useInsertionEffect = function (e, t) { return $t.current.useInsertionEffect(e, t) }; Ne.useLayoutEffect = function (e, t) { return $t.current.useLayoutEffect(e, t) }; Ne.useMemo = function (e, t) { return $t.current.useMemo(e, t) }; Ne.useReducer = function (e, t, n) { return $t.current.useReducer(e, t, n) }; Ne.useRef = function (e) { return $t.current.useRef(e) }; Ne.useState = function (e) { return $t.current.useState(e) }; Ne.useSyncExternalStore = function (e, t, n) { return $t.current.useSyncExternalStore(e, t, n) }; Ne.useTransition = function () { return $t.current.useTransition() }; Ne.version = "18.3.1"; bh.exports = Ne; var ct = bh.exports; const pg = _h(ct);/**
 * @license React
 * react-jsx-runtime.production.min.js
 *
 * Copyright (c) Facebook, Inc. and its affiliates.
 *
 * This source code is licensed under the MIT license found in the
 * LICENSE file in the root directory of this source tree.
 */var mg = ct, yg = Symbol.for("react.element"), gg = Symbol.for("react.fragment"), wg = Object.prototype.hasOwnProperty, xg = mg.__SECRET_INTERNALS_DO_NOT_USE_OR_YOU_WILL_BE_FIRED.ReactCurrentOwner, vg = { key: !0, ref: !0, __self: !0, __source: !0 }; function Oh(e, t, n) { var r, i = {}, s = null, o = null; n !== void 0 && (s = "" + n), t.key !== void 0 && (s = "" + t.key), t.ref !== void 0 && (o = t.ref); for (r in t) wg.call(t, r) && !vg.hasOwnProperty(r) && (i[r] = t[r]); if (e && e.defaultProps) for (r in t = e.defaultProps, t) i[r] === void 0 && (i[r] = t[r]); return { $$typeof: yg, type: e, key: s, ref: o, props: i, _owner: xg.current } } El.Fragment = gg; El.jsx = Oh; El.jsxs = Oh; Eh.exports = El; var H = Eh.exports, Ju = {}, Uh = { exports: {} }, Dt = {}, Fh = { exports: {} }, Ch = {};/**
 * @license React
 * scheduler.production.min.js
 *
 * Copyright (c) Facebook, Inc. and its affiliates.
 *
 * This source code is licensed under the MIT license found in the
 * LICENSE file in the root directory of this source tree.
 */(function (e) { function t(z, D) { var ae = z.length; z.push(D); e: for (; 0 < ae;) { var se = ae - 1 >>> 1, oe = z[se]; if (0 < i(oe, D)) z[se] = D, z[ae] = oe, ae = se; else break e } } function n(z) { return z.length === 0 ? null : z[0] } function r(z) { if (z.length === 0) return null; var D = z[0], ae = z.pop(); if (ae !== D) { z[0] = ae; e: for (var se = 0, oe = z.length, Ae = oe >>> 1; se < Ae;) { var B = 2 * (se + 1) - 1, Pe = z[B], Ee = B + 1, Ue = z[Ee]; if (0 > i(Pe, ae)) Ee < oe && 0 > i(Ue, Pe) ? (z[se] = Ue, z[Ee] = ae, se = Ee) : (z[se] = Pe, z[B] = ae, se = B); else if (Ee < oe && 0 > i(Ue, ae)) z[se] = Ue, z[Ee] = ae, se = Ee; else break e } } return D } function i(z, D) { var ae = z.sortIndex - D.sortIndex; return ae !== 0 ? ae : z.id - D.id } if (typeof performance == "object" && typeof performance.now == "function") { var s = performance; e.unstable_now = function () { return s.now() } } else { var o = Date, a = o.now(); e.unstable_now = function () { return o.now() - a } } var f = [], h = [], _ = 1, v = null, y = 3, w = !1, p = !1, O = !1, $ = typeof setTimeout == "function" ? setTimeout : null, b = typeof clearTimeout == "function" ? clearTimeout : null, E = typeof setImmediate < "u" ? setImmediate : null; typeof navigator < "u" && navigator.scheduling !== void 0 && navigator.scheduling.isInputPending !== void 0 && navigator.scheduling.isInputPending.bind(navigator.scheduling); function S(z) { for (var D = n(h); D !== null;) { if (D.callback === null) r(h); else if (D.startTime <= z) r(h), D.sortIndex = D.expirationTime, t(f, D); else break; D = n(h) } } function M(z) { if (O = !1, S(z), !p) if (n(f) !== null) p = !0, J(k); else { var D = n(h); D !== null && ie(M, D.startTime - z) } } function k(z, D) { p = !1, O && (O = !1, b(Y), Y = -1), w = !0; var ae = y; try { for (S(D), v = n(f); v !== null && (!(v.expirationTime > D) || z && !K());) { var se = v.callback; if (typeof se == "function") { v.callback = null, y = v.priorityLevel; var oe = se(v.expirationTime <= D); D = e.unstable_now(), typeof oe == "function" ? v.callback = oe : v === n(f) && r(f), S(D) } else r(f); v = n(f) } if (v !== null) var Ae = !0; else { var B = n(h); B !== null && ie(M, B.startTime - D), Ae = !1 } return Ae } finally { v = null, y = ae, w = !1 } } var C = !1, V = null, Y = -1, re = 5, U = -1; function K() { return !(e.unstable_now() - U < re) } function ee() { if (V !== null) { var z = e.unstable_now(); U = z; var D = !0; try { D = V(!0, z) } finally { D ? N() : (C = !1, V = null) } } else C = !1 } var N; if (typeof E == "function") N = function () { E(ee) }; else if (typeof MessageChannel < "u") { var F = new MessageChannel, G = F.port2; F.port1.onmessage = ee, N = function () { G.postMessage(null) } } else N = function () { $(ee, 0) }; function J(z) { V = z, C || (C = !0, N()) } function ie(z, D) { Y = $(function () { z(e.unstable_now()) }, D) } e.unstable_IdlePriority = 5, e.unstable_ImmediatePriority = 1, e.unstable_LowPriority = 4, e.unstable_NormalPriority = 3, e.unstable_Profiling = null, e.unstable_UserBlockingPriority = 2, e.unstable_cancelCallback = function (z) { z.callback = null }, e.unstable_continueExecution = function () { p || w || (p = !0, J(k)) }, e.unstable_forceFrameRate = function (z) { 0 > z || 125 < z ? console.error("forceFrameRate takes a positive int between 0 and 125, forcing frame rates higher than 125 fps is not supported") : re = 0 < z ? Math.floor(1e3 / z) : 5 }, e.unstable_getCurrentPriorityLevel = function () { return y }, e.unstable_getFirstCallbackNode = function () { return n(f) }, e.unstable_next = function (z) { switch (y) { case 1: case 2: case 3: var D = 3; break; default: D = y }var ae = y; y = D; try { return z() } finally { y = ae } }, e.unstable_pauseExecution = function () { }, e.unstable_requestPaint = function () { }, e.unstable_runWithPriority = function (z, D) { switch (z) { case 1: case 2: case 3: case 4: case 5: break; default: z = 3 }var ae = y; y = z; try { return D() } finally { y = ae } }, e.unstable_scheduleCallback = function (z, D, ae) { var se = e.unstable_now(); switch (typeof ae == "object" && ae !== null ? (ae = ae.delay, ae = typeof ae == "number" && 0 < ae ? se + ae : se) : ae = se, z) { case 1: var oe = -1; break; case 2: oe = 250; break; case 5: oe = 1073741823; break; case 4: oe = 1e4; break; default: oe = 5e3 }return oe = ae + oe, z = { id: _++, callback: D, priorityLevel: z, startTime: ae, expirationTime: oe, sortIndex: -1 }, ae > se ? (z.sortIndex = ae, t(h, z), n(f) === null && z === n(h) && (O ? (b(Y), Y = -1) : O = !0, ie(M, ae - se))) : (z.sortIndex = oe, t(f, z), p || w || (p = !0, J(k))), z }, e.unstable_shouldYield = K, e.unstable_wrapCallback = function (z) { var D = y; return function () { var ae = y; y = D; try { return z.apply(this, arguments) } finally { y = ae } } } })(Ch); Fh.exports = Ch; var _g = Fh.exports;/**
 * @license React
 * react-dom.production.min.js
 *
 * Copyright (c) Facebook, Inc. and its affiliates.
 *
 * This source code is licensed under the MIT license found in the
 * LICENSE file in the root directory of this source tree.
 */var Eg = ct, Qt = _g; function ue(e) { for (var t = "https://reactjs.org/docs/error-decoder.html?invariant=" + e, n = 1; n < arguments.length; n++)t += "&args[]=" + encodeURIComponent(arguments[n]); return "Minified React error #" + e + "; visit " + t + " for the full message or use the non-minified dev environment for full errors and additional helpful warnings." } var Ph = new Set, Xs = {}; function gi(e, t) { rs(e, t), rs(e + "Capture", t) } function rs(e, t) { for (Xs[e] = t, e = 0; e < t.length; e++)Ph.add(t[e]) } var nr = !(typeof window > "u" || typeof window.document > "u" || typeof window.document.createElement > "u"), ec = Object.prototype.hasOwnProperty, bg = /^[:A-Z_a-z\u00C0-\u00D6\u00D8-\u00F6\u00F8-\u02FF\u0370-\u037D\u037F-\u1FFF\u200C-\u200D\u2070-\u218F\u2C00-\u2FEF\u3001-\uD7FF\uF900-\uFDCF\uFDF0-\uFFFD][:A-Z_a-z\u00C0-\u00D6\u00D8-\u00F6\u00F8-\u02FF\u0370-\u037D\u037F-\u1FFF\u200C-\u200D\u2070-\u218F\u2C00-\u2FEF\u3001-\uD7FF\uF900-\uFDCF\uFDF0-\uFFFD\-.0-9\u00B7\u0300-\u036F\u203F-\u2040]*$/, Ed = {}, bd = {}; function Sg(e) { return ec.call(bd, e) ? !0 : ec.call(Ed, e) ? !1 : bg.test(e) ? bd[e] = !0 : (Ed[e] = !0, !1) } function Ng(e, t, n, r) { if (n !== null && n.type === 0) return !1; switch (typeof t) { case "function": case "symbol": return !0; case "boolean": return r ? !1 : n !== null ? !n.acceptsBooleans : (e = e.toLowerCase().slice(0, 5), e !== "data-" && e !== "aria-"); default: return !1 } } function Tg(e, t, n, r) { if (t === null || typeof t > "u" || Ng(e, t, n, r)) return !0; if (r) return !1; if (n !== null) switch (n.type) { case 3: return !t; case 4: return t === !1; case 5: return isNaN(t); case 6: return isNaN(t) || 1 > t }return !1 } function zt(e, t, n, r, i, s, o) { this.acceptsBooleans = t === 2 || t === 3 || t === 4, this.attributeName = r, this.attributeNamespace = i, this.mustUseProperty = n, this.propertyName = e, this.type = t, this.sanitizeURL = s, this.removeEmptyString = o } var _t = {}; "children dangerouslySetInnerHTML defaultValue defaultChecked innerHTML suppressContentEditableWarning suppressHydrationWarning style".split(" ").forEach(function (e) { _t[e] = new zt(e, 0, !1, e, null, !1, !1) });[["acceptCharset", "accept-charset"], ["className", "class"], ["htmlFor", "for"], ["httpEquiv", "http-equiv"]].forEach(function (e) { var t = e[0]; _t[t] = new zt(t, 1, !1, e[1], null, !1, !1) });["contentEditable", "draggable", "spellCheck", "value"].forEach(function (e) { _t[e] = new zt(e, 2, !1, e.toLowerCase(), null, !1, !1) });["autoReverse", "externalResourcesRequired", "focusable", "preserveAlpha"].forEach(function (e) { _t[e] = new zt(e, 2, !1, e, null, !1, !1) }); "allowFullScreen async autoFocus autoPlay controls default defer disabled disablePictureInPicture disableRemotePlayback formNoValidate hidden loop noModule noValidate open playsInline readOnly required reversed scoped seamless itemScope".split(" ").forEach(function (e) { _t[e] = new zt(e, 3, !1, e.toLowerCase(), null, !1, !1) });["checked", "multiple", "muted", "selected"].forEach(function (e) { _t[e] = new zt(e, 3, !0, e, null, !1, !1) });["capture", "download"].forEach(function (e) { _t[e] = new zt(e, 4, !1, e, null, !1, !1) });["cols", "rows", "size", "span"].forEach(function (e) { _t[e] = new zt(e, 6, !1, e, null, !1, !1) });["rowSpan", "start"].forEach(function (e) { _t[e] = new zt(e, 5, !1, e.toLowerCase(), null, !1, !1) }); var mf = /[\-:]([a-z])/g; function yf(e) { return e[1].toUpperCase() } "accent-height alignment-baseline arabic-form baseline-shift cap-height clip-path clip-rule color-interpolation color-interpolation-filters color-profile color-rendering dominant-baseline enable-background fill-opacity fill-rule flood-color flood-opacity font-family font-size font-size-adjust font-stretch font-style font-variant font-weight glyph-name glyph-orientation-horizontal glyph-orientation-vertical horiz-adv-x horiz-origin-x image-rendering letter-spacing lighting-color marker-end marker-mid marker-start overline-position overline-thickness paint-order panose-1 pointer-events rendering-intent shape-rendering stop-color stop-opacity strikethrough-position strikethrough-thickness stroke-dasharray stroke-dashoffset stroke-linecap stroke-linejoin stroke-miterlimit stroke-opacity stroke-width text-anchor text-decoration text-rendering underline-position underline-thickness unicode-bidi unicode-range units-per-em v-alphabetic v-hanging v-ideographic v-mathematical vector-effect vert-adv-y vert-origin-x vert-origin-y word-spacing writing-mode xmlns:xlink x-height".split(" ").forEach(function (e) { var t = e.replace(mf, yf); _t[t] = new zt(t, 1, !1, e, null, !1, !1) }); "xlink:actuate xlink:arcrole xlink:role xlink:show xlink:title xlink:type".split(" ").forEach(function (e) { var t = e.replace(mf, yf); _t[t] = new zt(t, 1, !1, e, "http://www.w3.org/1999/xlink", !1, !1) });["xml:base", "xml:lang", "xml:space"].forEach(function (e) { var t = e.replace(mf, yf); _t[t] = new zt(t, 1, !1, e, "http://www.w3.org/XML/1998/namespace", !1, !1) });["tabIndex", "crossOrigin"].forEach(function (e) { _t[e] = new zt(e, 1, !1, e.toLowerCase(), null, !1, !1) }); _t.xlinkHref = new zt("xlinkHref", 1, !1, "xlink:href", "http://www.w3.org/1999/xlink", !0, !1);["src", "href", "action", "formAction"].forEach(function (e) { _t[e] = new zt(e, 1, !1, e.toLowerCase(), null, !0, !0) }); function gf(e, t, n, r) { var i = _t.hasOwnProperty(t) ? _t[t] : null; (i !== null ? i.type !== 0 : r || !(2 < t.length) || t[0] !== "o" && t[0] !== "O" || t[1] !== "n" && t[1] !== "N") && (Tg(t, n, i, r) && (n = null), r || i === null ? Sg(t) && (n === null ? e.removeAttribute(t) : e.setAttribute(t, "" + n)) : i.mustUseProperty ? e[i.propertyName] = n === null ? i.type === 3 ? !1 : "" : n : (t = i.attributeName, r = i.attributeNamespace, n === null ? e.removeAttribute(t) : (i = i.type, n = i === 3 || i === 4 && n === !0 ? "" : "" + n, r ? e.setAttributeNS(r, t, n) : e.setAttribute(t, n)))) } var ar = Eg.__SECRET_INTERNALS_DO_NOT_USE_OR_YOU_WILL_BE_FIRED, Po = Symbol.for("react.element"), Ii = Symbol.for("react.portal"), Oi = Symbol.for("react.fragment"), wf = Symbol.for("react.strict_mode"), tc = Symbol.for("react.profiler"), Mh = Symbol.for("react.provider"), jh = Symbol.for("react.context"), xf = Symbol.for("react.forward_ref"), nc = Symbol.for("react.suspense"), rc = Symbol.for("react.suspense_list"), vf = Symbol.for("react.memo"), gr = Symbol.for("react.lazy"), $h = Symbol.for("react.offscreen"), Sd = Symbol.iterator; function _s(e) { return e === null || typeof e != "object" ? null : (e = Sd && e[Sd] || e["@@iterator"], typeof e == "function" ? e : null) } var Ye = Object.assign, au; function Rs(e) {
  if (au === void 0) try { throw Error() } catch (n) { var t = n.stack.trim().match(/\n( *(at )?)/); au = t && t[1] || "" } return `
`+ au + e
} var lu = !1; function uu(e, t) {
  if (!e || lu) return ""; lu = !0; var n = Error.prepareStackTrace; Error.prepareStackTrace = void 0; try { if (t) if (t = function () { throw Error() }, Object.defineProperty(t.prototype, "props", { set: function () { throw Error() } }), typeof Reflect == "object" && Reflect.construct) { try { Reflect.construct(t, []) } catch (h) { var r = h } Reflect.construct(e, [], t) } else { try { t.call() } catch (h) { r = h } e.call(t.prototype) } else { try { throw Error() } catch (h) { r = h } e() } } catch (h) {
    if (h && r && typeof h.stack == "string") {
      for (var i = h.stack.split(`
`), s = r.stack.split(`
`), o = i.length - 1, a = s.length - 1; 1 <= o && 0 <= a && i[o] !== s[a];)a--; for (; 1 <= o && 0 <= a; o--, a--)if (i[o] !== s[a]) {
        if (o !== 1 || a !== 1) do if (o--, a--, 0 > a || i[o] !== s[a]) {
          var f = `
`+ i[o].replace(" at new ", " at "); return e.displayName && f.includes("<anonymous>") && (f = f.replace("<anonymous>", e.displayName)), f
        } while (1 <= o && 0 <= a); break
      }
    }
  } finally { lu = !1, Error.prepareStackTrace = n } return (e = e ? e.displayName || e.name : "") ? Rs(e) : ""
} function Bg(e) { switch (e.tag) { case 5: return Rs(e.type); case 16: return Rs("Lazy"); case 13: return Rs("Suspense"); case 19: return Rs("SuspenseList"); case 0: case 2: case 15: return e = uu(e.type, !1), e; case 11: return e = uu(e.type.render, !1), e; case 1: return e = uu(e.type, !0), e; default: return "" } } function ic(e) { if (e == null) return null; if (typeof e == "function") return e.displayName || e.name || null; if (typeof e == "string") return e; switch (e) { case Oi: return "Fragment"; case Ii: return "Portal"; case tc: return "Profiler"; case wf: return "StrictMode"; case nc: return "Suspense"; case rc: return "SuspenseList" }if (typeof e == "object") switch (e.$$typeof) { case jh: return (e.displayName || "Context") + ".Consumer"; case Mh: return (e._context.displayName || "Context") + ".Provider"; case xf: var t = e.render; return e = e.displayName, e || (e = t.displayName || t.name || "", e = e !== "" ? "ForwardRef(" + e + ")" : "ForwardRef"), e; case vf: return t = e.displayName || null, t !== null ? t : ic(e.type) || "Memo"; case gr: t = e._payload, e = e._init; try { return ic(e(t)) } catch { } }return null } function Ag(e) { var t = e.type; switch (e.tag) { case 24: return "Cache"; case 9: return (t.displayName || "Context") + ".Consumer"; case 10: return (t._context.displayName || "Context") + ".Provider"; case 18: return "DehydratedFragment"; case 11: return e = t.render, e = e.displayName || e.name || "", t.displayName || (e !== "" ? "ForwardRef(" + e + ")" : "ForwardRef"); case 7: return "Fragment"; case 5: return t; case 4: return "Portal"; case 3: return "Root"; case 6: return "Text"; case 16: return ic(t); case 8: return t === wf ? "StrictMode" : "Mode"; case 22: return "Offscreen"; case 12: return "Profiler"; case 21: return "Scope"; case 13: return "Suspense"; case 19: return "SuspenseList"; case 25: return "TracingMarker"; case 1: case 0: case 17: case 2: case 14: case 15: if (typeof t == "function") return t.displayName || t.name || null; if (typeof t == "string") return t }return null } function Fr(e) { switch (typeof e) { case "boolean": case "number": case "string": case "undefined": return e; case "object": return e; default: return "" } } function zh(e) { var t = e.type; return (e = e.nodeName) && e.toLowerCase() === "input" && (t === "checkbox" || t === "radio") } function kg(e) { var t = zh(e) ? "checked" : "value", n = Object.getOwnPropertyDescriptor(e.constructor.prototype, t), r = "" + e[t]; if (!e.hasOwnProperty(t) && typeof n < "u" && typeof n.get == "function" && typeof n.set == "function") { var i = n.get, s = n.set; return Object.defineProperty(e, t, { configurable: !0, get: function () { return i.call(this) }, set: function (o) { r = "" + o, s.call(this, o) } }), Object.defineProperty(e, t, { enumerable: n.enumerable }), { getValue: function () { return r }, setValue: function (o) { r = "" + o }, stopTracking: function () { e._valueTracker = null, delete e[t] } } } } function Mo(e) { e._valueTracker || (e._valueTracker = kg(e)) } function Vh(e) { if (!e) return !1; var t = e._valueTracker; if (!t) return !0; var n = t.getValue(), r = ""; return e && (r = zh(e) ? e.checked ? "true" : "false" : e.value), e = r, e !== n ? (t.setValue(e), !0) : !1 } function za(e) { if (e = e || (typeof document < "u" ? document : void 0), typeof e > "u") return null; try { return e.activeElement || e.body } catch { return e.body } } function sc(e, t) { var n = t.checked; return Ye({}, t, { defaultChecked: void 0, defaultValue: void 0, value: void 0, checked: n ?? e._wrapperState.initialChecked }) } function Nd(e, t) { var n = t.defaultValue == null ? "" : t.defaultValue, r = t.checked != null ? t.checked : t.defaultChecked; n = Fr(t.value != null ? t.value : n), e._wrapperState = { initialChecked: r, initialValue: n, controlled: t.type === "checkbox" || t.type === "radio" ? t.checked != null : t.value != null } } function qh(e, t) { t = t.checked, t != null && gf(e, "checked", t, !1) } function oc(e, t) { qh(e, t); var n = Fr(t.value), r = t.type; if (n != null) r === "number" ? (n === 0 && e.value === "" || e.value != n) && (e.value = "" + n) : e.value !== "" + n && (e.value = "" + n); else if (r === "submit" || r === "reset") { e.removeAttribute("value"); return } t.hasOwnProperty("value") ? ac(e, t.type, n) : t.hasOwnProperty("defaultValue") && ac(e, t.type, Fr(t.defaultValue)), t.checked == null && t.defaultChecked != null && (e.defaultChecked = !!t.defaultChecked) } function Td(e, t, n) { if (t.hasOwnProperty("value") || t.hasOwnProperty("defaultValue")) { var r = t.type; if (!(r !== "submit" && r !== "reset" || t.value !== void 0 && t.value !== null)) return; t = "" + e._wrapperState.initialValue, n || t === e.value || (e.value = t), e.defaultValue = t } n = e.name, n !== "" && (e.name = ""), e.defaultChecked = !!e._wrapperState.initialChecked, n !== "" && (e.name = n) } function ac(e, t, n) { (t !== "number" || za(e.ownerDocument) !== e) && (n == null ? e.defaultValue = "" + e._wrapperState.initialValue : e.defaultValue !== "" + n && (e.defaultValue = "" + n)) } var Is = Array.isArray; function Ki(e, t, n, r) { if (e = e.options, t) { t = {}; for (var i = 0; i < n.length; i++)t["$" + n[i]] = !0; for (n = 0; n < e.length; n++)i = t.hasOwnProperty("$" + e[n].value), e[n].selected !== i && (e[n].selected = i), i && r && (e[n].defaultSelected = !0) } else { for (n = "" + Fr(n), t = null, i = 0; i < e.length; i++) { if (e[i].value === n) { e[i].selected = !0, r && (e[i].defaultSelected = !0); return } t !== null || e[i].disabled || (t = e[i]) } t !== null && (t.selected = !0) } } function lc(e, t) { if (t.dangerouslySetInnerHTML != null) throw Error(ue(91)); return Ye({}, t, { value: void 0, defaultValue: void 0, children: "" + e._wrapperState.initialValue }) } function Bd(e, t) { var n = t.value; if (n == null) { if (n = t.children, t = t.defaultValue, n != null) { if (t != null) throw Error(ue(92)); if (Is(n)) { if (1 < n.length) throw Error(ue(93)); n = n[0] } t = n } t == null && (t = ""), n = t } e._wrapperState = { initialValue: Fr(n) } } function Hh(e, t) { var n = Fr(t.value), r = Fr(t.defaultValue); n != null && (n = "" + n, n !== e.value && (e.value = n), t.defaultValue == null && e.defaultValue !== n && (e.defaultValue = n)), r != null && (e.defaultValue = "" + r) } function Ad(e) { var t = e.textContent; t === e._wrapperState.initialValue && t !== "" && t !== null && (e.value = t) } function Gh(e) { switch (e) { case "svg": return "http://www.w3.org/2000/svg"; case "math": return "http://www.w3.org/1998/Math/MathML"; default: return "http://www.w3.org/1999/xhtml" } } function uc(e, t) { return e == null || e === "http://www.w3.org/1999/xhtml" ? Gh(t) : e === "http://www.w3.org/2000/svg" && t === "foreignObject" ? "http://www.w3.org/1999/xhtml" : e } var jo, Lh = function (e) { return typeof MSApp < "u" && MSApp.execUnsafeLocalFunction ? function (t, n, r, i) { MSApp.execUnsafeLocalFunction(function () { return e(t, n, r, i) }) } : e }(function (e, t) { if (e.namespaceURI !== "http://www.w3.org/2000/svg" || "innerHTML" in e) e.innerHTML = t; else { for (jo = jo || document.createElement("div"), jo.innerHTML = "<svg>" + t.valueOf().toString() + "</svg>", t = jo.firstChild; e.firstChild;)e.removeChild(e.firstChild); for (; t.firstChild;)e.appendChild(t.firstChild) } }); function Qs(e, t) { if (t) { var n = e.firstChild; if (n && n === e.lastChild && n.nodeType === 3) { n.nodeValue = t; return } } e.textContent = t } var Vs = { animationIterationCount: !0, aspectRatio: !0, borderImageOutset: !0, borderImageSlice: !0, borderImageWidth: !0, boxFlex: !0, boxFlexGroup: !0, boxOrdinalGroup: !0, columnCount: !0, columns: !0, flex: !0, flexGrow: !0, flexPositive: !0, flexShrink: !0, flexNegative: !0, flexOrder: !0, gridArea: !0, gridRow: !0, gridRowEnd: !0, gridRowSpan: !0, gridRowStart: !0, gridColumn: !0, gridColumnEnd: !0, gridColumnSpan: !0, gridColumnStart: !0, fontWeight: !0, lineClamp: !0, lineHeight: !0, opacity: !0, order: !0, orphans: !0, tabSize: !0, widows: !0, zIndex: !0, zoom: !0, fillOpacity: !0, floodOpacity: !0, stopOpacity: !0, strokeDasharray: !0, strokeDashoffset: !0, strokeMiterlimit: !0, strokeOpacity: !0, strokeWidth: !0 }, Rg = ["Webkit", "ms", "Moz", "O"]; Object.keys(Vs).forEach(function (e) { Rg.forEach(function (t) { t = t + e.charAt(0).toUpperCase() + e.substring(1), Vs[t] = Vs[e] }) }); function Wh(e, t, n) { return t == null || typeof t == "boolean" || t === "" ? "" : n || typeof t != "number" || t === 0 || Vs.hasOwnProperty(e) && Vs[e] ? ("" + t).trim() : t + "px" } function Yh(e, t) { e = e.style; for (var n in t) if (t.hasOwnProperty(n)) { var r = n.indexOf("--") === 0, i = Wh(n, t[n], r); n === "float" && (n = "cssFloat"), r ? e.setProperty(n, i) : e[n] = i } } var Ig = Ye({ menuitem: !0 }, { area: !0, base: !0, br: !0, col: !0, embed: !0, hr: !0, img: !0, input: !0, keygen: !0, link: !0, meta: !0, param: !0, source: !0, track: !0, wbr: !0 }); function cc(e, t) { if (t) { if (Ig[e] && (t.children != null || t.dangerouslySetInnerHTML != null)) throw Error(ue(137, e)); if (t.dangerouslySetInnerHTML != null) { if (t.children != null) throw Error(ue(60)); if (typeof t.dangerouslySetInnerHTML != "object" || !("__html" in t.dangerouslySetInnerHTML)) throw Error(ue(61)) } if (t.style != null && typeof t.style != "object") throw Error(ue(62)) } } function fc(e, t) { if (e.indexOf("-") === -1) return typeof t.is == "string"; switch (e) { case "annotation-xml": case "color-profile": case "font-face": case "font-face-src": case "font-face-uri": case "font-face-format": case "font-face-name": case "missing-glyph": return !1; default: return !0 } } var dc = null; function _f(e) { return e = e.target || e.srcElement || window, e.correspondingUseElement && (e = e.correspondingUseElement), e.nodeType === 3 ? e.parentNode : e } var hc = null, Zi = null, Xi = null; function kd(e) { if (e = So(e)) { if (typeof hc != "function") throw Error(ue(280)); var t = e.stateNode; t && (t = Bl(t), hc(e.stateNode, e.type, t)) } } function Kh(e) { Zi ? Xi ? Xi.push(e) : Xi = [e] : Zi = e } function Zh() { if (Zi) { var e = Zi, t = Xi; if (Xi = Zi = null, kd(e), t) for (e = 0; e < t.length; e++)kd(t[e]) } } function Xh(e, t) { return e(t) } function Qh() { } var cu = !1; function Dh(e, t, n) { if (cu) return e(t, n); cu = !0; try { return Xh(e, t, n) } finally { cu = !1, (Zi !== null || Xi !== null) && (Qh(), Zh()) } } function Ds(e, t) { var n = e.stateNode; if (n === null) return null; var r = Bl(n); if (r === null) return null; n = r[t]; e: switch (t) { case "onClick": case "onClickCapture": case "onDoubleClick": case "onDoubleClickCapture": case "onMouseDown": case "onMouseDownCapture": case "onMouseMove": case "onMouseMoveCapture": case "onMouseUp": case "onMouseUpCapture": case "onMouseEnter": (r = !r.disabled) || (e = e.type, r = !(e === "button" || e === "input" || e === "select" || e === "textarea")), e = !r; break e; default: e = !1 }if (e) return null; if (n && typeof n != "function") throw Error(ue(231, t, typeof n)); return n } var pc = !1; if (nr) try { var Es = {}; Object.defineProperty(Es, "passive", { get: function () { pc = !0 } }), window.addEventListener("test", Es, Es), window.removeEventListener("test", Es, Es) } catch { pc = !1 } function Og(e, t, n, r, i, s, o, a, f) { var h = Array.prototype.slice.call(arguments, 3); try { t.apply(n, h) } catch (_) { this.onError(_) } } var qs = !1, Va = null, qa = !1, mc = null, Ug = { onError: function (e) { qs = !0, Va = e } }; function Fg(e, t, n, r, i, s, o, a, f) { qs = !1, Va = null, Og.apply(Ug, arguments) } function Cg(e, t, n, r, i, s, o, a, f) { if (Fg.apply(this, arguments), qs) { if (qs) { var h = Va; qs = !1, Va = null } else throw Error(ue(198)); qa || (qa = !0, mc = h) } } function wi(e) { var t = e, n = e; if (e.alternate) for (; t.return;)t = t.return; else { e = t; do t = e, t.flags & 4098 && (n = t.return), e = t.return; while (e) } return t.tag === 3 ? n : null } function Jh(e) { if (e.tag === 13) { var t = e.memoizedState; if (t === null && (e = e.alternate, e !== null && (t = e.memoizedState)), t !== null) return t.dehydrated } return null } function Rd(e) { if (wi(e) !== e) throw Error(ue(188)) } function Pg(e) { var t = e.alternate; if (!t) { if (t = wi(e), t === null) throw Error(ue(188)); return t !== e ? null : e } for (var n = e, r = t; ;) { var i = n.return; if (i === null) break; var s = i.alternate; if (s === null) { if (r = i.return, r !== null) { n = r; continue } break } if (i.child === s.child) { for (s = i.child; s;) { if (s === n) return Rd(i), e; if (s === r) return Rd(i), t; s = s.sibling } throw Error(ue(188)) } if (n.return !== r.return) n = i, r = s; else { for (var o = !1, a = i.child; a;) { if (a === n) { o = !0, n = i, r = s; break } if (a === r) { o = !0, r = i, n = s; break } a = a.sibling } if (!o) { for (a = s.child; a;) { if (a === n) { o = !0, n = s, r = i; break } if (a === r) { o = !0, r = s, n = i; break } a = a.sibling } if (!o) throw Error(ue(189)) } } if (n.alternate !== r) throw Error(ue(190)) } if (n.tag !== 3) throw Error(ue(188)); return n.stateNode.current === n ? e : t } function ep(e) { return e = Pg(e), e !== null ? tp(e) : null } function tp(e) { if (e.tag === 5 || e.tag === 6) return e; for (e = e.child; e !== null;) { var t = tp(e); if (t !== null) return t; e = e.sibling } return null } var np = Qt.unstable_scheduleCallback, Id = Qt.unstable_cancelCallback, Mg = Qt.unstable_shouldYield, jg = Qt.unstable_requestPaint, De = Qt.unstable_now, $g = Qt.unstable_getCurrentPriorityLevel, Ef = Qt.unstable_ImmediatePriority, rp = Qt.unstable_UserBlockingPriority, Ha = Qt.unstable_NormalPriority, zg = Qt.unstable_LowPriority, ip = Qt.unstable_IdlePriority, bl = null, Mn = null; function Vg(e) { if (Mn && typeof Mn.onCommitFiberRoot == "function") try { Mn.onCommitFiberRoot(bl, e, void 0, (e.current.flags & 128) === 128) } catch { } } var vn = Math.clz32 ? Math.clz32 : Gg, qg = Math.log, Hg = Math.LN2; function Gg(e) { return e >>>= 0, e === 0 ? 32 : 31 - (qg(e) / Hg | 0) | 0 } var $o = 64, zo = 4194304; function Os(e) { switch (e & -e) { case 1: return 1; case 2: return 2; case 4: return 4; case 8: return 8; case 16: return 16; case 32: return 32; case 64: case 128: case 256: case 512: case 1024: case 2048: case 4096: case 8192: case 16384: case 32768: case 65536: case 131072: case 262144: case 524288: case 1048576: case 2097152: return e & 4194240; case 4194304: case 8388608: case 16777216: case 33554432: case 67108864: return e & 130023424; case 134217728: return 134217728; case 268435456: return 268435456; case 536870912: return 536870912; case 1073741824: return 1073741824; default: return e } } function Ga(e, t) { var n = e.pendingLanes; if (n === 0) return 0; var r = 0, i = e.suspendedLanes, s = e.pingedLanes, o = n & 268435455; if (o !== 0) { var a = o & ~i; a !== 0 ? r = Os(a) : (s &= o, s !== 0 && (r = Os(s))) } else o = n & ~i, o !== 0 ? r = Os(o) : s !== 0 && (r = Os(s)); if (r === 0) return 0; if (t !== 0 && t !== r && !(t & i) && (i = r & -r, s = t & -t, i >= s || i === 16 && (s & 4194240) !== 0)) return t; if (r & 4 && (r |= n & 16), t = e.entangledLanes, t !== 0) for (e = e.entanglements, t &= r; 0 < t;)n = 31 - vn(t), i = 1 << n, r |= e[n], t &= ~i; return r } function Lg(e, t) { switch (e) { case 1: case 2: case 4: return t + 250; case 8: case 16: case 32: case 64: case 128: case 256: case 512: case 1024: case 2048: case 4096: case 8192: case 16384: case 32768: case 65536: case 131072: case 262144: case 524288: case 1048576: case 2097152: return t + 5e3; case 4194304: case 8388608: case 16777216: case 33554432: case 67108864: return -1; case 134217728: case 268435456: case 536870912: case 1073741824: return -1; default: return -1 } } function Wg(e, t) { for (var n = e.suspendedLanes, r = e.pingedLanes, i = e.expirationTimes, s = e.pendingLanes; 0 < s;) { var o = 31 - vn(s), a = 1 << o, f = i[o]; f === -1 ? (!(a & n) || a & r) && (i[o] = Lg(a, t)) : f <= t && (e.expiredLanes |= a), s &= ~a } } function yc(e) { return e = e.pendingLanes & -1073741825, e !== 0 ? e : e & 1073741824 ? 1073741824 : 0 } function sp() { var e = $o; return $o <<= 1, !($o & 4194240) && ($o = 64), e } function fu(e) { for (var t = [], n = 0; 31 > n; n++)t.push(e); return t } function Eo(e, t, n) { e.pendingLanes |= t, t !== 536870912 && (e.suspendedLanes = 0, e.pingedLanes = 0), e = e.eventTimes, t = 31 - vn(t), e[t] = n } function Yg(e, t) { var n = e.pendingLanes & ~t; e.pendingLanes = t, e.suspendedLanes = 0, e.pingedLanes = 0, e.expiredLanes &= t, e.mutableReadLanes &= t, e.entangledLanes &= t, t = e.entanglements; var r = e.eventTimes; for (e = e.expirationTimes; 0 < n;) { var i = 31 - vn(n), s = 1 << i; t[i] = 0, r[i] = -1, e[i] = -1, n &= ~s } } function bf(e, t) { var n = e.entangledLanes |= t; for (e = e.entanglements; n;) { var r = 31 - vn(n), i = 1 << r; i & t | e[r] & t && (e[r] |= t), n &= ~i } } var Ce = 0; function op(e) { return e &= -e, 1 < e ? 4 < e ? e & 268435455 ? 16 : 536870912 : 4 : 1 } var ap, Sf, lp, up, cp, gc = !1, Vo = [], Nr = null, Tr = null, Br = null, Js = new Map, eo = new Map, _r = [], Kg = "mousedown mouseup touchcancel touchend touchstart auxclick dblclick pointercancel pointerdown pointerup dragend dragstart drop compositionend compositionstart keydown keypress keyup input textInput copy cut paste click change contextmenu reset submit".split(" "); function Od(e, t) { switch (e) { case "focusin": case "focusout": Nr = null; break; case "dragenter": case "dragleave": Tr = null; break; case "mouseover": case "mouseout": Br = null; break; case "pointerover": case "pointerout": Js.delete(t.pointerId); break; case "gotpointercapture": case "lostpointercapture": eo.delete(t.pointerId) } } function bs(e, t, n, r, i, s) { return e === null || e.nativeEvent !== s ? (e = { blockedOn: t, domEventName: n, eventSystemFlags: r, nativeEvent: s, targetContainers: [i] }, t !== null && (t = So(t), t !== null && Sf(t)), e) : (e.eventSystemFlags |= r, t = e.targetContainers, i !== null && t.indexOf(i) === -1 && t.push(i), e) } function Zg(e, t, n, r, i) { switch (t) { case "focusin": return Nr = bs(Nr, e, t, n, r, i), !0; case "dragenter": return Tr = bs(Tr, e, t, n, r, i), !0; case "mouseover": return Br = bs(Br, e, t, n, r, i), !0; case "pointerover": var s = i.pointerId; return Js.set(s, bs(Js.get(s) || null, e, t, n, r, i)), !0; case "gotpointercapture": return s = i.pointerId, eo.set(s, bs(eo.get(s) || null, e, t, n, r, i)), !0 }return !1 } function fp(e) { var t = Zr(e.target); if (t !== null) { var n = wi(t); if (n !== null) { if (t = n.tag, t === 13) { if (t = Jh(n), t !== null) { e.blockedOn = t, cp(e.priority, function () { lp(n) }); return } } else if (t === 3 && n.stateNode.current.memoizedState.isDehydrated) { e.blockedOn = n.tag === 3 ? n.stateNode.containerInfo : null; return } } } e.blockedOn = null } function fa(e) { if (e.blockedOn !== null) return !1; for (var t = e.targetContainers; 0 < t.length;) { var n = wc(e.domEventName, e.eventSystemFlags, t[0], e.nativeEvent); if (n === null) { n = e.nativeEvent; var r = new n.constructor(n.type, n); dc = r, n.target.dispatchEvent(r), dc = null } else return t = So(n), t !== null && Sf(t), e.blockedOn = n, !1; t.shift() } return !0 } function Ud(e, t, n) { fa(e) && n.delete(t) } function Xg() { gc = !1, Nr !== null && fa(Nr) && (Nr = null), Tr !== null && fa(Tr) && (Tr = null), Br !== null && fa(Br) && (Br = null), Js.forEach(Ud), eo.forEach(Ud) } function Ss(e, t) { e.blockedOn === t && (e.blockedOn = null, gc || (gc = !0, Qt.unstable_scheduleCallback(Qt.unstable_NormalPriority, Xg))) } function to(e) { function t(i) { return Ss(i, e) } if (0 < Vo.length) { Ss(Vo[0], e); for (var n = 1; n < Vo.length; n++) { var r = Vo[n]; r.blockedOn === e && (r.blockedOn = null) } } for (Nr !== null && Ss(Nr, e), Tr !== null && Ss(Tr, e), Br !== null && Ss(Br, e), Js.forEach(t), eo.forEach(t), n = 0; n < _r.length; n++)r = _r[n], r.blockedOn === e && (r.blockedOn = null); for (; 0 < _r.length && (n = _r[0], n.blockedOn === null);)fp(n), n.blockedOn === null && _r.shift() } var Qi = ar.ReactCurrentBatchConfig, La = !0; function Qg(e, t, n, r) { var i = Ce, s = Qi.transition; Qi.transition = null; try { Ce = 1, Nf(e, t, n, r) } finally { Ce = i, Qi.transition = s } } function Dg(e, t, n, r) { var i = Ce, s = Qi.transition; Qi.transition = null; try { Ce = 4, Nf(e, t, n, r) } finally { Ce = i, Qi.transition = s } } function Nf(e, t, n, r) { if (La) { var i = wc(e, t, n, r); if (i === null) _u(e, t, r, Wa, n), Od(e, r); else if (Zg(i, e, t, n, r)) r.stopPropagation(); else if (Od(e, r), t & 4 && -1 < Kg.indexOf(e)) { for (; i !== null;) { var s = So(i); if (s !== null && ap(s), s = wc(e, t, n, r), s === null && _u(e, t, r, Wa, n), s === i) break; i = s } i !== null && r.stopPropagation() } else _u(e, t, r, null, n) } } var Wa = null; function wc(e, t, n, r) { if (Wa = null, e = _f(r), e = Zr(e), e !== null) if (t = wi(e), t === null) e = null; else if (n = t.tag, n === 13) { if (e = Jh(t), e !== null) return e; e = null } else if (n === 3) { if (t.stateNode.current.memoizedState.isDehydrated) return t.tag === 3 ? t.stateNode.containerInfo : null; e = null } else t !== e && (e = null); return Wa = e, null } function dp(e) { switch (e) { case "cancel": case "click": case "close": case "contextmenu": case "copy": case "cut": case "auxclick": case "dblclick": case "dragend": case "dragstart": case "drop": case "focusin": case "focusout": case "input": case "invalid": case "keydown": case "keypress": case "keyup": case "mousedown": case "mouseup": case "paste": case "pause": case "play": case "pointercancel": case "pointerdown": case "pointerup": case "ratechange": case "reset": case "resize": case "seeked": case "submit": case "touchcancel": case "touchend": case "touchstart": case "volumechange": case "change": case "selectionchange": case "textInput": case "compositionstart": case "compositionend": case "compositionupdate": case "beforeblur": case "afterblur": case "beforeinput": case "blur": case "fullscreenchange": case "focus": case "hashchange": case "popstate": case "select": case "selectstart": return 1; case "drag": case "dragenter": case "dragexit": case "dragleave": case "dragover": case "mousemove": case "mouseout": case "mouseover": case "pointermove": case "pointerout": case "pointerover": case "scroll": case "toggle": case "touchmove": case "wheel": case "mouseenter": case "mouseleave": case "pointerenter": case "pointerleave": return 4; case "message": switch ($g()) { case Ef: return 1; case rp: return 4; case Ha: case zg: return 16; case ip: return 536870912; default: return 16 }default: return 16 } } var br = null, Tf = null, da = null; function hp() { if (da) return da; var e, t = Tf, n = t.length, r, i = "value" in br ? br.value : br.textContent, s = i.length; for (e = 0; e < n && t[e] === i[e]; e++); var o = n - e; for (r = 1; r <= o && t[n - r] === i[s - r]; r++); return da = i.slice(e, 1 < r ? 1 - r : void 0) } function ha(e) { var t = e.keyCode; return "charCode" in e ? (e = e.charCode, e === 0 && t === 13 && (e = 13)) : e = t, e === 10 && (e = 13), 32 <= e || e === 13 ? e : 0 } function qo() { return !0 } function Fd() { return !1 } function Jt(e) { function t(n, r, i, s, o) { this._reactName = n, this._targetInst = i, this.type = r, this.nativeEvent = s, this.target = o, this.currentTarget = null; for (var a in e) e.hasOwnProperty(a) && (n = e[a], this[a] = n ? n(s) : s[a]); return this.isDefaultPrevented = (s.defaultPrevented != null ? s.defaultPrevented : s.returnValue === !1) ? qo : Fd, this.isPropagationStopped = Fd, this } return Ye(t.prototype, { preventDefault: function () { this.defaultPrevented = !0; var n = this.nativeEvent; n && (n.preventDefault ? n.preventDefault() : typeof n.returnValue != "unknown" && (n.returnValue = !1), this.isDefaultPrevented = qo) }, stopPropagation: function () { var n = this.nativeEvent; n && (n.stopPropagation ? n.stopPropagation() : typeof n.cancelBubble != "unknown" && (n.cancelBubble = !0), this.isPropagationStopped = qo) }, persist: function () { }, isPersistent: qo }), t } var ys = { eventPhase: 0, bubbles: 0, cancelable: 0, timeStamp: function (e) { return e.timeStamp || Date.now() }, defaultPrevented: 0, isTrusted: 0 }, Bf = Jt(ys), bo = Ye({}, ys, { view: 0, detail: 0 }), Jg = Jt(bo), du, hu, Ns, Sl = Ye({}, bo, { screenX: 0, screenY: 0, clientX: 0, clientY: 0, pageX: 0, pageY: 0, ctrlKey: 0, shiftKey: 0, altKey: 0, metaKey: 0, getModifierState: Af, button: 0, buttons: 0, relatedTarget: function (e) { return e.relatedTarget === void 0 ? e.fromElement === e.srcElement ? e.toElement : e.fromElement : e.relatedTarget }, movementX: function (e) { return "movementX" in e ? e.movementX : (e !== Ns && (Ns && e.type === "mousemove" ? (du = e.screenX - Ns.screenX, hu = e.screenY - Ns.screenY) : hu = du = 0, Ns = e), du) }, movementY: function (e) { return "movementY" in e ? e.movementY : hu } }), Cd = Jt(Sl), ew = Ye({}, Sl, { dataTransfer: 0 }), tw = Jt(ew), nw = Ye({}, bo, { relatedTarget: 0 }), pu = Jt(nw), rw = Ye({}, ys, { animationName: 0, elapsedTime: 0, pseudoElement: 0 }), iw = Jt(rw), sw = Ye({}, ys, { clipboardData: function (e) { return "clipboardData" in e ? e.clipboardData : window.clipboardData } }), ow = Jt(sw), aw = Ye({}, ys, { data: 0 }), Pd = Jt(aw), lw = { Esc: "Escape", Spacebar: " ", Left: "ArrowLeft", Up: "ArrowUp", Right: "ArrowRight", Down: "ArrowDown", Del: "Delete", Win: "OS", Menu: "ContextMenu", Apps: "ContextMenu", Scroll: "ScrollLock", MozPrintableKey: "Unidentified" }, uw = { 8: "Backspace", 9: "Tab", 12: "Clear", 13: "Enter", 16: "Shift", 17: "Control", 18: "Alt", 19: "Pause", 20: "CapsLock", 27: "Escape", 32: " ", 33: "PageUp", 34: "PageDown", 35: "End", 36: "Home", 37: "ArrowLeft", 38: "ArrowUp", 39: "ArrowRight", 40: "ArrowDown", 45: "Insert", 46: "Delete", 112: "F1", 113: "F2", 114: "F3", 115: "F4", 116: "F5", 117: "F6", 118: "F7", 119: "F8", 120: "F9", 121: "F10", 122: "F11", 123: "F12", 144: "NumLock", 145: "ScrollLock", 224: "Meta" }, cw = { Alt: "altKey", Control: "ctrlKey", Meta: "metaKey", Shift: "shiftKey" }; function fw(e) { var t = this.nativeEvent; return t.getModifierState ? t.getModifierState(e) : (e = cw[e]) ? !!t[e] : !1 } function Af() { return fw } var dw = Ye({}, bo, { key: function (e) { if (e.key) { var t = lw[e.key] || e.key; if (t !== "Unidentified") return t } return e.type === "keypress" ? (e = ha(e), e === 13 ? "Enter" : String.fromCharCode(e)) : e.type === "keydown" || e.type === "keyup" ? uw[e.keyCode] || "Unidentified" : "" }, code: 0, location: 0, ctrlKey: 0, shiftKey: 0, altKey: 0, metaKey: 0, repeat: 0, locale: 0, getModifierState: Af, charCode: function (e) { return e.type === "keypress" ? ha(e) : 0 }, keyCode: function (e) { return e.type === "keydown" || e.type === "keyup" ? e.keyCode : 0 }, which: function (e) { return e.type === "keypress" ? ha(e) : e.type === "keydown" || e.type === "keyup" ? e.keyCode : 0 } }), hw = Jt(dw), pw = Ye({}, Sl, { pointerId: 0, width: 0, height: 0, pressure: 0, tangentialPressure: 0, tiltX: 0, tiltY: 0, twist: 0, pointerType: 0, isPrimary: 0 }), Md = Jt(pw), mw = Ye({}, bo, { touches: 0, targetTouches: 0, changedTouches: 0, altKey: 0, metaKey: 0, ctrlKey: 0, shiftKey: 0, getModifierState: Af }), yw = Jt(mw), gw = Ye({}, ys, { propertyName: 0, elapsedTime: 0, pseudoElement: 0 }), ww = Jt(gw), xw = Ye({}, Sl, { deltaX: function (e) { return "deltaX" in e ? e.deltaX : "wheelDeltaX" in e ? -e.wheelDeltaX : 0 }, deltaY: function (e) { return "deltaY" in e ? e.deltaY : "wheelDeltaY" in e ? -e.wheelDeltaY : "wheelDelta" in e ? -e.wheelDelta : 0 }, deltaZ: 0, deltaMode: 0 }), vw = Jt(xw), _w = [9, 13, 27, 32], kf = nr && "CompositionEvent" in window, Hs = null; nr && "documentMode" in document && (Hs = document.documentMode); var Ew = nr && "TextEvent" in window && !Hs, pp = nr && (!kf || Hs && 8 < Hs && 11 >= Hs), jd = " ", $d = !1; function mp(e, t) { switch (e) { case "keyup": return _w.indexOf(t.keyCode) !== -1; case "keydown": return t.keyCode !== 229; case "keypress": case "mousedown": case "focusout": return !0; default: return !1 } } function yp(e) { return e = e.detail, typeof e == "object" && "data" in e ? e.data : null } var Ui = !1; function bw(e, t) { switch (e) { case "compositionend": return yp(t); case "keypress": return t.which !== 32 ? null : ($d = !0, jd); case "textInput": return e = t.data, e === jd && $d ? null : e; default: return null } } function Sw(e, t) { if (Ui) return e === "compositionend" || !kf && mp(e, t) ? (e = hp(), da = Tf = br = null, Ui = !1, e) : null; switch (e) { case "paste": return null; case "keypress": if (!(t.ctrlKey || t.altKey || t.metaKey) || t.ctrlKey && t.altKey) { if (t.char && 1 < t.char.length) return t.char; if (t.which) return String.fromCharCode(t.which) } return null; case "compositionend": return pp && t.locale !== "ko" ? null : t.data; default: return null } } var Nw = { color: !0, date: !0, datetime: !0, "datetime-local": !0, email: !0, month: !0, number: !0, password: !0, range: !0, search: !0, tel: !0, text: !0, time: !0, url: !0, week: !0 }; function zd(e) { var t = e && e.nodeName && e.nodeName.toLowerCase(); return t === "input" ? !!Nw[e.type] : t === "textarea" } function gp(e, t, n, r) { Kh(r), t = Ya(t, "onChange"), 0 < t.length && (n = new Bf("onChange", "change", null, n, r), e.push({ event: n, listeners: t })) } var Gs = null, no = null; function Tw(e) { Ap(e, 0) } function Nl(e) { var t = Pi(e); if (Vh(t)) return e } function Bw(e, t) { if (e === "change") return t } var wp = !1; if (nr) { var mu; if (nr) { var yu = "oninput" in document; if (!yu) { var Vd = document.createElement("div"); Vd.setAttribute("oninput", "return;"), yu = typeof Vd.oninput == "function" } mu = yu } else mu = !1; wp = mu && (!document.documentMode || 9 < document.documentMode) } function qd() { Gs && (Gs.detachEvent("onpropertychange", xp), no = Gs = null) } function xp(e) { if (e.propertyName === "value" && Nl(no)) { var t = []; gp(t, no, e, _f(e)), Dh(Tw, t) } } function Aw(e, t, n) { e === "focusin" ? (qd(), Gs = t, no = n, Gs.attachEvent("onpropertychange", xp)) : e === "focusout" && qd() } function kw(e) { if (e === "selectionchange" || e === "keyup" || e === "keydown") return Nl(no) } function Rw(e, t) { if (e === "click") return Nl(t) } function Iw(e, t) { if (e === "input" || e === "change") return Nl(t) } function Ow(e, t) { return e === t && (e !== 0 || 1 / e === 1 / t) || e !== e && t !== t } var En = typeof Object.is == "function" ? Object.is : Ow; function ro(e, t) { if (En(e, t)) return !0; if (typeof e != "object" || e === null || typeof t != "object" || t === null) return !1; var n = Object.keys(e), r = Object.keys(t); if (n.length !== r.length) return !1; for (r = 0; r < n.length; r++) { var i = n[r]; if (!ec.call(t, i) || !En(e[i], t[i])) return !1 } return !0 } function Hd(e) { for (; e && e.firstChild;)e = e.firstChild; return e } function Gd(e, t) { var n = Hd(e); e = 0; for (var r; n;) { if (n.nodeType === 3) { if (r = e + n.textContent.length, e <= t && r >= t) return { node: n, offset: t - e }; e = r } e: { for (; n;) { if (n.nextSibling) { n = n.nextSibling; break e } n = n.parentNode } n = void 0 } n = Hd(n) } } function vp(e, t) { return e && t ? e === t ? !0 : e && e.nodeType === 3 ? !1 : t && t.nodeType === 3 ? vp(e, t.parentNode) : "contains" in e ? e.contains(t) : e.compareDocumentPosition ? !!(e.compareDocumentPosition(t) & 16) : !1 : !1 } function _p() { for (var e = window, t = za(); t instanceof e.HTMLIFrameElement;) { try { var n = typeof t.contentWindow.location.href == "string" } catch { n = !1 } if (n) e = t.contentWindow; else break; t = za(e.document) } return t } function Rf(e) { var t = e && e.nodeName && e.nodeName.toLowerCase(); return t && (t === "input" && (e.type === "text" || e.type === "search" || e.type === "tel" || e.type === "url" || e.type === "password") || t === "textarea" || e.contentEditable === "true") } function Uw(e) { var t = _p(), n = e.focusedElem, r = e.selectionRange; if (t !== n && n && n.ownerDocument && vp(n.ownerDocument.documentElement, n)) { if (r !== null && Rf(n)) { if (t = r.start, e = r.end, e === void 0 && (e = t), "selectionStart" in n) n.selectionStart = t, n.selectionEnd = Math.min(e, n.value.length); else if (e = (t = n.ownerDocument || document) && t.defaultView || window, e.getSelection) { e = e.getSelection(); var i = n.textContent.length, s = Math.min(r.start, i); r = r.end === void 0 ? s : Math.min(r.end, i), !e.extend && s > r && (i = r, r = s, s = i), i = Gd(n, s); var o = Gd(n, r); i && o && (e.rangeCount !== 1 || e.anchorNode !== i.node || e.anchorOffset !== i.offset || e.focusNode !== o.node || e.focusOffset !== o.offset) && (t = t.createRange(), t.setStart(i.node, i.offset), e.removeAllRanges(), s > r ? (e.addRange(t), e.extend(o.node, o.offset)) : (t.setEnd(o.node, o.offset), e.addRange(t))) } } for (t = [], e = n; e = e.parentNode;)e.nodeType === 1 && t.push({ element: e, left: e.scrollLeft, top: e.scrollTop }); for (typeof n.focus == "function" && n.focus(), n = 0; n < t.length; n++)e = t[n], e.element.scrollLeft = e.left, e.element.scrollTop = e.top } } var Fw = nr && "documentMode" in document && 11 >= document.documentMode, Fi = null, xc = null, Ls = null, vc = !1; function Ld(e, t, n) { var r = n.window === n ? n.document : n.nodeType === 9 ? n : n.ownerDocument; vc || Fi == null || Fi !== za(r) || (r = Fi, "selectionStart" in r && Rf(r) ? r = { start: r.selectionStart, end: r.selectionEnd } : (r = (r.ownerDocument && r.ownerDocument.defaultView || window).getSelection(), r = { anchorNode: r.anchorNode, anchorOffset: r.anchorOffset, focusNode: r.focusNode, focusOffset: r.focusOffset }), Ls && ro(Ls, r) || (Ls = r, r = Ya(xc, "onSelect"), 0 < r.length && (t = new Bf("onSelect", "select", null, t, n), e.push({ event: t, listeners: r }), t.target = Fi))) } function Ho(e, t) { var n = {}; return n[e.toLowerCase()] = t.toLowerCase(), n["Webkit" + e] = "webkit" + t, n["Moz" + e] = "moz" + t, n } var Ci = { animationend: Ho("Animation", "AnimationEnd"), animationiteration: Ho("Animation", "AnimationIteration"), animationstart: Ho("Animation", "AnimationStart"), transitionend: Ho("Transition", "TransitionEnd") }, gu = {}, Ep = {}; nr && (Ep = document.createElement("div").style, "AnimationEvent" in window || (delete Ci.animationend.animation, delete Ci.animationiteration.animation, delete Ci.animationstart.animation), "TransitionEvent" in window || delete Ci.transitionend.transition); function Tl(e) { if (gu[e]) return gu[e]; if (!Ci[e]) return e; var t = Ci[e], n; for (n in t) if (t.hasOwnProperty(n) && n in Ep) return gu[e] = t[n]; return e } var bp = Tl("animationend"), Sp = Tl("animationiteration"), Np = Tl("animationstart"), Tp = Tl("transitionend"), Bp = new Map, Wd = "abort auxClick cancel canPlay canPlayThrough click close contextMenu copy cut drag dragEnd dragEnter dragExit dragLeave dragOver dragStart drop durationChange emptied encrypted ended error gotPointerCapture input invalid keyDown keyPress keyUp load loadedData loadedMetadata loadStart lostPointerCapture mouseDown mouseMove mouseOut mouseOver mouseUp paste pause play playing pointerCancel pointerDown pointerMove pointerOut pointerOver pointerUp progress rateChange reset resize seeked seeking stalled submit suspend timeUpdate touchCancel touchEnd touchStart volumeChange scroll toggle touchMove waiting wheel".split(" "); function Pr(e, t) { Bp.set(e, t), gi(t, [e]) } for (var wu = 0; wu < Wd.length; wu++) { var xu = Wd[wu], Cw = xu.toLowerCase(), Pw = xu[0].toUpperCase() + xu.slice(1); Pr(Cw, "on" + Pw) } Pr(bp, "onAnimationEnd"); Pr(Sp, "onAnimationIteration"); Pr(Np, "onAnimationStart"); Pr("dblclick", "onDoubleClick"); Pr("focusin", "onFocus"); Pr("focusout", "onBlur"); Pr(Tp, "onTransitionEnd"); rs("onMouseEnter", ["mouseout", "mouseover"]); rs("onMouseLeave", ["mouseout", "mouseover"]); rs("onPointerEnter", ["pointerout", "pointerover"]); rs("onPointerLeave", ["pointerout", "pointerover"]); gi("onChange", "change click focusin focusout input keydown keyup selectionchange".split(" ")); gi("onSelect", "focusout contextmenu dragend focusin keydown keyup mousedown mouseup selectionchange".split(" ")); gi("onBeforeInput", ["compositionend", "keypress", "textInput", "paste"]); gi("onCompositionEnd", "compositionend focusout keydown keypress keyup mousedown".split(" ")); gi("onCompositionStart", "compositionstart focusout keydown keypress keyup mousedown".split(" ")); gi("onCompositionUpdate", "compositionupdate focusout keydown keypress keyup mousedown".split(" ")); var Us = "abort canplay canplaythrough durationchange emptied encrypted ended error loadeddata loadedmetadata loadstart pause play playing progress ratechange resize seeked seeking stalled suspend timeupdate volumechange waiting".split(" "), Mw = new Set("cancel close invalid load scroll toggle".split(" ").concat(Us)); function Yd(e, t, n) { var r = e.type || "unknown-event"; e.currentTarget = n, Cg(r, t, void 0, e), e.currentTarget = null } function Ap(e, t) { t = (t & 4) !== 0; for (var n = 0; n < e.length; n++) { var r = e[n], i = r.event; r = r.listeners; e: { var s = void 0; if (t) for (var o = r.length - 1; 0 <= o; o--) { var a = r[o], f = a.instance, h = a.currentTarget; if (a = a.listener, f !== s && i.isPropagationStopped()) break e; Yd(i, a, h), s = f } else for (o = 0; o < r.length; o++) { if (a = r[o], f = a.instance, h = a.currentTarget, a = a.listener, f !== s && i.isPropagationStopped()) break e; Yd(i, a, h), s = f } } } if (qa) throw e = mc, qa = !1, mc = null, e } function qe(e, t) { var n = t[Nc]; n === void 0 && (n = t[Nc] = new Set); var r = e + "__bubble"; n.has(r) || (kp(t, e, 2, !1), n.add(r)) } function vu(e, t, n) { var r = 0; t && (r |= 4), kp(n, e, r, t) } var Go = "_reactListening" + Math.random().toString(36).slice(2); function io(e) { if (!e[Go]) { e[Go] = !0, Ph.forEach(function (n) { n !== "selectionchange" && (Mw.has(n) || vu(n, !1, e), vu(n, !0, e)) }); var t = e.nodeType === 9 ? e : e.ownerDocument; t === null || t[Go] || (t[Go] = !0, vu("selectionchange", !1, t)) } } function kp(e, t, n, r) { switch (dp(t)) { case 1: var i = Qg; break; case 4: i = Dg; break; default: i = Nf }n = i.bind(null, t, n, e), i = void 0, !pc || t !== "touchstart" && t !== "touchmove" && t !== "wheel" || (i = !0), r ? i !== void 0 ? e.addEventListener(t, n, { capture: !0, passive: i }) : e.addEventListener(t, n, !0) : i !== void 0 ? e.addEventListener(t, n, { passive: i }) : e.addEventListener(t, n, !1) } function _u(e, t, n, r, i) { var s = r; if (!(t & 1) && !(t & 2) && r !== null) e: for (; ;) { if (r === null) return; var o = r.tag; if (o === 3 || o === 4) { var a = r.stateNode.containerInfo; if (a === i || a.nodeType === 8 && a.parentNode === i) break; if (o === 4) for (o = r.return; o !== null;) { var f = o.tag; if ((f === 3 || f === 4) && (f = o.stateNode.containerInfo, f === i || f.nodeType === 8 && f.parentNode === i)) return; o = o.return } for (; a !== null;) { if (o = Zr(a), o === null) return; if (f = o.tag, f === 5 || f === 6) { r = s = o; continue e } a = a.parentNode } } r = r.return } Dh(function () { var h = s, _ = _f(n), v = []; e: { var y = Bp.get(e); if (y !== void 0) { var w = Bf, p = e; switch (e) { case "keypress": if (ha(n) === 0) break e; case "keydown": case "keyup": w = hw; break; case "focusin": p = "focus", w = pu; break; case "focusout": p = "blur", w = pu; break; case "beforeblur": case "afterblur": w = pu; break; case "click": if (n.button === 2) break e; case "auxclick": case "dblclick": case "mousedown": case "mousemove": case "mouseup": case "mouseout": case "mouseover": case "contextmenu": w = Cd; break; case "drag": case "dragend": case "dragenter": case "dragexit": case "dragleave": case "dragover": case "dragstart": case "drop": w = tw; break; case "touchcancel": case "touchend": case "touchmove": case "touchstart": w = yw; break; case bp: case Sp: case Np: w = iw; break; case Tp: w = ww; break; case "scroll": w = Jg; break; case "wheel": w = vw; break; case "copy": case "cut": case "paste": w = ow; break; case "gotpointercapture": case "lostpointercapture": case "pointercancel": case "pointerdown": case "pointermove": case "pointerout": case "pointerover": case "pointerup": w = Md }var O = (t & 4) !== 0, $ = !O && e === "scroll", b = O ? y !== null ? y + "Capture" : null : y; O = []; for (var E = h, S; E !== null;) { S = E; var M = S.stateNode; if (S.tag === 5 && M !== null && (S = M, b !== null && (M = Ds(E, b), M != null && O.push(so(E, M, S)))), $) break; E = E.return } 0 < O.length && (y = new w(y, p, null, n, _), v.push({ event: y, listeners: O })) } } if (!(t & 7)) { e: { if (y = e === "mouseover" || e === "pointerover", w = e === "mouseout" || e === "pointerout", y && n !== dc && (p = n.relatedTarget || n.fromElement) && (Zr(p) || p[rr])) break e; if ((w || y) && (y = _.window === _ ? _ : (y = _.ownerDocument) ? y.defaultView || y.parentWindow : window, w ? (p = n.relatedTarget || n.toElement, w = h, p = p ? Zr(p) : null, p !== null && ($ = wi(p), p !== $ || p.tag !== 5 && p.tag !== 6) && (p = null)) : (w = null, p = h), w !== p)) { if (O = Cd, M = "onMouseLeave", b = "onMouseEnter", E = "mouse", (e === "pointerout" || e === "pointerover") && (O = Md, M = "onPointerLeave", b = "onPointerEnter", E = "pointer"), $ = w == null ? y : Pi(w), S = p == null ? y : Pi(p), y = new O(M, E + "leave", w, n, _), y.target = $, y.relatedTarget = S, M = null, Zr(_) === h && (O = new O(b, E + "enter", p, n, _), O.target = S, O.relatedTarget = $, M = O), $ = M, w && p) t: { for (O = w, b = p, E = 0, S = O; S; S = xi(S))E++; for (S = 0, M = b; M; M = xi(M))S++; for (; 0 < E - S;)O = xi(O), E--; for (; 0 < S - E;)b = xi(b), S--; for (; E--;) { if (O === b || b !== null && O === b.alternate) break t; O = xi(O), b = xi(b) } O = null } else O = null; w !== null && Kd(v, y, w, O, !1), p !== null && $ !== null && Kd(v, $, p, O, !0) } } e: { if (y = h ? Pi(h) : window, w = y.nodeName && y.nodeName.toLowerCase(), w === "select" || w === "input" && y.type === "file") var k = Bw; else if (zd(y)) if (wp) k = Iw; else { k = kw; var C = Aw } else (w = y.nodeName) && w.toLowerCase() === "input" && (y.type === "checkbox" || y.type === "radio") && (k = Rw); if (k && (k = k(e, h))) { gp(v, k, n, _); break e } C && C(e, y, h), e === "focusout" && (C = y._wrapperState) && C.controlled && y.type === "number" && ac(y, "number", y.value) } switch (C = h ? Pi(h) : window, e) { case "focusin": (zd(C) || C.contentEditable === "true") && (Fi = C, xc = h, Ls = null); break; case "focusout": Ls = xc = Fi = null; break; case "mousedown": vc = !0; break; case "contextmenu": case "mouseup": case "dragend": vc = !1, Ld(v, n, _); break; case "selectionchange": if (Fw) break; case "keydown": case "keyup": Ld(v, n, _) }var V; if (kf) e: { switch (e) { case "compositionstart": var Y = "onCompositionStart"; break e; case "compositionend": Y = "onCompositionEnd"; break e; case "compositionupdate": Y = "onCompositionUpdate"; break e }Y = void 0 } else Ui ? mp(e, n) && (Y = "onCompositionEnd") : e === "keydown" && n.keyCode === 229 && (Y = "onCompositionStart"); Y && (pp && n.locale !== "ko" && (Ui || Y !== "onCompositionStart" ? Y === "onCompositionEnd" && Ui && (V = hp()) : (br = _, Tf = "value" in br ? br.value : br.textContent, Ui = !0)), C = Ya(h, Y), 0 < C.length && (Y = new Pd(Y, e, null, n, _), v.push({ event: Y, listeners: C }), V ? Y.data = V : (V = yp(n), V !== null && (Y.data = V)))), (V = Ew ? bw(e, n) : Sw(e, n)) && (h = Ya(h, "onBeforeInput"), 0 < h.length && (_ = new Pd("onBeforeInput", "beforeinput", null, n, _), v.push({ event: _, listeners: h }), _.data = V)) } Ap(v, t) }) } function so(e, t, n) { return { instance: e, listener: t, currentTarget: n } } function Ya(e, t) { for (var n = t + "Capture", r = []; e !== null;) { var i = e, s = i.stateNode; i.tag === 5 && s !== null && (i = s, s = Ds(e, n), s != null && r.unshift(so(e, s, i)), s = Ds(e, t), s != null && r.push(so(e, s, i))), e = e.return } return r } function xi(e) { if (e === null) return null; do e = e.return; while (e && e.tag !== 5); return e || null } function Kd(e, t, n, r, i) { for (var s = t._reactName, o = []; n !== null && n !== r;) { var a = n, f = a.alternate, h = a.stateNode; if (f !== null && f === r) break; a.tag === 5 && h !== null && (a = h, i ? (f = Ds(n, s), f != null && o.unshift(so(n, f, a))) : i || (f = Ds(n, s), f != null && o.push(so(n, f, a)))), n = n.return } o.length !== 0 && e.push({ event: t, listeners: o }) } var jw = /\r\n?/g, $w = /\u0000|\uFFFD/g; function Zd(e) {
  return (typeof e == "string" ? e : "" + e).replace(jw, `
`).replace($w, "")
} function Lo(e, t, n) { if (t = Zd(t), Zd(e) !== t && n) throw Error(ue(425)) } function Ka() { } var _c = null, Ec = null; function bc(e, t) { return e === "textarea" || e === "noscript" || typeof t.children == "string" || typeof t.children == "number" || typeof t.dangerouslySetInnerHTML == "object" && t.dangerouslySetInnerHTML !== null && t.dangerouslySetInnerHTML.__html != null } var Sc = typeof setTimeout == "function" ? setTimeout : void 0, zw = typeof clearTimeout == "function" ? clearTimeout : void 0, Xd = typeof Promise == "function" ? Promise : void 0, Vw = typeof queueMicrotask == "function" ? queueMicrotask : typeof Xd < "u" ? function (e) { return Xd.resolve(null).then(e).catch(qw) } : Sc; function qw(e) { setTimeout(function () { throw e }) } function Eu(e, t) { var n = t, r = 0; do { var i = n.nextSibling; if (e.removeChild(n), i && i.nodeType === 8) if (n = i.data, n === "/$") { if (r === 0) { e.removeChild(i), to(t); return } r-- } else n !== "$" && n !== "$?" && n !== "$!" || r++; n = i } while (n); to(t) } function Ar(e) { for (; e != null; e = e.nextSibling) { var t = e.nodeType; if (t === 1 || t === 3) break; if (t === 8) { if (t = e.data, t === "$" || t === "$!" || t === "$?") break; if (t === "/$") return null } } return e } function Qd(e) { e = e.previousSibling; for (var t = 0; e;) { if (e.nodeType === 8) { var n = e.data; if (n === "$" || n === "$!" || n === "$?") { if (t === 0) return e; t-- } else n === "/$" && t++ } e = e.previousSibling } return null } var gs = Math.random().toString(36).slice(2), Fn = "__reactFiber$" + gs, oo = "__reactProps$" + gs, rr = "__reactContainer$" + gs, Nc = "__reactEvents$" + gs, Hw = "__reactListeners$" + gs, Gw = "__reactHandles$" + gs; function Zr(e) { var t = e[Fn]; if (t) return t; for (var n = e.parentNode; n;) { if (t = n[rr] || n[Fn]) { if (n = t.alternate, t.child !== null || n !== null && n.child !== null) for (e = Qd(e); e !== null;) { if (n = e[Fn]) return n; e = Qd(e) } return t } e = n, n = e.parentNode } return null } function So(e) { return e = e[Fn] || e[rr], !e || e.tag !== 5 && e.tag !== 6 && e.tag !== 13 && e.tag !== 3 ? null : e } function Pi(e) { if (e.tag === 5 || e.tag === 6) return e.stateNode; throw Error(ue(33)) } function Bl(e) { return e[oo] || null } var Tc = [], Mi = -1; function Mr(e) { return { current: e } } function He(e) { 0 > Mi || (e.current = Tc[Mi], Tc[Mi] = null, Mi--) } function Ve(e, t) { Mi++, Tc[Mi] = e.current, e.current = t } var Cr = {}, Rt = Mr(Cr), Gt = Mr(!1), ai = Cr; function is(e, t) { var n = e.type.contextTypes; if (!n) return Cr; var r = e.stateNode; if (r && r.__reactInternalMemoizedUnmaskedChildContext === t) return r.__reactInternalMemoizedMaskedChildContext; var i = {}, s; for (s in n) i[s] = t[s]; return r && (e = e.stateNode, e.__reactInternalMemoizedUnmaskedChildContext = t, e.__reactInternalMemoizedMaskedChildContext = i), i } function Lt(e) { return e = e.childContextTypes, e != null } function Za() { He(Gt), He(Rt) } function Dd(e, t, n) { if (Rt.current !== Cr) throw Error(ue(168)); Ve(Rt, t), Ve(Gt, n) } function Rp(e, t, n) { var r = e.stateNode; if (t = t.childContextTypes, typeof r.getChildContext != "function") return n; r = r.getChildContext(); for (var i in r) if (!(i in t)) throw Error(ue(108, Ag(e) || "Unknown", i)); return Ye({}, n, r) } function Xa(e) { return e = (e = e.stateNode) && e.__reactInternalMemoizedMergedChildContext || Cr, ai = Rt.current, Ve(Rt, e), Ve(Gt, Gt.current), !0 } function Jd(e, t, n) { var r = e.stateNode; if (!r) throw Error(ue(169)); n ? (e = Rp(e, t, ai), r.__reactInternalMemoizedMergedChildContext = e, He(Gt), He(Rt), Ve(Rt, e)) : He(Gt), Ve(Gt, n) } var Yn = null, Al = !1, bu = !1; function Ip(e) { Yn === null ? Yn = [e] : Yn.push(e) } function Lw(e) { Al = !0, Ip(e) } function jr() { if (!bu && Yn !== null) { bu = !0; var e = 0, t = Ce; try { var n = Yn; for (Ce = 1; e < n.length; e++) { var r = n[e]; do r = r(!0); while (r !== null) } Yn = null, Al = !1 } catch (i) { throw Yn !== null && (Yn = Yn.slice(e + 1)), np(Ef, jr), i } finally { Ce = t, bu = !1 } } return null } var ji = [], $i = 0, Qa = null, Da = 0, nn = [], rn = 0, li = null, Xn = 1, Qn = ""; function Vr(e, t) { ji[$i++] = Da, ji[$i++] = Qa, Qa = e, Da = t } function Op(e, t, n) { nn[rn++] = Xn, nn[rn++] = Qn, nn[rn++] = li, li = e; var r = Xn; e = Qn; var i = 32 - vn(r) - 1; r &= ~(1 << i), n += 1; var s = 32 - vn(t) + i; if (30 < s) { var o = i - i % 5; s = (r & (1 << o) - 1).toString(32), r >>= o, i -= o, Xn = 1 << 32 - vn(t) + i | n << i | r, Qn = s + e } else Xn = 1 << s | n << i | r, Qn = e } function If(e) { e.return !== null && (Vr(e, 1), Op(e, 1, 0)) } function Of(e) { for (; e === Qa;)Qa = ji[--$i], ji[$i] = null, Da = ji[--$i], ji[$i] = null; for (; e === li;)li = nn[--rn], nn[rn] = null, Qn = nn[--rn], nn[rn] = null, Xn = nn[--rn], nn[rn] = null } var Xt = null, Zt = null, Ge = !1, wn = null; function Up(e, t) { var n = on(5, null, null, 0); n.elementType = "DELETED", n.stateNode = t, n.return = e, t = e.deletions, t === null ? (e.deletions = [n], e.flags |= 16) : t.push(n) } function e0(e, t) { switch (e.tag) { case 5: var n = e.type; return t = t.nodeType !== 1 || n.toLowerCase() !== t.nodeName.toLowerCase() ? null : t, t !== null ? (e.stateNode = t, Xt = e, Zt = Ar(t.firstChild), !0) : !1; case 6: return t = e.pendingProps === "" || t.nodeType !== 3 ? null : t, t !== null ? (e.stateNode = t, Xt = e, Zt = null, !0) : !1; case 13: return t = t.nodeType !== 8 ? null : t, t !== null ? (n = li !== null ? { id: Xn, overflow: Qn } : null, e.memoizedState = { dehydrated: t, treeContext: n, retryLane: 1073741824 }, n = on(18, null, null, 0), n.stateNode = t, n.return = e, e.child = n, Xt = e, Zt = null, !0) : !1; default: return !1 } } function Bc(e) { return (e.mode & 1) !== 0 && (e.flags & 128) === 0 } function Ac(e) { if (Ge) { var t = Zt; if (t) { var n = t; if (!e0(e, t)) { if (Bc(e)) throw Error(ue(418)); t = Ar(n.nextSibling); var r = Xt; t && e0(e, t) ? Up(r, n) : (e.flags = e.flags & -4097 | 2, Ge = !1, Xt = e) } } else { if (Bc(e)) throw Error(ue(418)); e.flags = e.flags & -4097 | 2, Ge = !1, Xt = e } } } function t0(e) { for (e = e.return; e !== null && e.tag !== 5 && e.tag !== 3 && e.tag !== 13;)e = e.return; Xt = e } function Wo(e) { if (e !== Xt) return !1; if (!Ge) return t0(e), Ge = !0, !1; var t; if ((t = e.tag !== 3) && !(t = e.tag !== 5) && (t = e.type, t = t !== "head" && t !== "body" && !bc(e.type, e.memoizedProps)), t && (t = Zt)) { if (Bc(e)) throw Fp(), Error(ue(418)); for (; t;)Up(e, t), t = Ar(t.nextSibling) } if (t0(e), e.tag === 13) { if (e = e.memoizedState, e = e !== null ? e.dehydrated : null, !e) throw Error(ue(317)); e: { for (e = e.nextSibling, t = 0; e;) { if (e.nodeType === 8) { var n = e.data; if (n === "/$") { if (t === 0) { Zt = Ar(e.nextSibling); break e } t-- } else n !== "$" && n !== "$!" && n !== "$?" || t++ } e = e.nextSibling } Zt = null } } else Zt = Xt ? Ar(e.stateNode.nextSibling) : null; return !0 } function Fp() { for (var e = Zt; e;)e = Ar(e.nextSibling) } function ss() { Zt = Xt = null, Ge = !1 } function Uf(e) { wn === null ? wn = [e] : wn.push(e) } var Ww = ar.ReactCurrentBatchConfig; function Ts(e, t, n) { if (e = n.ref, e !== null && typeof e != "function" && typeof e != "object") { if (n._owner) { if (n = n._owner, n) { if (n.tag !== 1) throw Error(ue(309)); var r = n.stateNode } if (!r) throw Error(ue(147, e)); var i = r, s = "" + e; return t !== null && t.ref !== null && typeof t.ref == "function" && t.ref._stringRef === s ? t.ref : (t = function (o) { var a = i.refs; o === null ? delete a[s] : a[s] = o }, t._stringRef = s, t) } if (typeof e != "string") throw Error(ue(284)); if (!n._owner) throw Error(ue(290, e)) } return e } function Yo(e, t) { throw e = Object.prototype.toString.call(t), Error(ue(31, e === "[object Object]" ? "object with keys {" + Object.keys(t).join(", ") + "}" : e)) } function n0(e) { var t = e._init; return t(e._payload) } function Cp(e) { function t(b, E) { if (e) { var S = b.deletions; S === null ? (b.deletions = [E], b.flags |= 16) : S.push(E) } } function n(b, E) { if (!e) return null; for (; E !== null;)t(b, E), E = E.sibling; return null } function r(b, E) { for (b = new Map; E !== null;)E.key !== null ? b.set(E.key, E) : b.set(E.index, E), E = E.sibling; return b } function i(b, E) { return b = Or(b, E), b.index = 0, b.sibling = null, b } function s(b, E, S) { return b.index = S, e ? (S = b.alternate, S !== null ? (S = S.index, S < E ? (b.flags |= 2, E) : S) : (b.flags |= 2, E)) : (b.flags |= 1048576, E) } function o(b) { return e && b.alternate === null && (b.flags |= 2), b } function a(b, E, S, M) { return E === null || E.tag !== 6 ? (E = Ru(S, b.mode, M), E.return = b, E) : (E = i(E, S), E.return = b, E) } function f(b, E, S, M) { var k = S.type; return k === Oi ? _(b, E, S.props.children, M, S.key) : E !== null && (E.elementType === k || typeof k == "object" && k !== null && k.$$typeof === gr && n0(k) === E.type) ? (M = i(E, S.props), M.ref = Ts(b, E, S), M.return = b, M) : (M = va(S.type, S.key, S.props, null, b.mode, M), M.ref = Ts(b, E, S), M.return = b, M) } function h(b, E, S, M) { return E === null || E.tag !== 4 || E.stateNode.containerInfo !== S.containerInfo || E.stateNode.implementation !== S.implementation ? (E = Iu(S, b.mode, M), E.return = b, E) : (E = i(E, S.children || []), E.return = b, E) } function _(b, E, S, M, k) { return E === null || E.tag !== 7 ? (E = ri(S, b.mode, M, k), E.return = b, E) : (E = i(E, S), E.return = b, E) } function v(b, E, S) { if (typeof E == "string" && E !== "" || typeof E == "number") return E = Ru("" + E, b.mode, S), E.return = b, E; if (typeof E == "object" && E !== null) { switch (E.$$typeof) { case Po: return S = va(E.type, E.key, E.props, null, b.mode, S), S.ref = Ts(b, null, E), S.return = b, S; case Ii: return E = Iu(E, b.mode, S), E.return = b, E; case gr: var M = E._init; return v(b, M(E._payload), S) }if (Is(E) || _s(E)) return E = ri(E, b.mode, S, null), E.return = b, E; Yo(b, E) } return null } function y(b, E, S, M) { var k = E !== null ? E.key : null; if (typeof S == "string" && S !== "" || typeof S == "number") return k !== null ? null : a(b, E, "" + S, M); if (typeof S == "object" && S !== null) { switch (S.$$typeof) { case Po: return S.key === k ? f(b, E, S, M) : null; case Ii: return S.key === k ? h(b, E, S, M) : null; case gr: return k = S._init, y(b, E, k(S._payload), M) }if (Is(S) || _s(S)) return k !== null ? null : _(b, E, S, M, null); Yo(b, S) } return null } function w(b, E, S, M, k) { if (typeof M == "string" && M !== "" || typeof M == "number") return b = b.get(S) || null, a(E, b, "" + M, k); if (typeof M == "object" && M !== null) { switch (M.$$typeof) { case Po: return b = b.get(M.key === null ? S : M.key) || null, f(E, b, M, k); case Ii: return b = b.get(M.key === null ? S : M.key) || null, h(E, b, M, k); case gr: var C = M._init; return w(b, E, S, C(M._payload), k) }if (Is(M) || _s(M)) return b = b.get(S) || null, _(E, b, M, k, null); Yo(E, M) } return null } function p(b, E, S, M) { for (var k = null, C = null, V = E, Y = E = 0, re = null; V !== null && Y < S.length; Y++) { V.index > Y ? (re = V, V = null) : re = V.sibling; var U = y(b, V, S[Y], M); if (U === null) { V === null && (V = re); break } e && V && U.alternate === null && t(b, V), E = s(U, E, Y), C === null ? k = U : C.sibling = U, C = U, V = re } if (Y === S.length) return n(b, V), Ge && Vr(b, Y), k; if (V === null) { for (; Y < S.length; Y++)V = v(b, S[Y], M), V !== null && (E = s(V, E, Y), C === null ? k = V : C.sibling = V, C = V); return Ge && Vr(b, Y), k } for (V = r(b, V); Y < S.length; Y++)re = w(V, b, Y, S[Y], M), re !== null && (e && re.alternate !== null && V.delete(re.key === null ? Y : re.key), E = s(re, E, Y), C === null ? k = re : C.sibling = re, C = re); return e && V.forEach(function (K) { return t(b, K) }), Ge && Vr(b, Y), k } function O(b, E, S, M) { var k = _s(S); if (typeof k != "function") throw Error(ue(150)); if (S = k.call(S), S == null) throw Error(ue(151)); for (var C = k = null, V = E, Y = E = 0, re = null, U = S.next(); V !== null && !U.done; Y++, U = S.next()) { V.index > Y ? (re = V, V = null) : re = V.sibling; var K = y(b, V, U.value, M); if (K === null) { V === null && (V = re); break } e && V && K.alternate === null && t(b, V), E = s(K, E, Y), C === null ? k = K : C.sibling = K, C = K, V = re } if (U.done) return n(b, V), Ge && Vr(b, Y), k; if (V === null) { for (; !U.done; Y++, U = S.next())U = v(b, U.value, M), U !== null && (E = s(U, E, Y), C === null ? k = U : C.sibling = U, C = U); return Ge && Vr(b, Y), k } for (V = r(b, V); !U.done; Y++, U = S.next())U = w(V, b, Y, U.value, M), U !== null && (e && U.alternate !== null && V.delete(U.key === null ? Y : U.key), E = s(U, E, Y), C === null ? k = U : C.sibling = U, C = U); return e && V.forEach(function (ee) { return t(b, ee) }), Ge && Vr(b, Y), k } function $(b, E, S, M) { if (typeof S == "object" && S !== null && S.type === Oi && S.key === null && (S = S.props.children), typeof S == "object" && S !== null) { switch (S.$$typeof) { case Po: e: { for (var k = S.key, C = E; C !== null;) { if (C.key === k) { if (k = S.type, k === Oi) { if (C.tag === 7) { n(b, C.sibling), E = i(C, S.props.children), E.return = b, b = E; break e } } else if (C.elementType === k || typeof k == "object" && k !== null && k.$$typeof === gr && n0(k) === C.type) { n(b, C.sibling), E = i(C, S.props), E.ref = Ts(b, C, S), E.return = b, b = E; break e } n(b, C); break } else t(b, C); C = C.sibling } S.type === Oi ? (E = ri(S.props.children, b.mode, M, S.key), E.return = b, b = E) : (M = va(S.type, S.key, S.props, null, b.mode, M), M.ref = Ts(b, E, S), M.return = b, b = M) } return o(b); case Ii: e: { for (C = S.key; E !== null;) { if (E.key === C) if (E.tag === 4 && E.stateNode.containerInfo === S.containerInfo && E.stateNode.implementation === S.implementation) { n(b, E.sibling), E = i(E, S.children || []), E.return = b, b = E; break e } else { n(b, E); break } else t(b, E); E = E.sibling } E = Iu(S, b.mode, M), E.return = b, b = E } return o(b); case gr: return C = S._init, $(b, E, C(S._payload), M) }if (Is(S)) return p(b, E, S, M); if (_s(S)) return O(b, E, S, M); Yo(b, S) } return typeof S == "string" && S !== "" || typeof S == "number" ? (S = "" + S, E !== null && E.tag === 6 ? (n(b, E.sibling), E = i(E, S), E.return = b, b = E) : (n(b, E), E = Ru(S, b.mode, M), E.return = b, b = E), o(b)) : n(b, E) } return $ } var os = Cp(!0), Pp = Cp(!1), Ja = Mr(null), el = null, zi = null, Ff = null; function Cf() { Ff = zi = el = null } function Pf(e) { var t = Ja.current; He(Ja), e._currentValue = t } function kc(e, t, n) { for (; e !== null;) { var r = e.alternate; if ((e.childLanes & t) !== t ? (e.childLanes |= t, r !== null && (r.childLanes |= t)) : r !== null && (r.childLanes & t) !== t && (r.childLanes |= t), e === n) break; e = e.return } } function Di(e, t) { el = e, Ff = zi = null, e = e.dependencies, e !== null && e.firstContext !== null && (e.lanes & t && (qt = !0), e.firstContext = null) } function ln(e) { var t = e._currentValue; if (Ff !== e) if (e = { context: e, memoizedValue: t, next: null }, zi === null) { if (el === null) throw Error(ue(308)); zi = e, el.dependencies = { lanes: 0, firstContext: e } } else zi = zi.next = e; return t } var Xr = null; function Mf(e) { Xr === null ? Xr = [e] : Xr.push(e) } function Mp(e, t, n, r) { var i = t.interleaved; return i === null ? (n.next = n, Mf(t)) : (n.next = i.next, i.next = n), t.interleaved = n, ir(e, r) } function ir(e, t) { e.lanes |= t; var n = e.alternate; for (n !== null && (n.lanes |= t), n = e, e = e.return; e !== null;)e.childLanes |= t, n = e.alternate, n !== null && (n.childLanes |= t), n = e, e = e.return; return n.tag === 3 ? n.stateNode : null } var wr = !1; function jf(e) { e.updateQueue = { baseState: e.memoizedState, firstBaseUpdate: null, lastBaseUpdate: null, shared: { pending: null, interleaved: null, lanes: 0 }, effects: null } } function jp(e, t) { e = e.updateQueue, t.updateQueue === e && (t.updateQueue = { baseState: e.baseState, firstBaseUpdate: e.firstBaseUpdate, lastBaseUpdate: e.lastBaseUpdate, shared: e.shared, effects: e.effects }) } function tr(e, t) { return { eventTime: e, lane: t, tag: 0, payload: null, callback: null, next: null } } function kr(e, t, n) { var r = e.updateQueue; if (r === null) return null; if (r = r.shared, Ie & 2) { var i = r.pending; return i === null ? t.next = t : (t.next = i.next, i.next = t), r.pending = t, ir(e, n) } return i = r.interleaved, i === null ? (t.next = t, Mf(r)) : (t.next = i.next, i.next = t), r.interleaved = t, ir(e, n) } function pa(e, t, n) { if (t = t.updateQueue, t !== null && (t = t.shared, (n & 4194240) !== 0)) { var r = t.lanes; r &= e.pendingLanes, n |= r, t.lanes = n, bf(e, n) } } function r0(e, t) { var n = e.updateQueue, r = e.alternate; if (r !== null && (r = r.updateQueue, n === r)) { var i = null, s = null; if (n = n.firstBaseUpdate, n !== null) { do { var o = { eventTime: n.eventTime, lane: n.lane, tag: n.tag, payload: n.payload, callback: n.callback, next: null }; s === null ? i = s = o : s = s.next = o, n = n.next } while (n !== null); s === null ? i = s = t : s = s.next = t } else i = s = t; n = { baseState: r.baseState, firstBaseUpdate: i, lastBaseUpdate: s, shared: r.shared, effects: r.effects }, e.updateQueue = n; return } e = n.lastBaseUpdate, e === null ? n.firstBaseUpdate = t : e.next = t, n.lastBaseUpdate = t } function tl(e, t, n, r) { var i = e.updateQueue; wr = !1; var s = i.firstBaseUpdate, o = i.lastBaseUpdate, a = i.shared.pending; if (a !== null) { i.shared.pending = null; var f = a, h = f.next; f.next = null, o === null ? s = h : o.next = h, o = f; var _ = e.alternate; _ !== null && (_ = _.updateQueue, a = _.lastBaseUpdate, a !== o && (a === null ? _.firstBaseUpdate = h : a.next = h, _.lastBaseUpdate = f)) } if (s !== null) { var v = i.baseState; o = 0, _ = h = f = null, a = s; do { var y = a.lane, w = a.eventTime; if ((r & y) === y) { _ !== null && (_ = _.next = { eventTime: w, lane: 0, tag: a.tag, payload: a.payload, callback: a.callback, next: null }); e: { var p = e, O = a; switch (y = t, w = n, O.tag) { case 1: if (p = O.payload, typeof p == "function") { v = p.call(w, v, y); break e } v = p; break e; case 3: p.flags = p.flags & -65537 | 128; case 0: if (p = O.payload, y = typeof p == "function" ? p.call(w, v, y) : p, y == null) break e; v = Ye({}, v, y); break e; case 2: wr = !0 } } a.callback !== null && a.lane !== 0 && (e.flags |= 64, y = i.effects, y === null ? i.effects = [a] : y.push(a)) } else w = { eventTime: w, lane: y, tag: a.tag, payload: a.payload, callback: a.callback, next: null }, _ === null ? (h = _ = w, f = v) : _ = _.next = w, o |= y; if (a = a.next, a === null) { if (a = i.shared.pending, a === null) break; y = a, a = y.next, y.next = null, i.lastBaseUpdate = y, i.shared.pending = null } } while (!0); if (_ === null && (f = v), i.baseState = f, i.firstBaseUpdate = h, i.lastBaseUpdate = _, t = i.shared.interleaved, t !== null) { i = t; do o |= i.lane, i = i.next; while (i !== t) } else s === null && (i.shared.lanes = 0); ci |= o, e.lanes = o, e.memoizedState = v } } function i0(e, t, n) { if (e = t.effects, t.effects = null, e !== null) for (t = 0; t < e.length; t++) { var r = e[t], i = r.callback; if (i !== null) { if (r.callback = null, r = n, typeof i != "function") throw Error(ue(191, i)); i.call(r) } } } var No = {}, jn = Mr(No), ao = Mr(No), lo = Mr(No); function Qr(e) { if (e === No) throw Error(ue(174)); return e } function $f(e, t) { switch (Ve(lo, t), Ve(ao, e), Ve(jn, No), e = t.nodeType, e) { case 9: case 11: t = (t = t.documentElement) ? t.namespaceURI : uc(null, ""); break; default: e = e === 8 ? t.parentNode : t, t = e.namespaceURI || null, e = e.tagName, t = uc(t, e) }He(jn), Ve(jn, t) } function as() { He(jn), He(ao), He(lo) } function $p(e) { Qr(lo.current); var t = Qr(jn.current), n = uc(t, e.type); t !== n && (Ve(ao, e), Ve(jn, n)) } function zf(e) { ao.current === e && (He(jn), He(ao)) } var Le = Mr(0); function nl(e) { for (var t = e; t !== null;) { if (t.tag === 13) { var n = t.memoizedState; if (n !== null && (n = n.dehydrated, n === null || n.data === "$?" || n.data === "$!")) return t } else if (t.tag === 19 && t.memoizedProps.revealOrder !== void 0) { if (t.flags & 128) return t } else if (t.child !== null) { t.child.return = t, t = t.child; continue } if (t === e) break; for (; t.sibling === null;) { if (t.return === null || t.return === e) return null; t = t.return } t.sibling.return = t.return, t = t.sibling } return null } var Su = []; function Vf() { for (var e = 0; e < Su.length; e++)Su[e]._workInProgressVersionPrimary = null; Su.length = 0 } var ma = ar.ReactCurrentDispatcher, Nu = ar.ReactCurrentBatchConfig, ui = 0, We = null, it = null, dt = null, rl = !1, Ws = !1, uo = 0, Yw = 0; function Et() { throw Error(ue(321)) } function qf(e, t) { if (t === null) return !1; for (var n = 0; n < t.length && n < e.length; n++)if (!En(e[n], t[n])) return !1; return !0 } function Hf(e, t, n, r, i, s) { if (ui = s, We = t, t.memoizedState = null, t.updateQueue = null, t.lanes = 0, ma.current = e === null || e.memoizedState === null ? Qw : Dw, e = n(r, i), Ws) { s = 0; do { if (Ws = !1, uo = 0, 25 <= s) throw Error(ue(301)); s += 1, dt = it = null, t.updateQueue = null, ma.current = Jw, e = n(r, i) } while (Ws) } if (ma.current = il, t = it !== null && it.next !== null, ui = 0, dt = it = We = null, rl = !1, t) throw Error(ue(300)); return e } function Gf() { var e = uo !== 0; return uo = 0, e } function In() { var e = { memoizedState: null, baseState: null, baseQueue: null, queue: null, next: null }; return dt === null ? We.memoizedState = dt = e : dt = dt.next = e, dt } function un() { if (it === null) { var e = We.alternate; e = e !== null ? e.memoizedState : null } else e = it.next; var t = dt === null ? We.memoizedState : dt.next; if (t !== null) dt = t, it = e; else { if (e === null) throw Error(ue(310)); it = e, e = { memoizedState: it.memoizedState, baseState: it.baseState, baseQueue: it.baseQueue, queue: it.queue, next: null }, dt === null ? We.memoizedState = dt = e : dt = dt.next = e } return dt } function co(e, t) { return typeof t == "function" ? t(e) : t } function Tu(e) { var t = un(), n = t.queue; if (n === null) throw Error(ue(311)); n.lastRenderedReducer = e; var r = it, i = r.baseQueue, s = n.pending; if (s !== null) { if (i !== null) { var o = i.next; i.next = s.next, s.next = o } r.baseQueue = i = s, n.pending = null } if (i !== null) { s = i.next, r = r.baseState; var a = o = null, f = null, h = s; do { var _ = h.lane; if ((ui & _) === _) f !== null && (f = f.next = { lane: 0, action: h.action, hasEagerState: h.hasEagerState, eagerState: h.eagerState, next: null }), r = h.hasEagerState ? h.eagerState : e(r, h.action); else { var v = { lane: _, action: h.action, hasEagerState: h.hasEagerState, eagerState: h.eagerState, next: null }; f === null ? (a = f = v, o = r) : f = f.next = v, We.lanes |= _, ci |= _ } h = h.next } while (h !== null && h !== s); f === null ? o = r : f.next = a, En(r, t.memoizedState) || (qt = !0), t.memoizedState = r, t.baseState = o, t.baseQueue = f, n.lastRenderedState = r } if (e = n.interleaved, e !== null) { i = e; do s = i.lane, We.lanes |= s, ci |= s, i = i.next; while (i !== e) } else i === null && (n.lanes = 0); return [t.memoizedState, n.dispatch] } function Bu(e) { var t = un(), n = t.queue; if (n === null) throw Error(ue(311)); n.lastRenderedReducer = e; var r = n.dispatch, i = n.pending, s = t.memoizedState; if (i !== null) { n.pending = null; var o = i = i.next; do s = e(s, o.action), o = o.next; while (o !== i); En(s, t.memoizedState) || (qt = !0), t.memoizedState = s, t.baseQueue === null && (t.baseState = s), n.lastRenderedState = s } return [s, r] } function zp() { } function Vp(e, t) { var n = We, r = un(), i = t(), s = !En(r.memoizedState, i); if (s && (r.memoizedState = i, qt = !0), r = r.queue, Lf(Gp.bind(null, n, r, e), [e]), r.getSnapshot !== t || s || dt !== null && dt.memoizedState.tag & 1) { if (n.flags |= 2048, fo(9, Hp.bind(null, n, r, i, t), void 0, null), mt === null) throw Error(ue(349)); ui & 30 || qp(n, t, i) } return i } function qp(e, t, n) { e.flags |= 16384, e = { getSnapshot: t, value: n }, t = We.updateQueue, t === null ? (t = { lastEffect: null, stores: null }, We.updateQueue = t, t.stores = [e]) : (n = t.stores, n === null ? t.stores = [e] : n.push(e)) } function Hp(e, t, n, r) { t.value = n, t.getSnapshot = r, Lp(t) && Wp(e) } function Gp(e, t, n) { return n(function () { Lp(t) && Wp(e) }) } function Lp(e) { var t = e.getSnapshot; e = e.value; try { var n = t(); return !En(e, n) } catch { return !0 } } function Wp(e) { var t = ir(e, 1); t !== null && _n(t, e, 1, -1) } function s0(e) { var t = In(); return typeof e == "function" && (e = e()), t.memoizedState = t.baseState = e, e = { pending: null, interleaved: null, lanes: 0, dispatch: null, lastRenderedReducer: co, lastRenderedState: e }, t.queue = e, e = e.dispatch = Xw.bind(null, We, e), [t.memoizedState, e] } function fo(e, t, n, r) { return e = { tag: e, create: t, destroy: n, deps: r, next: null }, t = We.updateQueue, t === null ? (t = { lastEffect: null, stores: null }, We.updateQueue = t, t.lastEffect = e.next = e) : (n = t.lastEffect, n === null ? t.lastEffect = e.next = e : (r = n.next, n.next = e, e.next = r, t.lastEffect = e)), e } function Yp() { return un().memoizedState } function ya(e, t, n, r) { var i = In(); We.flags |= e, i.memoizedState = fo(1 | t, n, void 0, r === void 0 ? null : r) } function kl(e, t, n, r) { var i = un(); r = r === void 0 ? null : r; var s = void 0; if (it !== null) { var o = it.memoizedState; if (s = o.destroy, r !== null && qf(r, o.deps)) { i.memoizedState = fo(t, n, s, r); return } } We.flags |= e, i.memoizedState = fo(1 | t, n, s, r) } function o0(e, t) { return ya(8390656, 8, e, t) } function Lf(e, t) { return kl(2048, 8, e, t) } function Kp(e, t) { return kl(4, 2, e, t) } function Zp(e, t) { return kl(4, 4, e, t) } function Xp(e, t) { if (typeof t == "function") return e = e(), t(e), function () { t(null) }; if (t != null) return e = e(), t.current = e, function () { t.current = null } } function Qp(e, t, n) { return n = n != null ? n.concat([e]) : null, kl(4, 4, Xp.bind(null, t, e), n) } function Wf() { } function Dp(e, t) { var n = un(); t = t === void 0 ? null : t; var r = n.memoizedState; return r !== null && t !== null && qf(t, r[1]) ? r[0] : (n.memoizedState = [e, t], e) } function Jp(e, t) { var n = un(); t = t === void 0 ? null : t; var r = n.memoizedState; return r !== null && t !== null && qf(t, r[1]) ? r[0] : (e = e(), n.memoizedState = [e, t], e) } function e1(e, t, n) { return ui & 21 ? (En(n, t) || (n = sp(), We.lanes |= n, ci |= n, e.baseState = !0), t) : (e.baseState && (e.baseState = !1, qt = !0), e.memoizedState = n) } function Kw(e, t) { var n = Ce; Ce = n !== 0 && 4 > n ? n : 4, e(!0); var r = Nu.transition; Nu.transition = {}; try { e(!1), t() } finally { Ce = n, Nu.transition = r } } function t1() { return un().memoizedState } function Zw(e, t, n) { var r = Ir(e); if (n = { lane: r, action: n, hasEagerState: !1, eagerState: null, next: null }, n1(e)) r1(t, n); else if (n = Mp(e, t, n, r), n !== null) { var i = jt(); _n(n, e, r, i), i1(n, t, r) } } function Xw(e, t, n) { var r = Ir(e), i = { lane: r, action: n, hasEagerState: !1, eagerState: null, next: null }; if (n1(e)) r1(t, i); else { var s = e.alternate; if (e.lanes === 0 && (s === null || s.lanes === 0) && (s = t.lastRenderedReducer, s !== null)) try { var o = t.lastRenderedState, a = s(o, n); if (i.hasEagerState = !0, i.eagerState = a, En(a, o)) { var f = t.interleaved; f === null ? (i.next = i, Mf(t)) : (i.next = f.next, f.next = i), t.interleaved = i; return } } catch { } finally { } n = Mp(e, t, i, r), n !== null && (i = jt(), _n(n, e, r, i), i1(n, t, r)) } } function n1(e) { var t = e.alternate; return e === We || t !== null && t === We } function r1(e, t) { Ws = rl = !0; var n = e.pending; n === null ? t.next = t : (t.next = n.next, n.next = t), e.pending = t } function i1(e, t, n) { if (n & 4194240) { var r = t.lanes; r &= e.pendingLanes, n |= r, t.lanes = n, bf(e, n) } } var il = { readContext: ln, useCallback: Et, useContext: Et, useEffect: Et, useImperativeHandle: Et, useInsertionEffect: Et, useLayoutEffect: Et, useMemo: Et, useReducer: Et, useRef: Et, useState: Et, useDebugValue: Et, useDeferredValue: Et, useTransition: Et, useMutableSource: Et, useSyncExternalStore: Et, useId: Et, unstable_isNewReconciler: !1 }, Qw = { readContext: ln, useCallback: function (e, t) { return In().memoizedState = [e, t === void 0 ? null : t], e }, useContext: ln, useEffect: o0, useImperativeHandle: function (e, t, n) { return n = n != null ? n.concat([e]) : null, ya(4194308, 4, Xp.bind(null, t, e), n) }, useLayoutEffect: function (e, t) { return ya(4194308, 4, e, t) }, useInsertionEffect: function (e, t) { return ya(4, 2, e, t) }, useMemo: function (e, t) { var n = In(); return t = t === void 0 ? null : t, e = e(), n.memoizedState = [e, t], e }, useReducer: function (e, t, n) { var r = In(); return t = n !== void 0 ? n(t) : t, r.memoizedState = r.baseState = t, e = { pending: null, interleaved: null, lanes: 0, dispatch: null, lastRenderedReducer: e, lastRenderedState: t }, r.queue = e, e = e.dispatch = Zw.bind(null, We, e), [r.memoizedState, e] }, useRef: function (e) { var t = In(); return e = { current: e }, t.memoizedState = e }, useState: s0, useDebugValue: Wf, useDeferredValue: function (e) { return In().memoizedState = e }, useTransition: function () { var e = s0(!1), t = e[0]; return e = Kw.bind(null, e[1]), In().memoizedState = e, [t, e] }, useMutableSource: function () { }, useSyncExternalStore: function (e, t, n) { var r = We, i = In(); if (Ge) { if (n === void 0) throw Error(ue(407)); n = n() } else { if (n = t(), mt === null) throw Error(ue(349)); ui & 30 || qp(r, t, n) } i.memoizedState = n; var s = { value: n, getSnapshot: t }; return i.queue = s, o0(Gp.bind(null, r, s, e), [e]), r.flags |= 2048, fo(9, Hp.bind(null, r, s, n, t), void 0, null), n }, useId: function () { var e = In(), t = mt.identifierPrefix; if (Ge) { var n = Qn, r = Xn; n = (r & ~(1 << 32 - vn(r) - 1)).toString(32) + n, t = ":" + t + "R" + n, n = uo++, 0 < n && (t += "H" + n.toString(32)), t += ":" } else n = Yw++, t = ":" + t + "r" + n.toString(32) + ":"; return e.memoizedState = t }, unstable_isNewReconciler: !1 }, Dw = { readContext: ln, useCallback: Dp, useContext: ln, useEffect: Lf, useImperativeHandle: Qp, useInsertionEffect: Kp, useLayoutEffect: Zp, useMemo: Jp, useReducer: Tu, useRef: Yp, useState: function () { return Tu(co) }, useDebugValue: Wf, useDeferredValue: function (e) { var t = un(); return e1(t, it.memoizedState, e) }, useTransition: function () { var e = Tu(co)[0], t = un().memoizedState; return [e, t] }, useMutableSource: zp, useSyncExternalStore: Vp, useId: t1, unstable_isNewReconciler: !1 }, Jw = { readContext: ln, useCallback: Dp, useContext: ln, useEffect: Lf, useImperativeHandle: Qp, useInsertionEffect: Kp, useLayoutEffect: Zp, useMemo: Jp, useReducer: Bu, useRef: Yp, useState: function () { return Bu(co) }, useDebugValue: Wf, useDeferredValue: function (e) { var t = un(); return it === null ? t.memoizedState = e : e1(t, it.memoizedState, e) }, useTransition: function () { var e = Bu(co)[0], t = un().memoizedState; return [e, t] }, useMutableSource: zp, useSyncExternalStore: Vp, useId: t1, unstable_isNewReconciler: !1 }; function mn(e, t) { if (e && e.defaultProps) { t = Ye({}, t), e = e.defaultProps; for (var n in e) t[n] === void 0 && (t[n] = e[n]); return t } return t } function Rc(e, t, n, r) { t = e.memoizedState, n = n(r, t), n = n == null ? t : Ye({}, t, n), e.memoizedState = n, e.lanes === 0 && (e.updateQueue.baseState = n) } var Rl = { isMounted: function (e) { return (e = e._reactInternals) ? wi(e) === e : !1 }, enqueueSetState: function (e, t, n) { e = e._reactInternals; var r = jt(), i = Ir(e), s = tr(r, i); s.payload = t, n != null && (s.callback = n), t = kr(e, s, i), t !== null && (_n(t, e, i, r), pa(t, e, i)) }, enqueueReplaceState: function (e, t, n) { e = e._reactInternals; var r = jt(), i = Ir(e), s = tr(r, i); s.tag = 1, s.payload = t, n != null && (s.callback = n), t = kr(e, s, i), t !== null && (_n(t, e, i, r), pa(t, e, i)) }, enqueueForceUpdate: function (e, t) { e = e._reactInternals; var n = jt(), r = Ir(e), i = tr(n, r); i.tag = 2, t != null && (i.callback = t), t = kr(e, i, r), t !== null && (_n(t, e, r, n), pa(t, e, r)) } }; function a0(e, t, n, r, i, s, o) { return e = e.stateNode, typeof e.shouldComponentUpdate == "function" ? e.shouldComponentUpdate(r, s, o) : t.prototype && t.prototype.isPureReactComponent ? !ro(n, r) || !ro(i, s) : !0 } function s1(e, t, n) { var r = !1, i = Cr, s = t.contextType; return typeof s == "object" && s !== null ? s = ln(s) : (i = Lt(t) ? ai : Rt.current, r = t.contextTypes, s = (r = r != null) ? is(e, i) : Cr), t = new t(n, s), e.memoizedState = t.state !== null && t.state !== void 0 ? t.state : null, t.updater = Rl, e.stateNode = t, t._reactInternals = e, r && (e = e.stateNode, e.__reactInternalMemoizedUnmaskedChildContext = i, e.__reactInternalMemoizedMaskedChildContext = s), t } function l0(e, t, n, r) { e = t.state, typeof t.componentWillReceiveProps == "function" && t.componentWillReceiveProps(n, r), typeof t.UNSAFE_componentWillReceiveProps == "function" && t.UNSAFE_componentWillReceiveProps(n, r), t.state !== e && Rl.enqueueReplaceState(t, t.state, null) } function Ic(e, t, n, r) { var i = e.stateNode; i.props = n, i.state = e.memoizedState, i.refs = {}, jf(e); var s = t.contextType; typeof s == "object" && s !== null ? i.context = ln(s) : (s = Lt(t) ? ai : Rt.current, i.context = is(e, s)), i.state = e.memoizedState, s = t.getDerivedStateFromProps, typeof s == "function" && (Rc(e, t, s, n), i.state = e.memoizedState), typeof t.getDerivedStateFromProps == "function" || typeof i.getSnapshotBeforeUpdate == "function" || typeof i.UNSAFE_componentWillMount != "function" && typeof i.componentWillMount != "function" || (t = i.state, typeof i.componentWillMount == "function" && i.componentWillMount(), typeof i.UNSAFE_componentWillMount == "function" && i.UNSAFE_componentWillMount(), t !== i.state && Rl.enqueueReplaceState(i, i.state, null), tl(e, n, i, r), i.state = e.memoizedState), typeof i.componentDidMount == "function" && (e.flags |= 4194308) } function ls(e, t) {
  try { var n = "", r = t; do n += Bg(r), r = r.return; while (r); var i = n } catch (s) {
    i = `
Error generating stack: `+ s.message + `
`+ s.stack
  } return { value: e, source: t, stack: i, digest: null }
} function Au(e, t, n) { return { value: e, source: null, stack: n ?? null, digest: t ?? null } } function Oc(e, t) { try { console.error(t.value) } catch (n) { setTimeout(function () { throw n }) } } var e2 = typeof WeakMap == "function" ? WeakMap : Map; function o1(e, t, n) { n = tr(-1, n), n.tag = 3, n.payload = { element: null }; var r = t.value; return n.callback = function () { ol || (ol = !0, qc = r), Oc(e, t) }, n } function a1(e, t, n) { n = tr(-1, n), n.tag = 3; var r = e.type.getDerivedStateFromError; if (typeof r == "function") { var i = t.value; n.payload = function () { return r(i) }, n.callback = function () { Oc(e, t) } } var s = e.stateNode; return s !== null && typeof s.componentDidCatch == "function" && (n.callback = function () { Oc(e, t), typeof r != "function" && (Rr === null ? Rr = new Set([this]) : Rr.add(this)); var o = t.stack; this.componentDidCatch(t.value, { componentStack: o !== null ? o : "" }) }), n } function u0(e, t, n) { var r = e.pingCache; if (r === null) { r = e.pingCache = new e2; var i = new Set; r.set(t, i) } else i = r.get(t), i === void 0 && (i = new Set, r.set(t, i)); i.has(n) || (i.add(n), e = p2.bind(null, e, t, n), t.then(e, e)) } function c0(e) { do { var t; if ((t = e.tag === 13) && (t = e.memoizedState, t = t !== null ? t.dehydrated !== null : !0), t) return e; e = e.return } while (e !== null); return null } function f0(e, t, n, r, i) { return e.mode & 1 ? (e.flags |= 65536, e.lanes = i, e) : (e === t ? e.flags |= 65536 : (e.flags |= 128, n.flags |= 131072, n.flags &= -52805, n.tag === 1 && (n.alternate === null ? n.tag = 17 : (t = tr(-1, 1), t.tag = 2, kr(n, t, 1))), n.lanes |= 1), e) } var t2 = ar.ReactCurrentOwner, qt = !1; function Pt(e, t, n, r) { t.child = e === null ? Pp(t, null, n, r) : os(t, e.child, n, r) } function d0(e, t, n, r, i) { n = n.render; var s = t.ref; return Di(t, i), r = Hf(e, t, n, r, s, i), n = Gf(), e !== null && !qt ? (t.updateQueue = e.updateQueue, t.flags &= -2053, e.lanes &= ~i, sr(e, t, i)) : (Ge && n && If(t), t.flags |= 1, Pt(e, t, r, i), t.child) } function h0(e, t, n, r, i) { if (e === null) { var s = n.type; return typeof s == "function" && !ed(s) && s.defaultProps === void 0 && n.compare === null && n.defaultProps === void 0 ? (t.tag = 15, t.type = s, l1(e, t, s, r, i)) : (e = va(n.type, null, r, t, t.mode, i), e.ref = t.ref, e.return = t, t.child = e) } if (s = e.child, !(e.lanes & i)) { var o = s.memoizedProps; if (n = n.compare, n = n !== null ? n : ro, n(o, r) && e.ref === t.ref) return sr(e, t, i) } return t.flags |= 1, e = Or(s, r), e.ref = t.ref, e.return = t, t.child = e } function l1(e, t, n, r, i) { if (e !== null) { var s = e.memoizedProps; if (ro(s, r) && e.ref === t.ref) if (qt = !1, t.pendingProps = r = s, (e.lanes & i) !== 0) e.flags & 131072 && (qt = !0); else return t.lanes = e.lanes, sr(e, t, i) } return Uc(e, t, n, r, i) } function u1(e, t, n) { var r = t.pendingProps, i = r.children, s = e !== null ? e.memoizedState : null; if (r.mode === "hidden") if (!(t.mode & 1)) t.memoizedState = { baseLanes: 0, cachePool: null, transitions: null }, Ve(qi, Yt), Yt |= n; else { if (!(n & 1073741824)) return e = s !== null ? s.baseLanes | n : n, t.lanes = t.childLanes = 1073741824, t.memoizedState = { baseLanes: e, cachePool: null, transitions: null }, t.updateQueue = null, Ve(qi, Yt), Yt |= e, null; t.memoizedState = { baseLanes: 0, cachePool: null, transitions: null }, r = s !== null ? s.baseLanes : n, Ve(qi, Yt), Yt |= r } else s !== null ? (r = s.baseLanes | n, t.memoizedState = null) : r = n, Ve(qi, Yt), Yt |= r; return Pt(e, t, i, n), t.child } function c1(e, t) { var n = t.ref; (e === null && n !== null || e !== null && e.ref !== n) && (t.flags |= 512, t.flags |= 2097152) } function Uc(e, t, n, r, i) { var s = Lt(n) ? ai : Rt.current; return s = is(t, s), Di(t, i), n = Hf(e, t, n, r, s, i), r = Gf(), e !== null && !qt ? (t.updateQueue = e.updateQueue, t.flags &= -2053, e.lanes &= ~i, sr(e, t, i)) : (Ge && r && If(t), t.flags |= 1, Pt(e, t, n, i), t.child) } function p0(e, t, n, r, i) { if (Lt(n)) { var s = !0; Xa(t) } else s = !1; if (Di(t, i), t.stateNode === null) ga(e, t), s1(t, n, r), Ic(t, n, r, i), r = !0; else if (e === null) { var o = t.stateNode, a = t.memoizedProps; o.props = a; var f = o.context, h = n.contextType; typeof h == "object" && h !== null ? h = ln(h) : (h = Lt(n) ? ai : Rt.current, h = is(t, h)); var _ = n.getDerivedStateFromProps, v = typeof _ == "function" || typeof o.getSnapshotBeforeUpdate == "function"; v || typeof o.UNSAFE_componentWillReceiveProps != "function" && typeof o.componentWillReceiveProps != "function" || (a !== r || f !== h) && l0(t, o, r, h), wr = !1; var y = t.memoizedState; o.state = y, tl(t, r, o, i), f = t.memoizedState, a !== r || y !== f || Gt.current || wr ? (typeof _ == "function" && (Rc(t, n, _, r), f = t.memoizedState), (a = wr || a0(t, n, a, r, y, f, h)) ? (v || typeof o.UNSAFE_componentWillMount != "function" && typeof o.componentWillMount != "function" || (typeof o.componentWillMount == "function" && o.componentWillMount(), typeof o.UNSAFE_componentWillMount == "function" && o.UNSAFE_componentWillMount()), typeof o.componentDidMount == "function" && (t.flags |= 4194308)) : (typeof o.componentDidMount == "function" && (t.flags |= 4194308), t.memoizedProps = r, t.memoizedState = f), o.props = r, o.state = f, o.context = h, r = a) : (typeof o.componentDidMount == "function" && (t.flags |= 4194308), r = !1) } else { o = t.stateNode, jp(e, t), a = t.memoizedProps, h = t.type === t.elementType ? a : mn(t.type, a), o.props = h, v = t.pendingProps, y = o.context, f = n.contextType, typeof f == "object" && f !== null ? f = ln(f) : (f = Lt(n) ? ai : Rt.current, f = is(t, f)); var w = n.getDerivedStateFromProps; (_ = typeof w == "function" || typeof o.getSnapshotBeforeUpdate == "function") || typeof o.UNSAFE_componentWillReceiveProps != "function" && typeof o.componentWillReceiveProps != "function" || (a !== v || y !== f) && l0(t, o, r, f), wr = !1, y = t.memoizedState, o.state = y, tl(t, r, o, i); var p = t.memoizedState; a !== v || y !== p || Gt.current || wr ? (typeof w == "function" && (Rc(t, n, w, r), p = t.memoizedState), (h = wr || a0(t, n, h, r, y, p, f) || !1) ? (_ || typeof o.UNSAFE_componentWillUpdate != "function" && typeof o.componentWillUpdate != "function" || (typeof o.componentWillUpdate == "function" && o.componentWillUpdate(r, p, f), typeof o.UNSAFE_componentWillUpdate == "function" && o.UNSAFE_componentWillUpdate(r, p, f)), typeof o.componentDidUpdate == "function" && (t.flags |= 4), typeof o.getSnapshotBeforeUpdate == "function" && (t.flags |= 1024)) : (typeof o.componentDidUpdate != "function" || a === e.memoizedProps && y === e.memoizedState || (t.flags |= 4), typeof o.getSnapshotBeforeUpdate != "function" || a === e.memoizedProps && y === e.memoizedState || (t.flags |= 1024), t.memoizedProps = r, t.memoizedState = p), o.props = r, o.state = p, o.context = f, r = h) : (typeof o.componentDidUpdate != "function" || a === e.memoizedProps && y === e.memoizedState || (t.flags |= 4), typeof o.getSnapshotBeforeUpdate != "function" || a === e.memoizedProps && y === e.memoizedState || (t.flags |= 1024), r = !1) } return Fc(e, t, n, r, s, i) } function Fc(e, t, n, r, i, s) { c1(e, t); var o = (t.flags & 128) !== 0; if (!r && !o) return i && Jd(t, n, !1), sr(e, t, s); r = t.stateNode, t2.current = t; var a = o && typeof n.getDerivedStateFromError != "function" ? null : r.render(); return t.flags |= 1, e !== null && o ? (t.child = os(t, e.child, null, s), t.child = os(t, null, a, s)) : Pt(e, t, a, s), t.memoizedState = r.state, i && Jd(t, n, !0), t.child } function f1(e) { var t = e.stateNode; t.pendingContext ? Dd(e, t.pendingContext, t.pendingContext !== t.context) : t.context && Dd(e, t.context, !1), $f(e, t.containerInfo) } function m0(e, t, n, r, i) { return ss(), Uf(i), t.flags |= 256, Pt(e, t, n, r), t.child } var Cc = { dehydrated: null, treeContext: null, retryLane: 0 }; function Pc(e) { return { baseLanes: e, cachePool: null, transitions: null } } function d1(e, t, n) { var r = t.pendingProps, i = Le.current, s = !1, o = (t.flags & 128) !== 0, a; if ((a = o) || (a = e !== null && e.memoizedState === null ? !1 : (i & 2) !== 0), a ? (s = !0, t.flags &= -129) : (e === null || e.memoizedState !== null) && (i |= 1), Ve(Le, i & 1), e === null) return Ac(t), e = t.memoizedState, e !== null && (e = e.dehydrated, e !== null) ? (t.mode & 1 ? e.data === "$!" ? t.lanes = 8 : t.lanes = 1073741824 : t.lanes = 1, null) : (o = r.children, e = r.fallback, s ? (r = t.mode, s = t.child, o = { mode: "hidden", children: o }, !(r & 1) && s !== null ? (s.childLanes = 0, s.pendingProps = o) : s = Ul(o, r, 0, null), e = ri(e, r, n, null), s.return = t, e.return = t, s.sibling = e, t.child = s, t.child.memoizedState = Pc(n), t.memoizedState = Cc, e) : Yf(t, o)); if (i = e.memoizedState, i !== null && (a = i.dehydrated, a !== null)) return n2(e, t, o, r, a, i, n); if (s) { s = r.fallback, o = t.mode, i = e.child, a = i.sibling; var f = { mode: "hidden", children: r.children }; return !(o & 1) && t.child !== i ? (r = t.child, r.childLanes = 0, r.pendingProps = f, t.deletions = null) : (r = Or(i, f), r.subtreeFlags = i.subtreeFlags & 14680064), a !== null ? s = Or(a, s) : (s = ri(s, o, n, null), s.flags |= 2), s.return = t, r.return = t, r.sibling = s, t.child = r, r = s, s = t.child, o = e.child.memoizedState, o = o === null ? Pc(n) : { baseLanes: o.baseLanes | n, cachePool: null, transitions: o.transitions }, s.memoizedState = o, s.childLanes = e.childLanes & ~n, t.memoizedState = Cc, r } return s = e.child, e = s.sibling, r = Or(s, { mode: "visible", children: r.children }), !(t.mode & 1) && (r.lanes = n), r.return = t, r.sibling = null, e !== null && (n = t.deletions, n === null ? (t.deletions = [e], t.flags |= 16) : n.push(e)), t.child = r, t.memoizedState = null, r } function Yf(e, t) { return t = Ul({ mode: "visible", children: t }, e.mode, 0, null), t.return = e, e.child = t } function Ko(e, t, n, r) { return r !== null && Uf(r), os(t, e.child, null, n), e = Yf(t, t.pendingProps.children), e.flags |= 2, t.memoizedState = null, e } function n2(e, t, n, r, i, s, o) { if (n) return t.flags & 256 ? (t.flags &= -257, r = Au(Error(ue(422))), Ko(e, t, o, r)) : t.memoizedState !== null ? (t.child = e.child, t.flags |= 128, null) : (s = r.fallback, i = t.mode, r = Ul({ mode: "visible", children: r.children }, i, 0, null), s = ri(s, i, o, null), s.flags |= 2, r.return = t, s.return = t, r.sibling = s, t.child = r, t.mode & 1 && os(t, e.child, null, o), t.child.memoizedState = Pc(o), t.memoizedState = Cc, s); if (!(t.mode & 1)) return Ko(e, t, o, null); if (i.data === "$!") { if (r = i.nextSibling && i.nextSibling.dataset, r) var a = r.dgst; return r = a, s = Error(ue(419)), r = Au(s, r, void 0), Ko(e, t, o, r) } if (a = (o & e.childLanes) !== 0, qt || a) { if (r = mt, r !== null) { switch (o & -o) { case 4: i = 2; break; case 16: i = 8; break; case 64: case 128: case 256: case 512: case 1024: case 2048: case 4096: case 8192: case 16384: case 32768: case 65536: case 131072: case 262144: case 524288: case 1048576: case 2097152: case 4194304: case 8388608: case 16777216: case 33554432: case 67108864: i = 32; break; case 536870912: i = 268435456; break; default: i = 0 }i = i & (r.suspendedLanes | o) ? 0 : i, i !== 0 && i !== s.retryLane && (s.retryLane = i, ir(e, i), _n(r, e, i, -1)) } return Jf(), r = Au(Error(ue(421))), Ko(e, t, o, r) } return i.data === "$?" ? (t.flags |= 128, t.child = e.child, t = m2.bind(null, e), i._reactRetry = t, null) : (e = s.treeContext, Zt = Ar(i.nextSibling), Xt = t, Ge = !0, wn = null, e !== null && (nn[rn++] = Xn, nn[rn++] = Qn, nn[rn++] = li, Xn = e.id, Qn = e.overflow, li = t), t = Yf(t, r.children), t.flags |= 4096, t) } function y0(e, t, n) { e.lanes |= t; var r = e.alternate; r !== null && (r.lanes |= t), kc(e.return, t, n) } function ku(e, t, n, r, i) { var s = e.memoizedState; s === null ? e.memoizedState = { isBackwards: t, rendering: null, renderingStartTime: 0, last: r, tail: n, tailMode: i } : (s.isBackwards = t, s.rendering = null, s.renderingStartTime = 0, s.last = r, s.tail = n, s.tailMode = i) } function h1(e, t, n) { var r = t.pendingProps, i = r.revealOrder, s = r.tail; if (Pt(e, t, r.children, n), r = Le.current, r & 2) r = r & 1 | 2, t.flags |= 128; else { if (e !== null && e.flags & 128) e: for (e = t.child; e !== null;) { if (e.tag === 13) e.memoizedState !== null && y0(e, n, t); else if (e.tag === 19) y0(e, n, t); else if (e.child !== null) { e.child.return = e, e = e.child; continue } if (e === t) break e; for (; e.sibling === null;) { if (e.return === null || e.return === t) break e; e = e.return } e.sibling.return = e.return, e = e.sibling } r &= 1 } if (Ve(Le, r), !(t.mode & 1)) t.memoizedState = null; else switch (i) { case "forwards": for (n = t.child, i = null; n !== null;)e = n.alternate, e !== null && nl(e) === null && (i = n), n = n.sibling; n = i, n === null ? (i = t.child, t.child = null) : (i = n.sibling, n.sibling = null), ku(t, !1, i, n, s); break; case "backwards": for (n = null, i = t.child, t.child = null; i !== null;) { if (e = i.alternate, e !== null && nl(e) === null) { t.child = i; break } e = i.sibling, i.sibling = n, n = i, i = e } ku(t, !0, n, null, s); break; case "together": ku(t, !1, null, null, void 0); break; default: t.memoizedState = null }return t.child } function ga(e, t) { !(t.mode & 1) && e !== null && (e.alternate = null, t.alternate = null, t.flags |= 2) } function sr(e, t, n) { if (e !== null && (t.dependencies = e.dependencies), ci |= t.lanes, !(n & t.childLanes)) return null; if (e !== null && t.child !== e.child) throw Error(ue(153)); if (t.child !== null) { for (e = t.child, n = Or(e, e.pendingProps), t.child = n, n.return = t; e.sibling !== null;)e = e.sibling, n = n.sibling = Or(e, e.pendingProps), n.return = t; n.sibling = null } return t.child } function r2(e, t, n) { switch (t.tag) { case 3: f1(t), ss(); break; case 5: $p(t); break; case 1: Lt(t.type) && Xa(t); break; case 4: $f(t, t.stateNode.containerInfo); break; case 10: var r = t.type._context, i = t.memoizedProps.value; Ve(Ja, r._currentValue), r._currentValue = i; break; case 13: if (r = t.memoizedState, r !== null) return r.dehydrated !== null ? (Ve(Le, Le.current & 1), t.flags |= 128, null) : n & t.child.childLanes ? d1(e, t, n) : (Ve(Le, Le.current & 1), e = sr(e, t, n), e !== null ? e.sibling : null); Ve(Le, Le.current & 1); break; case 19: if (r = (n & t.childLanes) !== 0, e.flags & 128) { if (r) return h1(e, t, n); t.flags |= 128 } if (i = t.memoizedState, i !== null && (i.rendering = null, i.tail = null, i.lastEffect = null), Ve(Le, Le.current), r) break; return null; case 22: case 23: return t.lanes = 0, u1(e, t, n) }return sr(e, t, n) } var p1, Mc, m1, y1; p1 = function (e, t) { for (var n = t.child; n !== null;) { if (n.tag === 5 || n.tag === 6) e.appendChild(n.stateNode); else if (n.tag !== 4 && n.child !== null) { n.child.return = n, n = n.child; continue } if (n === t) break; for (; n.sibling === null;) { if (n.return === null || n.return === t) return; n = n.return } n.sibling.return = n.return, n = n.sibling } }; Mc = function () { }; m1 = function (e, t, n, r) { var i = e.memoizedProps; if (i !== r) { e = t.stateNode, Qr(jn.current); var s = null; switch (n) { case "input": i = sc(e, i), r = sc(e, r), s = []; break; case "select": i = Ye({}, i, { value: void 0 }), r = Ye({}, r, { value: void 0 }), s = []; break; case "textarea": i = lc(e, i), r = lc(e, r), s = []; break; default: typeof i.onClick != "function" && typeof r.onClick == "function" && (e.onclick = Ka) }cc(n, r); var o; n = null; for (h in i) if (!r.hasOwnProperty(h) && i.hasOwnProperty(h) && i[h] != null) if (h === "style") { var a = i[h]; for (o in a) a.hasOwnProperty(o) && (n || (n = {}), n[o] = "") } else h !== "dangerouslySetInnerHTML" && h !== "children" && h !== "suppressContentEditableWarning" && h !== "suppressHydrationWarning" && h !== "autoFocus" && (Xs.hasOwnProperty(h) ? s || (s = []) : (s = s || []).push(h, null)); for (h in r) { var f = r[h]; if (a = i != null ? i[h] : void 0, r.hasOwnProperty(h) && f !== a && (f != null || a != null)) if (h === "style") if (a) { for (o in a) !a.hasOwnProperty(o) || f && f.hasOwnProperty(o) || (n || (n = {}), n[o] = ""); for (o in f) f.hasOwnProperty(o) && a[o] !== f[o] && (n || (n = {}), n[o] = f[o]) } else n || (s || (s = []), s.push(h, n)), n = f; else h === "dangerouslySetInnerHTML" ? (f = f ? f.__html : void 0, a = a ? a.__html : void 0, f != null && a !== f && (s = s || []).push(h, f)) : h === "children" ? typeof f != "string" && typeof f != "number" || (s = s || []).push(h, "" + f) : h !== "suppressContentEditableWarning" && h !== "suppressHydrationWarning" && (Xs.hasOwnProperty(h) ? (f != null && h === "onScroll" && qe("scroll", e), s || a === f || (s = [])) : (s = s || []).push(h, f)) } n && (s = s || []).push("style", n); var h = s; (t.updateQueue = h) && (t.flags |= 4) } }; y1 = function (e, t, n, r) { n !== r && (t.flags |= 4) }; function Bs(e, t) { if (!Ge) switch (e.tailMode) { case "hidden": t = e.tail; for (var n = null; t !== null;)t.alternate !== null && (n = t), t = t.sibling; n === null ? e.tail = null : n.sibling = null; break; case "collapsed": n = e.tail; for (var r = null; n !== null;)n.alternate !== null && (r = n), n = n.sibling; r === null ? t || e.tail === null ? e.tail = null : e.tail.sibling = null : r.sibling = null } } function bt(e) { var t = e.alternate !== null && e.alternate.child === e.child, n = 0, r = 0; if (t) for (var i = e.child; i !== null;)n |= i.lanes | i.childLanes, r |= i.subtreeFlags & 14680064, r |= i.flags & 14680064, i.return = e, i = i.sibling; else for (i = e.child; i !== null;)n |= i.lanes | i.childLanes, r |= i.subtreeFlags, r |= i.flags, i.return = e, i = i.sibling; return e.subtreeFlags |= r, e.childLanes = n, t } function i2(e, t, n) { var r = t.pendingProps; switch (Of(t), t.tag) { case 2: case 16: case 15: case 0: case 11: case 7: case 8: case 12: case 9: case 14: return bt(t), null; case 1: return Lt(t.type) && Za(), bt(t), null; case 3: return r = t.stateNode, as(), He(Gt), He(Rt), Vf(), r.pendingContext && (r.context = r.pendingContext, r.pendingContext = null), (e === null || e.child === null) && (Wo(t) ? t.flags |= 4 : e === null || e.memoizedState.isDehydrated && !(t.flags & 256) || (t.flags |= 1024, wn !== null && (Lc(wn), wn = null))), Mc(e, t), bt(t), null; case 5: zf(t); var i = Qr(lo.current); if (n = t.type, e !== null && t.stateNode != null) m1(e, t, n, r, i), e.ref !== t.ref && (t.flags |= 512, t.flags |= 2097152); else { if (!r) { if (t.stateNode === null) throw Error(ue(166)); return bt(t), null } if (e = Qr(jn.current), Wo(t)) { r = t.stateNode, n = t.type; var s = t.memoizedProps; switch (r[Fn] = t, r[oo] = s, e = (t.mode & 1) !== 0, n) { case "dialog": qe("cancel", r), qe("close", r); break; case "iframe": case "object": case "embed": qe("load", r); break; case "video": case "audio": for (i = 0; i < Us.length; i++)qe(Us[i], r); break; case "source": qe("error", r); break; case "img": case "image": case "link": qe("error", r), qe("load", r); break; case "details": qe("toggle", r); break; case "input": Nd(r, s), qe("invalid", r); break; case "select": r._wrapperState = { wasMultiple: !!s.multiple }, qe("invalid", r); break; case "textarea": Bd(r, s), qe("invalid", r) }cc(n, s), i = null; for (var o in s) if (s.hasOwnProperty(o)) { var a = s[o]; o === "children" ? typeof a == "string" ? r.textContent !== a && (s.suppressHydrationWarning !== !0 && Lo(r.textContent, a, e), i = ["children", a]) : typeof a == "number" && r.textContent !== "" + a && (s.suppressHydrationWarning !== !0 && Lo(r.textContent, a, e), i = ["children", "" + a]) : Xs.hasOwnProperty(o) && a != null && o === "onScroll" && qe("scroll", r) } switch (n) { case "input": Mo(r), Td(r, s, !0); break; case "textarea": Mo(r), Ad(r); break; case "select": case "option": break; default: typeof s.onClick == "function" && (r.onclick = Ka) }r = i, t.updateQueue = r, r !== null && (t.flags |= 4) } else { o = i.nodeType === 9 ? i : i.ownerDocument, e === "http://www.w3.org/1999/xhtml" && (e = Gh(n)), e === "http://www.w3.org/1999/xhtml" ? n === "script" ? (e = o.createElement("div"), e.innerHTML = "<script><\/script>", e = e.removeChild(e.firstChild)) : typeof r.is == "string" ? e = o.createElement(n, { is: r.is }) : (e = o.createElement(n), n === "select" && (o = e, r.multiple ? o.multiple = !0 : r.size && (o.size = r.size))) : e = o.createElementNS(e, n), e[Fn] = t, e[oo] = r, p1(e, t, !1, !1), t.stateNode = e; e: { switch (o = fc(n, r), n) { case "dialog": qe("cancel", e), qe("close", e), i = r; break; case "iframe": case "object": case "embed": qe("load", e), i = r; break; case "video": case "audio": for (i = 0; i < Us.length; i++)qe(Us[i], e); i = r; break; case "source": qe("error", e), i = r; break; case "img": case "image": case "link": qe("error", e), qe("load", e), i = r; break; case "details": qe("toggle", e), i = r; break; case "input": Nd(e, r), i = sc(e, r), qe("invalid", e); break; case "option": i = r; break; case "select": e._wrapperState = { wasMultiple: !!r.multiple }, i = Ye({}, r, { value: void 0 }), qe("invalid", e); break; case "textarea": Bd(e, r), i = lc(e, r), qe("invalid", e); break; default: i = r }cc(n, i), a = i; for (s in a) if (a.hasOwnProperty(s)) { var f = a[s]; s === "style" ? Yh(e, f) : s === "dangerouslySetInnerHTML" ? (f = f ? f.__html : void 0, f != null && Lh(e, f)) : s === "children" ? typeof f == "string" ? (n !== "textarea" || f !== "") && Qs(e, f) : typeof f == "number" && Qs(e, "" + f) : s !== "suppressContentEditableWarning" && s !== "suppressHydrationWarning" && s !== "autoFocus" && (Xs.hasOwnProperty(s) ? f != null && s === "onScroll" && qe("scroll", e) : f != null && gf(e, s, f, o)) } switch (n) { case "input": Mo(e), Td(e, r, !1); break; case "textarea": Mo(e), Ad(e); break; case "option": r.value != null && e.setAttribute("value", "" + Fr(r.value)); break; case "select": e.multiple = !!r.multiple, s = r.value, s != null ? Ki(e, !!r.multiple, s, !1) : r.defaultValue != null && Ki(e, !!r.multiple, r.defaultValue, !0); break; default: typeof i.onClick == "function" && (e.onclick = Ka) }switch (n) { case "button": case "input": case "select": case "textarea": r = !!r.autoFocus; break e; case "img": r = !0; break e; default: r = !1 } } r && (t.flags |= 4) } t.ref !== null && (t.flags |= 512, t.flags |= 2097152) } return bt(t), null; case 6: if (e && t.stateNode != null) y1(e, t, e.memoizedProps, r); else { if (typeof r != "string" && t.stateNode === null) throw Error(ue(166)); if (n = Qr(lo.current), Qr(jn.current), Wo(t)) { if (r = t.stateNode, n = t.memoizedProps, r[Fn] = t, (s = r.nodeValue !== n) && (e = Xt, e !== null)) switch (e.tag) { case 3: Lo(r.nodeValue, n, (e.mode & 1) !== 0); break; case 5: e.memoizedProps.suppressHydrationWarning !== !0 && Lo(r.nodeValue, n, (e.mode & 1) !== 0) }s && (t.flags |= 4) } else r = (n.nodeType === 9 ? n : n.ownerDocument).createTextNode(r), r[Fn] = t, t.stateNode = r } return bt(t), null; case 13: if (He(Le), r = t.memoizedState, e === null || e.memoizedState !== null && e.memoizedState.dehydrated !== null) { if (Ge && Zt !== null && t.mode & 1 && !(t.flags & 128)) Fp(), ss(), t.flags |= 98560, s = !1; else if (s = Wo(t), r !== null && r.dehydrated !== null) { if (e === null) { if (!s) throw Error(ue(318)); if (s = t.memoizedState, s = s !== null ? s.dehydrated : null, !s) throw Error(ue(317)); s[Fn] = t } else ss(), !(t.flags & 128) && (t.memoizedState = null), t.flags |= 4; bt(t), s = !1 } else wn !== null && (Lc(wn), wn = null), s = !0; if (!s) return t.flags & 65536 ? t : null } return t.flags & 128 ? (t.lanes = n, t) : (r = r !== null, r !== (e !== null && e.memoizedState !== null) && r && (t.child.flags |= 8192, t.mode & 1 && (e === null || Le.current & 1 ? ot === 0 && (ot = 3) : Jf())), t.updateQueue !== null && (t.flags |= 4), bt(t), null); case 4: return as(), Mc(e, t), e === null && io(t.stateNode.containerInfo), bt(t), null; case 10: return Pf(t.type._context), bt(t), null; case 17: return Lt(t.type) && Za(), bt(t), null; case 19: if (He(Le), s = t.memoizedState, s === null) return bt(t), null; if (r = (t.flags & 128) !== 0, o = s.rendering, o === null) if (r) Bs(s, !1); else { if (ot !== 0 || e !== null && e.flags & 128) for (e = t.child; e !== null;) { if (o = nl(e), o !== null) { for (t.flags |= 128, Bs(s, !1), r = o.updateQueue, r !== null && (t.updateQueue = r, t.flags |= 4), t.subtreeFlags = 0, r = n, n = t.child; n !== null;)s = n, e = r, s.flags &= 14680066, o = s.alternate, o === null ? (s.childLanes = 0, s.lanes = e, s.child = null, s.subtreeFlags = 0, s.memoizedProps = null, s.memoizedState = null, s.updateQueue = null, s.dependencies = null, s.stateNode = null) : (s.childLanes = o.childLanes, s.lanes = o.lanes, s.child = o.child, s.subtreeFlags = 0, s.deletions = null, s.memoizedProps = o.memoizedProps, s.memoizedState = o.memoizedState, s.updateQueue = o.updateQueue, s.type = o.type, e = o.dependencies, s.dependencies = e === null ? null : { lanes: e.lanes, firstContext: e.firstContext }), n = n.sibling; return Ve(Le, Le.current & 1 | 2), t.child } e = e.sibling } s.tail !== null && De() > us && (t.flags |= 128, r = !0, Bs(s, !1), t.lanes = 4194304) } else { if (!r) if (e = nl(o), e !== null) { if (t.flags |= 128, r = !0, n = e.updateQueue, n !== null && (t.updateQueue = n, t.flags |= 4), Bs(s, !0), s.tail === null && s.tailMode === "hidden" && !o.alternate && !Ge) return bt(t), null } else 2 * De() - s.renderingStartTime > us && n !== 1073741824 && (t.flags |= 128, r = !0, Bs(s, !1), t.lanes = 4194304); s.isBackwards ? (o.sibling = t.child, t.child = o) : (n = s.last, n !== null ? n.sibling = o : t.child = o, s.last = o) } return s.tail !== null ? (t = s.tail, s.rendering = t, s.tail = t.sibling, s.renderingStartTime = De(), t.sibling = null, n = Le.current, Ve(Le, r ? n & 1 | 2 : n & 1), t) : (bt(t), null); case 22: case 23: return Df(), r = t.memoizedState !== null, e !== null && e.memoizedState !== null !== r && (t.flags |= 8192), r && t.mode & 1 ? Yt & 1073741824 && (bt(t), t.subtreeFlags & 6 && (t.flags |= 8192)) : bt(t), null; case 24: return null; case 25: return null }throw Error(ue(156, t.tag)) } function s2(e, t) { switch (Of(t), t.tag) { case 1: return Lt(t.type) && Za(), e = t.flags, e & 65536 ? (t.flags = e & -65537 | 128, t) : null; case 3: return as(), He(Gt), He(Rt), Vf(), e = t.flags, e & 65536 && !(e & 128) ? (t.flags = e & -65537 | 128, t) : null; case 5: return zf(t), null; case 13: if (He(Le), e = t.memoizedState, e !== null && e.dehydrated !== null) { if (t.alternate === null) throw Error(ue(340)); ss() } return e = t.flags, e & 65536 ? (t.flags = e & -65537 | 128, t) : null; case 19: return He(Le), null; case 4: return as(), null; case 10: return Pf(t.type._context), null; case 22: case 23: return Df(), null; case 24: return null; default: return null } } var Zo = !1, At = !1, o2 = typeof WeakSet == "function" ? WeakSet : Set, he = null; function Vi(e, t) { var n = e.ref; if (n !== null) if (typeof n == "function") try { n(null) } catch (r) { Ke(e, t, r) } else n.current = null } function jc(e, t, n) { try { n() } catch (r) { Ke(e, t, r) } } var g0 = !1; function a2(e, t) { if (_c = La, e = _p(), Rf(e)) { if ("selectionStart" in e) var n = { start: e.selectionStart, end: e.selectionEnd }; else e: { n = (n = e.ownerDocument) && n.defaultView || window; var r = n.getSelection && n.getSelection(); if (r && r.rangeCount !== 0) { n = r.anchorNode; var i = r.anchorOffset, s = r.focusNode; r = r.focusOffset; try { n.nodeType, s.nodeType } catch { n = null; break e } var o = 0, a = -1, f = -1, h = 0, _ = 0, v = e, y = null; t: for (; ;) { for (var w; v !== n || i !== 0 && v.nodeType !== 3 || (a = o + i), v !== s || r !== 0 && v.nodeType !== 3 || (f = o + r), v.nodeType === 3 && (o += v.nodeValue.length), (w = v.firstChild) !== null;)y = v, v = w; for (; ;) { if (v === e) break t; if (y === n && ++h === i && (a = o), y === s && ++_ === r && (f = o), (w = v.nextSibling) !== null) break; v = y, y = v.parentNode } v = w } n = a === -1 || f === -1 ? null : { start: a, end: f } } else n = null } n = n || { start: 0, end: 0 } } else n = null; for (Ec = { focusedElem: e, selectionRange: n }, La = !1, he = t; he !== null;)if (t = he, e = t.child, (t.subtreeFlags & 1028) !== 0 && e !== null) e.return = t, he = e; else for (; he !== null;) { t = he; try { var p = t.alternate; if (t.flags & 1024) switch (t.tag) { case 0: case 11: case 15: break; case 1: if (p !== null) { var O = p.memoizedProps, $ = p.memoizedState, b = t.stateNode, E = b.getSnapshotBeforeUpdate(t.elementType === t.type ? O : mn(t.type, O), $); b.__reactInternalSnapshotBeforeUpdate = E } break; case 3: var S = t.stateNode.containerInfo; S.nodeType === 1 ? S.textContent = "" : S.nodeType === 9 && S.documentElement && S.removeChild(S.documentElement); break; case 5: case 6: case 4: case 17: break; default: throw Error(ue(163)) } } catch (M) { Ke(t, t.return, M) } if (e = t.sibling, e !== null) { e.return = t.return, he = e; break } he = t.return } return p = g0, g0 = !1, p } function Ys(e, t, n) { var r = t.updateQueue; if (r = r !== null ? r.lastEffect : null, r !== null) { var i = r = r.next; do { if ((i.tag & e) === e) { var s = i.destroy; i.destroy = void 0, s !== void 0 && jc(t, n, s) } i = i.next } while (i !== r) } } function Il(e, t) { if (t = t.updateQueue, t = t !== null ? t.lastEffect : null, t !== null) { var n = t = t.next; do { if ((n.tag & e) === e) { var r = n.create; n.destroy = r() } n = n.next } while (n !== t) } } function $c(e) { var t = e.ref; if (t !== null) { var n = e.stateNode; switch (e.tag) { case 5: e = n; break; default: e = n }typeof t == "function" ? t(e) : t.current = e } } function g1(e) { var t = e.alternate; t !== null && (e.alternate = null, g1(t)), e.child = null, e.deletions = null, e.sibling = null, e.tag === 5 && (t = e.stateNode, t !== null && (delete t[Fn], delete t[oo], delete t[Nc], delete t[Hw], delete t[Gw])), e.stateNode = null, e.return = null, e.dependencies = null, e.memoizedProps = null, e.memoizedState = null, e.pendingProps = null, e.stateNode = null, e.updateQueue = null } function w1(e) { return e.tag === 5 || e.tag === 3 || e.tag === 4 } function w0(e) { e: for (; ;) { for (; e.sibling === null;) { if (e.return === null || w1(e.return)) return null; e = e.return } for (e.sibling.return = e.return, e = e.sibling; e.tag !== 5 && e.tag !== 6 && e.tag !== 18;) { if (e.flags & 2 || e.child === null || e.tag === 4) continue e; e.child.return = e, e = e.child } if (!(e.flags & 2)) return e.stateNode } } function zc(e, t, n) { var r = e.tag; if (r === 5 || r === 6) e = e.stateNode, t ? n.nodeType === 8 ? n.parentNode.insertBefore(e, t) : n.insertBefore(e, t) : (n.nodeType === 8 ? (t = n.parentNode, t.insertBefore(e, n)) : (t = n, t.appendChild(e)), n = n._reactRootContainer, n != null || t.onclick !== null || (t.onclick = Ka)); else if (r !== 4 && (e = e.child, e !== null)) for (zc(e, t, n), e = e.sibling; e !== null;)zc(e, t, n), e = e.sibling } function Vc(e, t, n) { var r = e.tag; if (r === 5 || r === 6) e = e.stateNode, t ? n.insertBefore(e, t) : n.appendChild(e); else if (r !== 4 && (e = e.child, e !== null)) for (Vc(e, t, n), e = e.sibling; e !== null;)Vc(e, t, n), e = e.sibling } var gt = null, gn = !1; function cr(e, t, n) { for (n = n.child; n !== null;)x1(e, t, n), n = n.sibling } function x1(e, t, n) { if (Mn && typeof Mn.onCommitFiberUnmount == "function") try { Mn.onCommitFiberUnmount(bl, n) } catch { } switch (n.tag) { case 5: At || Vi(n, t); case 6: var r = gt, i = gn; gt = null, cr(e, t, n), gt = r, gn = i, gt !== null && (gn ? (e = gt, n = n.stateNode, e.nodeType === 8 ? e.parentNode.removeChild(n) : e.removeChild(n)) : gt.removeChild(n.stateNode)); break; case 18: gt !== null && (gn ? (e = gt, n = n.stateNode, e.nodeType === 8 ? Eu(e.parentNode, n) : e.nodeType === 1 && Eu(e, n), to(e)) : Eu(gt, n.stateNode)); break; case 4: r = gt, i = gn, gt = n.stateNode.containerInfo, gn = !0, cr(e, t, n), gt = r, gn = i; break; case 0: case 11: case 14: case 15: if (!At && (r = n.updateQueue, r !== null && (r = r.lastEffect, r !== null))) { i = r = r.next; do { var s = i, o = s.destroy; s = s.tag, o !== void 0 && (s & 2 || s & 4) && jc(n, t, o), i = i.next } while (i !== r) } cr(e, t, n); break; case 1: if (!At && (Vi(n, t), r = n.stateNode, typeof r.componentWillUnmount == "function")) try { r.props = n.memoizedProps, r.state = n.memoizedState, r.componentWillUnmount() } catch (a) { Ke(n, t, a) } cr(e, t, n); break; case 21: cr(e, t, n); break; case 22: n.mode & 1 ? (At = (r = At) || n.memoizedState !== null, cr(e, t, n), At = r) : cr(e, t, n); break; default: cr(e, t, n) } } function x0(e) { var t = e.updateQueue; if (t !== null) { e.updateQueue = null; var n = e.stateNode; n === null && (n = e.stateNode = new o2), t.forEach(function (r) { var i = y2.bind(null, e, r); n.has(r) || (n.add(r), r.then(i, i)) }) } } function fn(e, t) { var n = t.deletions; if (n !== null) for (var r = 0; r < n.length; r++) { var i = n[r]; try { var s = e, o = t, a = o; e: for (; a !== null;) { switch (a.tag) { case 5: gt = a.stateNode, gn = !1; break e; case 3: gt = a.stateNode.containerInfo, gn = !0; break e; case 4: gt = a.stateNode.containerInfo, gn = !0; break e }a = a.return } if (gt === null) throw Error(ue(160)); x1(s, o, i), gt = null, gn = !1; var f = i.alternate; f !== null && (f.return = null), i.return = null } catch (h) { Ke(i, t, h) } } if (t.subtreeFlags & 12854) for (t = t.child; t !== null;)v1(t, e), t = t.sibling } function v1(e, t) { var n = e.alternate, r = e.flags; switch (e.tag) { case 0: case 11: case 14: case 15: if (fn(t, e), Sn(e), r & 4) { try { Ys(3, e, e.return), Il(3, e) } catch (O) { Ke(e, e.return, O) } try { Ys(5, e, e.return) } catch (O) { Ke(e, e.return, O) } } break; case 1: fn(t, e), Sn(e), r & 512 && n !== null && Vi(n, n.return); break; case 5: if (fn(t, e), Sn(e), r & 512 && n !== null && Vi(n, n.return), e.flags & 32) { var i = e.stateNode; try { Qs(i, "") } catch (O) { Ke(e, e.return, O) } } if (r & 4 && (i = e.stateNode, i != null)) { var s = e.memoizedProps, o = n !== null ? n.memoizedProps : s, a = e.type, f = e.updateQueue; if (e.updateQueue = null, f !== null) try { a === "input" && s.type === "radio" && s.name != null && qh(i, s), fc(a, o); var h = fc(a, s); for (o = 0; o < f.length; o += 2) { var _ = f[o], v = f[o + 1]; _ === "style" ? Yh(i, v) : _ === "dangerouslySetInnerHTML" ? Lh(i, v) : _ === "children" ? Qs(i, v) : gf(i, _, v, h) } switch (a) { case "input": oc(i, s); break; case "textarea": Hh(i, s); break; case "select": var y = i._wrapperState.wasMultiple; i._wrapperState.wasMultiple = !!s.multiple; var w = s.value; w != null ? Ki(i, !!s.multiple, w, !1) : y !== !!s.multiple && (s.defaultValue != null ? Ki(i, !!s.multiple, s.defaultValue, !0) : Ki(i, !!s.multiple, s.multiple ? [] : "", !1)) }i[oo] = s } catch (O) { Ke(e, e.return, O) } } break; case 6: if (fn(t, e), Sn(e), r & 4) { if (e.stateNode === null) throw Error(ue(162)); i = e.stateNode, s = e.memoizedProps; try { i.nodeValue = s } catch (O) { Ke(e, e.return, O) } } break; case 3: if (fn(t, e), Sn(e), r & 4 && n !== null && n.memoizedState.isDehydrated) try { to(t.containerInfo) } catch (O) { Ke(e, e.return, O) } break; case 4: fn(t, e), Sn(e); break; case 13: fn(t, e), Sn(e), i = e.child, i.flags & 8192 && (s = i.memoizedState !== null, i.stateNode.isHidden = s, !s || i.alternate !== null && i.alternate.memoizedState !== null || (Xf = De())), r & 4 && x0(e); break; case 22: if (_ = n !== null && n.memoizedState !== null, e.mode & 1 ? (At = (h = At) || _, fn(t, e), At = h) : fn(t, e), Sn(e), r & 8192) { if (h = e.memoizedState !== null, (e.stateNode.isHidden = h) && !_ && e.mode & 1) for (he = e, _ = e.child; _ !== null;) { for (v = he = _; he !== null;) { switch (y = he, w = y.child, y.tag) { case 0: case 11: case 14: case 15: Ys(4, y, y.return); break; case 1: Vi(y, y.return); var p = y.stateNode; if (typeof p.componentWillUnmount == "function") { r = y, n = y.return; try { t = r, p.props = t.memoizedProps, p.state = t.memoizedState, p.componentWillUnmount() } catch (O) { Ke(r, n, O) } } break; case 5: Vi(y, y.return); break; case 22: if (y.memoizedState !== null) { _0(v); continue } }w !== null ? (w.return = y, he = w) : _0(v) } _ = _.sibling } e: for (_ = null, v = e; ;) { if (v.tag === 5) { if (_ === null) { _ = v; try { i = v.stateNode, h ? (s = i.style, typeof s.setProperty == "function" ? s.setProperty("display", "none", "important") : s.display = "none") : (a = v.stateNode, f = v.memoizedProps.style, o = f != null && f.hasOwnProperty("display") ? f.display : null, a.style.display = Wh("display", o)) } catch (O) { Ke(e, e.return, O) } } } else if (v.tag === 6) { if (_ === null) try { v.stateNode.nodeValue = h ? "" : v.memoizedProps } catch (O) { Ke(e, e.return, O) } } else if ((v.tag !== 22 && v.tag !== 23 || v.memoizedState === null || v === e) && v.child !== null) { v.child.return = v, v = v.child; continue } if (v === e) break e; for (; v.sibling === null;) { if (v.return === null || v.return === e) break e; _ === v && (_ = null), v = v.return } _ === v && (_ = null), v.sibling.return = v.return, v = v.sibling } } break; case 19: fn(t, e), Sn(e), r & 4 && x0(e); break; case 21: break; default: fn(t, e), Sn(e) } } function Sn(e) { var t = e.flags; if (t & 2) { try { e: { for (var n = e.return; n !== null;) { if (w1(n)) { var r = n; break e } n = n.return } throw Error(ue(160)) } switch (r.tag) { case 5: var i = r.stateNode; r.flags & 32 && (Qs(i, ""), r.flags &= -33); var s = w0(e); Vc(e, s, i); break; case 3: case 4: var o = r.stateNode.containerInfo, a = w0(e); zc(e, a, o); break; default: throw Error(ue(161)) } } catch (f) { Ke(e, e.return, f) } e.flags &= -3 } t & 4096 && (e.flags &= -4097) } function l2(e, t, n) { he = e, _1(e) } function _1(e, t, n) { for (var r = (e.mode & 1) !== 0; he !== null;) { var i = he, s = i.child; if (i.tag === 22 && r) { var o = i.memoizedState !== null || Zo; if (!o) { var a = i.alternate, f = a !== null && a.memoizedState !== null || At; a = Zo; var h = At; if (Zo = o, (At = f) && !h) for (he = i; he !== null;)o = he, f = o.child, o.tag === 22 && o.memoizedState !== null ? E0(i) : f !== null ? (f.return = o, he = f) : E0(i); for (; s !== null;)he = s, _1(s), s = s.sibling; he = i, Zo = a, At = h } v0(e) } else i.subtreeFlags & 8772 && s !== null ? (s.return = i, he = s) : v0(e) } } function v0(e) { for (; he !== null;) { var t = he; if (t.flags & 8772) { var n = t.alternate; try { if (t.flags & 8772) switch (t.tag) { case 0: case 11: case 15: At || Il(5, t); break; case 1: var r = t.stateNode; if (t.flags & 4 && !At) if (n === null) r.componentDidMount(); else { var i = t.elementType === t.type ? n.memoizedProps : mn(t.type, n.memoizedProps); r.componentDidUpdate(i, n.memoizedState, r.__reactInternalSnapshotBeforeUpdate) } var s = t.updateQueue; s !== null && i0(t, s, r); break; case 3: var o = t.updateQueue; if (o !== null) { if (n = null, t.child !== null) switch (t.child.tag) { case 5: n = t.child.stateNode; break; case 1: n = t.child.stateNode }i0(t, o, n) } break; case 5: var a = t.stateNode; if (n === null && t.flags & 4) { n = a; var f = t.memoizedProps; switch (t.type) { case "button": case "input": case "select": case "textarea": f.autoFocus && n.focus(); break; case "img": f.src && (n.src = f.src) } } break; case 6: break; case 4: break; case 12: break; case 13: if (t.memoizedState === null) { var h = t.alternate; if (h !== null) { var _ = h.memoizedState; if (_ !== null) { var v = _.dehydrated; v !== null && to(v) } } } break; case 19: case 17: case 21: case 22: case 23: case 25: break; default: throw Error(ue(163)) }At || t.flags & 512 && $c(t) } catch (y) { Ke(t, t.return, y) } } if (t === e) { he = null; break } if (n = t.sibling, n !== null) { n.return = t.return, he = n; break } he = t.return } } function _0(e) { for (; he !== null;) { var t = he; if (t === e) { he = null; break } var n = t.sibling; if (n !== null) { n.return = t.return, he = n; break } he = t.return } } function E0(e) { for (; he !== null;) { var t = he; try { switch (t.tag) { case 0: case 11: case 15: var n = t.return; try { Il(4, t) } catch (f) { Ke(t, n, f) } break; case 1: var r = t.stateNode; if (typeof r.componentDidMount == "function") { var i = t.return; try { r.componentDidMount() } catch (f) { Ke(t, i, f) } } var s = t.return; try { $c(t) } catch (f) { Ke(t, s, f) } break; case 5: var o = t.return; try { $c(t) } catch (f) { Ke(t, o, f) } } } catch (f) { Ke(t, t.return, f) } if (t === e) { he = null; break } var a = t.sibling; if (a !== null) { a.return = t.return, he = a; break } he = t.return } } var u2 = Math.ceil, sl = ar.ReactCurrentDispatcher, Kf = ar.ReactCurrentOwner, an = ar.ReactCurrentBatchConfig, Ie = 0, mt = null, nt = null, xt = 0, Yt = 0, qi = Mr(0), ot = 0, ho = null, ci = 0, Ol = 0, Zf = 0, Ks = null, Vt = null, Xf = 0, us = 1 / 0, Gn = null, ol = !1, qc = null, Rr = null, Xo = !1, Sr = null, al = 0, Zs = 0, Hc = null, wa = -1, xa = 0; function jt() { return Ie & 6 ? De() : wa !== -1 ? wa : wa = De() } function Ir(e) { return e.mode & 1 ? Ie & 2 && xt !== 0 ? xt & -xt : Ww.transition !== null ? (xa === 0 && (xa = sp()), xa) : (e = Ce, e !== 0 || (e = window.event, e = e === void 0 ? 16 : dp(e.type)), e) : 1 } function _n(e, t, n, r) { if (50 < Zs) throw Zs = 0, Hc = null, Error(ue(185)); Eo(e, n, r), (!(Ie & 2) || e !== mt) && (e === mt && (!(Ie & 2) && (Ol |= n), ot === 4 && Er(e, xt)), Wt(e, r), n === 1 && Ie === 0 && !(t.mode & 1) && (us = De() + 500, Al && jr())) } function Wt(e, t) { var n = e.callbackNode; Wg(e, t); var r = Ga(e, e === mt ? xt : 0); if (r === 0) n !== null && Id(n), e.callbackNode = null, e.callbackPriority = 0; else if (t = r & -r, e.callbackPriority !== t) { if (n != null && Id(n), t === 1) e.tag === 0 ? Lw(b0.bind(null, e)) : Ip(b0.bind(null, e)), Vw(function () { !(Ie & 6) && jr() }), n = null; else { switch (op(r)) { case 1: n = Ef; break; case 4: n = rp; break; case 16: n = Ha; break; case 536870912: n = ip; break; default: n = Ha }n = k1(n, E1.bind(null, e)) } e.callbackPriority = t, e.callbackNode = n } } function E1(e, t) { if (wa = -1, xa = 0, Ie & 6) throw Error(ue(327)); var n = e.callbackNode; if (Ji() && e.callbackNode !== n) return null; var r = Ga(e, e === mt ? xt : 0); if (r === 0) return null; if (r & 30 || r & e.expiredLanes || t) t = ll(e, r); else { t = r; var i = Ie; Ie |= 2; var s = S1(); (mt !== e || xt !== t) && (Gn = null, us = De() + 500, ni(e, t)); do try { d2(); break } catch (a) { b1(e, a) } while (!0); Cf(), sl.current = s, Ie = i, nt !== null ? t = 0 : (mt = null, xt = 0, t = ot) } if (t !== 0) { if (t === 2 && (i = yc(e), i !== 0 && (r = i, t = Gc(e, i))), t === 1) throw n = ho, ni(e, 0), Er(e, r), Wt(e, De()), n; if (t === 6) Er(e, r); else { if (i = e.current.alternate, !(r & 30) && !c2(i) && (t = ll(e, r), t === 2 && (s = yc(e), s !== 0 && (r = s, t = Gc(e, s))), t === 1)) throw n = ho, ni(e, 0), Er(e, r), Wt(e, De()), n; switch (e.finishedWork = i, e.finishedLanes = r, t) { case 0: case 1: throw Error(ue(345)); case 2: qr(e, Vt, Gn); break; case 3: if (Er(e, r), (r & 130023424) === r && (t = Xf + 500 - De(), 10 < t)) { if (Ga(e, 0) !== 0) break; if (i = e.suspendedLanes, (i & r) !== r) { jt(), e.pingedLanes |= e.suspendedLanes & i; break } e.timeoutHandle = Sc(qr.bind(null, e, Vt, Gn), t); break } qr(e, Vt, Gn); break; case 4: if (Er(e, r), (r & 4194240) === r) break; for (t = e.eventTimes, i = -1; 0 < r;) { var o = 31 - vn(r); s = 1 << o, o = t[o], o > i && (i = o), r &= ~s } if (r = i, r = De() - r, r = (120 > r ? 120 : 480 > r ? 480 : 1080 > r ? 1080 : 1920 > r ? 1920 : 3e3 > r ? 3e3 : 4320 > r ? 4320 : 1960 * u2(r / 1960)) - r, 10 < r) { e.timeoutHandle = Sc(qr.bind(null, e, Vt, Gn), r); break } qr(e, Vt, Gn); break; case 5: qr(e, Vt, Gn); break; default: throw Error(ue(329)) } } } return Wt(e, De()), e.callbackNode === n ? E1.bind(null, e) : null } function Gc(e, t) { var n = Ks; return e.current.memoizedState.isDehydrated && (ni(e, t).flags |= 256), e = ll(e, t), e !== 2 && (t = Vt, Vt = n, t !== null && Lc(t)), e } function Lc(e) { Vt === null ? Vt = e : Vt.push.apply(Vt, e) } function c2(e) { for (var t = e; ;) { if (t.flags & 16384) { var n = t.updateQueue; if (n !== null && (n = n.stores, n !== null)) for (var r = 0; r < n.length; r++) { var i = n[r], s = i.getSnapshot; i = i.value; try { if (!En(s(), i)) return !1 } catch { return !1 } } } if (n = t.child, t.subtreeFlags & 16384 && n !== null) n.return = t, t = n; else { if (t === e) break; for (; t.sibling === null;) { if (t.return === null || t.return === e) return !0; t = t.return } t.sibling.return = t.return, t = t.sibling } } return !0 } function Er(e, t) { for (t &= ~Zf, t &= ~Ol, e.suspendedLanes |= t, e.pingedLanes &= ~t, e = e.expirationTimes; 0 < t;) { var n = 31 - vn(t), r = 1 << n; e[n] = -1, t &= ~r } } function b0(e) { if (Ie & 6) throw Error(ue(327)); Ji(); var t = Ga(e, 0); if (!(t & 1)) return Wt(e, De()), null; var n = ll(e, t); if (e.tag !== 0 && n === 2) { var r = yc(e); r !== 0 && (t = r, n = Gc(e, r)) } if (n === 1) throw n = ho, ni(e, 0), Er(e, t), Wt(e, De()), n; if (n === 6) throw Error(ue(345)); return e.finishedWork = e.current.alternate, e.finishedLanes = t, qr(e, Vt, Gn), Wt(e, De()), null } function Qf(e, t) { var n = Ie; Ie |= 1; try { return e(t) } finally { Ie = n, Ie === 0 && (us = De() + 500, Al && jr()) } } function fi(e) { Sr !== null && Sr.tag === 0 && !(Ie & 6) && Ji(); var t = Ie; Ie |= 1; var n = an.transition, r = Ce; try { if (an.transition = null, Ce = 1, e) return e() } finally { Ce = r, an.transition = n, Ie = t, !(Ie & 6) && jr() } } function Df() { Yt = qi.current, He(qi) } function ni(e, t) { e.finishedWork = null, e.finishedLanes = 0; var n = e.timeoutHandle; if (n !== -1 && (e.timeoutHandle = -1, zw(n)), nt !== null) for (n = nt.return; n !== null;) { var r = n; switch (Of(r), r.tag) { case 1: r = r.type.childContextTypes, r != null && Za(); break; case 3: as(), He(Gt), He(Rt), Vf(); break; case 5: zf(r); break; case 4: as(); break; case 13: He(Le); break; case 19: He(Le); break; case 10: Pf(r.type._context); break; case 22: case 23: Df() }n = n.return } if (mt = e, nt = e = Or(e.current, null), xt = Yt = t, ot = 0, ho = null, Zf = Ol = ci = 0, Vt = Ks = null, Xr !== null) { for (t = 0; t < Xr.length; t++)if (n = Xr[t], r = n.interleaved, r !== null) { n.interleaved = null; var i = r.next, s = n.pending; if (s !== null) { var o = s.next; s.next = i, r.next = o } n.pending = r } Xr = null } return e } function b1(e, t) { do { var n = nt; try { if (Cf(), ma.current = il, rl) { for (var r = We.memoizedState; r !== null;) { var i = r.queue; i !== null && (i.pending = null), r = r.next } rl = !1 } if (ui = 0, dt = it = We = null, Ws = !1, uo = 0, Kf.current = null, n === null || n.return === null) { ot = 1, ho = t, nt = null; break } e: { var s = e, o = n.return, a = n, f = t; if (t = xt, a.flags |= 32768, f !== null && typeof f == "object" && typeof f.then == "function") { var h = f, _ = a, v = _.tag; if (!(_.mode & 1) && (v === 0 || v === 11 || v === 15)) { var y = _.alternate; y ? (_.updateQueue = y.updateQueue, _.memoizedState = y.memoizedState, _.lanes = y.lanes) : (_.updateQueue = null, _.memoizedState = null) } var w = c0(o); if (w !== null) { w.flags &= -257, f0(w, o, a, s, t), w.mode & 1 && u0(s, h, t), t = w, f = h; var p = t.updateQueue; if (p === null) { var O = new Set; O.add(f), t.updateQueue = O } else p.add(f); break e } else { if (!(t & 1)) { u0(s, h, t), Jf(); break e } f = Error(ue(426)) } } else if (Ge && a.mode & 1) { var $ = c0(o); if ($ !== null) { !($.flags & 65536) && ($.flags |= 256), f0($, o, a, s, t), Uf(ls(f, a)); break e } } s = f = ls(f, a), ot !== 4 && (ot = 2), Ks === null ? Ks = [s] : Ks.push(s), s = o; do { switch (s.tag) { case 3: s.flags |= 65536, t &= -t, s.lanes |= t; var b = o1(s, f, t); r0(s, b); break e; case 1: a = f; var E = s.type, S = s.stateNode; if (!(s.flags & 128) && (typeof E.getDerivedStateFromError == "function" || S !== null && typeof S.componentDidCatch == "function" && (Rr === null || !Rr.has(S)))) { s.flags |= 65536, t &= -t, s.lanes |= t; var M = a1(s, a, t); r0(s, M); break e } }s = s.return } while (s !== null) } T1(n) } catch (k) { t = k, nt === n && n !== null && (nt = n = n.return); continue } break } while (!0) } function S1() { var e = sl.current; return sl.current = il, e === null ? il : e } function Jf() { (ot === 0 || ot === 3 || ot === 2) && (ot = 4), mt === null || !(ci & 268435455) && !(Ol & 268435455) || Er(mt, xt) } function ll(e, t) { var n = Ie; Ie |= 2; var r = S1(); (mt !== e || xt !== t) && (Gn = null, ni(e, t)); do try { f2(); break } catch (i) { b1(e, i) } while (!0); if (Cf(), Ie = n, sl.current = r, nt !== null) throw Error(ue(261)); return mt = null, xt = 0, ot } function f2() { for (; nt !== null;)N1(nt) } function d2() { for (; nt !== null && !Mg();)N1(nt) } function N1(e) { var t = A1(e.alternate, e, Yt); e.memoizedProps = e.pendingProps, t === null ? T1(e) : nt = t, Kf.current = null } function T1(e) { var t = e; do { var n = t.alternate; if (e = t.return, t.flags & 32768) { if (n = s2(n, t), n !== null) { n.flags &= 32767, nt = n; return } if (e !== null) e.flags |= 32768, e.subtreeFlags = 0, e.deletions = null; else { ot = 6, nt = null; return } } else if (n = i2(n, t, Yt), n !== null) { nt = n; return } if (t = t.sibling, t !== null) { nt = t; return } nt = t = e } while (t !== null); ot === 0 && (ot = 5) } function qr(e, t, n) { var r = Ce, i = an.transition; try { an.transition = null, Ce = 1, h2(e, t, n, r) } finally { an.transition = i, Ce = r } return null } function h2(e, t, n, r) { do Ji(); while (Sr !== null); if (Ie & 6) throw Error(ue(327)); n = e.finishedWork; var i = e.finishedLanes; if (n === null) return null; if (e.finishedWork = null, e.finishedLanes = 0, n === e.current) throw Error(ue(177)); e.callbackNode = null, e.callbackPriority = 0; var s = n.lanes | n.childLanes; if (Yg(e, s), e === mt && (nt = mt = null, xt = 0), !(n.subtreeFlags & 2064) && !(n.flags & 2064) || Xo || (Xo = !0, k1(Ha, function () { return Ji(), null })), s = (n.flags & 15990) !== 0, n.subtreeFlags & 15990 || s) { s = an.transition, an.transition = null; var o = Ce; Ce = 1; var a = Ie; Ie |= 4, Kf.current = null, a2(e, n), v1(n, e), Uw(Ec), La = !!_c, Ec = _c = null, e.current = n, l2(n), jg(), Ie = a, Ce = o, an.transition = s } else e.current = n; if (Xo && (Xo = !1, Sr = e, al = i), s = e.pendingLanes, s === 0 && (Rr = null), Vg(n.stateNode), Wt(e, De()), t !== null) for (r = e.onRecoverableError, n = 0; n < t.length; n++)i = t[n], r(i.value, { componentStack: i.stack, digest: i.digest }); if (ol) throw ol = !1, e = qc, qc = null, e; return al & 1 && e.tag !== 0 && Ji(), s = e.pendingLanes, s & 1 ? e === Hc ? Zs++ : (Zs = 0, Hc = e) : Zs = 0, jr(), null } function Ji() { if (Sr !== null) { var e = op(al), t = an.transition, n = Ce; try { if (an.transition = null, Ce = 16 > e ? 16 : e, Sr === null) var r = !1; else { if (e = Sr, Sr = null, al = 0, Ie & 6) throw Error(ue(331)); var i = Ie; for (Ie |= 4, he = e.current; he !== null;) { var s = he, o = s.child; if (he.flags & 16) { var a = s.deletions; if (a !== null) { for (var f = 0; f < a.length; f++) { var h = a[f]; for (he = h; he !== null;) { var _ = he; switch (_.tag) { case 0: case 11: case 15: Ys(8, _, s) }var v = _.child; if (v !== null) v.return = _, he = v; else for (; he !== null;) { _ = he; var y = _.sibling, w = _.return; if (g1(_), _ === h) { he = null; break } if (y !== null) { y.return = w, he = y; break } he = w } } } var p = s.alternate; if (p !== null) { var O = p.child; if (O !== null) { p.child = null; do { var $ = O.sibling; O.sibling = null, O = $ } while (O !== null) } } he = s } } if (s.subtreeFlags & 2064 && o !== null) o.return = s, he = o; else e: for (; he !== null;) { if (s = he, s.flags & 2048) switch (s.tag) { case 0: case 11: case 15: Ys(9, s, s.return) }var b = s.sibling; if (b !== null) { b.return = s.return, he = b; break e } he = s.return } } var E = e.current; for (he = E; he !== null;) { o = he; var S = o.child; if (o.subtreeFlags & 2064 && S !== null) S.return = o, he = S; else e: for (o = E; he !== null;) { if (a = he, a.flags & 2048) try { switch (a.tag) { case 0: case 11: case 15: Il(9, a) } } catch (k) { Ke(a, a.return, k) } if (a === o) { he = null; break e } var M = a.sibling; if (M !== null) { M.return = a.return, he = M; break e } he = a.return } } if (Ie = i, jr(), Mn && typeof Mn.onPostCommitFiberRoot == "function") try { Mn.onPostCommitFiberRoot(bl, e) } catch { } r = !0 } return r } finally { Ce = n, an.transition = t } } return !1 } function S0(e, t, n) { t = ls(n, t), t = o1(e, t, 1), e = kr(e, t, 1), t = jt(), e !== null && (Eo(e, 1, t), Wt(e, t)) } function Ke(e, t, n) { if (e.tag === 3) S0(e, e, n); else for (; t !== null;) { if (t.tag === 3) { S0(t, e, n); break } else if (t.tag === 1) { var r = t.stateNode; if (typeof t.type.getDerivedStateFromError == "function" || typeof r.componentDidCatch == "function" && (Rr === null || !Rr.has(r))) { e = ls(n, e), e = a1(t, e, 1), t = kr(t, e, 1), e = jt(), t !== null && (Eo(t, 1, e), Wt(t, e)); break } } t = t.return } } function p2(e, t, n) { var r = e.pingCache; r !== null && r.delete(t), t = jt(), e.pingedLanes |= e.suspendedLanes & n, mt === e && (xt & n) === n && (ot === 4 || ot === 3 && (xt & 130023424) === xt && 500 > De() - Xf ? ni(e, 0) : Zf |= n), Wt(e, t) } function B1(e, t) { t === 0 && (e.mode & 1 ? (t = zo, zo <<= 1, !(zo & 130023424) && (zo = 4194304)) : t = 1); var n = jt(); e = ir(e, t), e !== null && (Eo(e, t, n), Wt(e, n)) } function m2(e) { var t = e.memoizedState, n = 0; t !== null && (n = t.retryLane), B1(e, n) } function y2(e, t) { var n = 0; switch (e.tag) { case 13: var r = e.stateNode, i = e.memoizedState; i !== null && (n = i.retryLane); break; case 19: r = e.stateNode; break; default: throw Error(ue(314)) }r !== null && r.delete(t), B1(e, n) } var A1; A1 = function (e, t, n) { if (e !== null) if (e.memoizedProps !== t.pendingProps || Gt.current) qt = !0; else { if (!(e.lanes & n) && !(t.flags & 128)) return qt = !1, r2(e, t, n); qt = !!(e.flags & 131072) } else qt = !1, Ge && t.flags & 1048576 && Op(t, Da, t.index); switch (t.lanes = 0, t.tag) { case 2: var r = t.type; ga(e, t), e = t.pendingProps; var i = is(t, Rt.current); Di(t, n), i = Hf(null, t, r, e, i, n); var s = Gf(); return t.flags |= 1, typeof i == "object" && i !== null && typeof i.render == "function" && i.$$typeof === void 0 ? (t.tag = 1, t.memoizedState = null, t.updateQueue = null, Lt(r) ? (s = !0, Xa(t)) : s = !1, t.memoizedState = i.state !== null && i.state !== void 0 ? i.state : null, jf(t), i.updater = Rl, t.stateNode = i, i._reactInternals = t, Ic(t, r, e, n), t = Fc(null, t, r, !0, s, n)) : (t.tag = 0, Ge && s && If(t), Pt(null, t, i, n), t = t.child), t; case 16: r = t.elementType; e: { switch (ga(e, t), e = t.pendingProps, i = r._init, r = i(r._payload), t.type = r, i = t.tag = w2(r), e = mn(r, e), i) { case 0: t = Uc(null, t, r, e, n); break e; case 1: t = p0(null, t, r, e, n); break e; case 11: t = d0(null, t, r, e, n); break e; case 14: t = h0(null, t, r, mn(r.type, e), n); break e }throw Error(ue(306, r, "")) } return t; case 0: return r = t.type, i = t.pendingProps, i = t.elementType === r ? i : mn(r, i), Uc(e, t, r, i, n); case 1: return r = t.type, i = t.pendingProps, i = t.elementType === r ? i : mn(r, i), p0(e, t, r, i, n); case 3: e: { if (f1(t), e === null) throw Error(ue(387)); r = t.pendingProps, s = t.memoizedState, i = s.element, jp(e, t), tl(t, r, null, n); var o = t.memoizedState; if (r = o.element, s.isDehydrated) if (s = { element: r, isDehydrated: !1, cache: o.cache, pendingSuspenseBoundaries: o.pendingSuspenseBoundaries, transitions: o.transitions }, t.updateQueue.baseState = s, t.memoizedState = s, t.flags & 256) { i = ls(Error(ue(423)), t), t = m0(e, t, r, n, i); break e } else if (r !== i) { i = ls(Error(ue(424)), t), t = m0(e, t, r, n, i); break e } else for (Zt = Ar(t.stateNode.containerInfo.firstChild), Xt = t, Ge = !0, wn = null, n = Pp(t, null, r, n), t.child = n; n;)n.flags = n.flags & -3 | 4096, n = n.sibling; else { if (ss(), r === i) { t = sr(e, t, n); break e } Pt(e, t, r, n) } t = t.child } return t; case 5: return $p(t), e === null && Ac(t), r = t.type, i = t.pendingProps, s = e !== null ? e.memoizedProps : null, o = i.children, bc(r, i) ? o = null : s !== null && bc(r, s) && (t.flags |= 32), c1(e, t), Pt(e, t, o, n), t.child; case 6: return e === null && Ac(t), null; case 13: return d1(e, t, n); case 4: return $f(t, t.stateNode.containerInfo), r = t.pendingProps, e === null ? t.child = os(t, null, r, n) : Pt(e, t, r, n), t.child; case 11: return r = t.type, i = t.pendingProps, i = t.elementType === r ? i : mn(r, i), d0(e, t, r, i, n); case 7: return Pt(e, t, t.pendingProps, n), t.child; case 8: return Pt(e, t, t.pendingProps.children, n), t.child; case 12: return Pt(e, t, t.pendingProps.children, n), t.child; case 10: e: { if (r = t.type._context, i = t.pendingProps, s = t.memoizedProps, o = i.value, Ve(Ja, r._currentValue), r._currentValue = o, s !== null) if (En(s.value, o)) { if (s.children === i.children && !Gt.current) { t = sr(e, t, n); break e } } else for (s = t.child, s !== null && (s.return = t); s !== null;) { var a = s.dependencies; if (a !== null) { o = s.child; for (var f = a.firstContext; f !== null;) { if (f.context === r) { if (s.tag === 1) { f = tr(-1, n & -n), f.tag = 2; var h = s.updateQueue; if (h !== null) { h = h.shared; var _ = h.pending; _ === null ? f.next = f : (f.next = _.next, _.next = f), h.pending = f } } s.lanes |= n, f = s.alternate, f !== null && (f.lanes |= n), kc(s.return, n, t), a.lanes |= n; break } f = f.next } } else if (s.tag === 10) o = s.type === t.type ? null : s.child; else if (s.tag === 18) { if (o = s.return, o === null) throw Error(ue(341)); o.lanes |= n, a = o.alternate, a !== null && (a.lanes |= n), kc(o, n, t), o = s.sibling } else o = s.child; if (o !== null) o.return = s; else for (o = s; o !== null;) { if (o === t) { o = null; break } if (s = o.sibling, s !== null) { s.return = o.return, o = s; break } o = o.return } s = o } Pt(e, t, i.children, n), t = t.child } return t; case 9: return i = t.type, r = t.pendingProps.children, Di(t, n), i = ln(i), r = r(i), t.flags |= 1, Pt(e, t, r, n), t.child; case 14: return r = t.type, i = mn(r, t.pendingProps), i = mn(r.type, i), h0(e, t, r, i, n); case 15: return l1(e, t, t.type, t.pendingProps, n); case 17: return r = t.type, i = t.pendingProps, i = t.elementType === r ? i : mn(r, i), ga(e, t), t.tag = 1, Lt(r) ? (e = !0, Xa(t)) : e = !1, Di(t, n), s1(t, r, i), Ic(t, r, i, n), Fc(null, t, r, !0, e, n); case 19: return h1(e, t, n); case 22: return u1(e, t, n) }throw Error(ue(156, t.tag)) }; function k1(e, t) { return np(e, t) } function g2(e, t, n, r) { this.tag = e, this.key = n, this.sibling = this.child = this.return = this.stateNode = this.type = this.elementType = null, this.index = 0, this.ref = null, this.pendingProps = t, this.dependencies = this.memoizedState = this.updateQueue = this.memoizedProps = null, this.mode = r, this.subtreeFlags = this.flags = 0, this.deletions = null, this.childLanes = this.lanes = 0, this.alternate = null } function on(e, t, n, r) { return new g2(e, t, n, r) } function ed(e) { return e = e.prototype, !(!e || !e.isReactComponent) } function w2(e) { if (typeof e == "function") return ed(e) ? 1 : 0; if (e != null) { if (e = e.$$typeof, e === xf) return 11; if (e === vf) return 14 } return 2 } function Or(e, t) { var n = e.alternate; return n === null ? (n = on(e.tag, t, e.key, e.mode), n.elementType = e.elementType, n.type = e.type, n.stateNode = e.stateNode, n.alternate = e, e.alternate = n) : (n.pendingProps = t, n.type = e.type, n.flags = 0, n.subtreeFlags = 0, n.deletions = null), n.flags = e.flags & 14680064, n.childLanes = e.childLanes, n.lanes = e.lanes, n.child = e.child, n.memoizedProps = e.memoizedProps, n.memoizedState = e.memoizedState, n.updateQueue = e.updateQueue, t = e.dependencies, n.dependencies = t === null ? null : { lanes: t.lanes, firstContext: t.firstContext }, n.sibling = e.sibling, n.index = e.index, n.ref = e.ref, n } function va(e, t, n, r, i, s) { var o = 2; if (r = e, typeof e == "function") ed(e) && (o = 1); else if (typeof e == "string") o = 5; else e: switch (e) { case Oi: return ri(n.children, i, s, t); case wf: o = 8, i |= 8; break; case tc: return e = on(12, n, t, i | 2), e.elementType = tc, e.lanes = s, e; case nc: return e = on(13, n, t, i), e.elementType = nc, e.lanes = s, e; case rc: return e = on(19, n, t, i), e.elementType = rc, e.lanes = s, e; case $h: return Ul(n, i, s, t); default: if (typeof e == "object" && e !== null) switch (e.$$typeof) { case Mh: o = 10; break e; case jh: o = 9; break e; case xf: o = 11; break e; case vf: o = 14; break e; case gr: o = 16, r = null; break e }throw Error(ue(130, e == null ? e : typeof e, "")) }return t = on(o, n, t, i), t.elementType = e, t.type = r, t.lanes = s, t } function ri(e, t, n, r) { return e = on(7, e, r, t), e.lanes = n, e } function Ul(e, t, n, r) { return e = on(22, e, r, t), e.elementType = $h, e.lanes = n, e.stateNode = { isHidden: !1 }, e } function Ru(e, t, n) { return e = on(6, e, null, t), e.lanes = n, e } function Iu(e, t, n) { return t = on(4, e.children !== null ? e.children : [], e.key, t), t.lanes = n, t.stateNode = { containerInfo: e.containerInfo, pendingChildren: null, implementation: e.implementation }, t } function x2(e, t, n, r, i) { this.tag = t, this.containerInfo = e, this.finishedWork = this.pingCache = this.current = this.pendingChildren = null, this.timeoutHandle = -1, this.callbackNode = this.pendingContext = this.context = null, this.callbackPriority = 0, this.eventTimes = fu(0), this.expirationTimes = fu(-1), this.entangledLanes = this.finishedLanes = this.mutableReadLanes = this.expiredLanes = this.pingedLanes = this.suspendedLanes = this.pendingLanes = 0, this.entanglements = fu(0), this.identifierPrefix = r, this.onRecoverableError = i, this.mutableSourceEagerHydrationData = null } function td(e, t, n, r, i, s, o, a, f) { return e = new x2(e, t, n, a, f), t === 1 ? (t = 1, s === !0 && (t |= 8)) : t = 0, s = on(3, null, null, t), e.current = s, s.stateNode = e, s.memoizedState = { element: r, isDehydrated: n, cache: null, transitions: null, pendingSuspenseBoundaries: null }, jf(s), e } function v2(e, t, n) { var r = 3 < arguments.length && arguments[3] !== void 0 ? arguments[3] : null; return { $$typeof: Ii, key: r == null ? null : "" + r, children: e, containerInfo: t, implementation: n } } function R1(e) { if (!e) return Cr; e = e._reactInternals; e: { if (wi(e) !== e || e.tag !== 1) throw Error(ue(170)); var t = e; do { switch (t.tag) { case 3: t = t.stateNode.context; break e; case 1: if (Lt(t.type)) { t = t.stateNode.__reactInternalMemoizedMergedChildContext; break e } }t = t.return } while (t !== null); throw Error(ue(171)) } if (e.tag === 1) { var n = e.type; if (Lt(n)) return Rp(e, n, t) } return t } function I1(e, t, n, r, i, s, o, a, f) { return e = td(n, r, !0, e, i, s, o, a, f), e.context = R1(null), n = e.current, r = jt(), i = Ir(n), s = tr(r, i), s.callback = t ?? null, kr(n, s, i), e.current.lanes = i, Eo(e, i, r), Wt(e, r), e } function Fl(e, t, n, r) { var i = t.current, s = jt(), o = Ir(i); return n = R1(n), t.context === null ? t.context = n : t.pendingContext = n, t = tr(s, o), t.payload = { element: e }, r = r === void 0 ? null : r, r !== null && (t.callback = r), e = kr(i, t, o), e !== null && (_n(e, i, o, s), pa(e, i, o)), o } function ul(e) { if (e = e.current, !e.child) return null; switch (e.child.tag) { case 5: return e.child.stateNode; default: return e.child.stateNode } } function N0(e, t) { if (e = e.memoizedState, e !== null && e.dehydrated !== null) { var n = e.retryLane; e.retryLane = n !== 0 && n < t ? n : t } } function nd(e, t) { N0(e, t), (e = e.alternate) && N0(e, t) } function _2() { return null } var O1 = typeof reportError == "function" ? reportError : function (e) { console.error(e) }; function rd(e) { this._internalRoot = e } Cl.prototype.render = rd.prototype.render = function (e) { var t = this._internalRoot; if (t === null) throw Error(ue(409)); Fl(e, t, null, null) }; Cl.prototype.unmount = rd.prototype.unmount = function () { var e = this._internalRoot; if (e !== null) { this._internalRoot = null; var t = e.containerInfo; fi(function () { Fl(null, e, null, null) }), t[rr] = null } }; function Cl(e) { this._internalRoot = e } Cl.prototype.unstable_scheduleHydration = function (e) { if (e) { var t = up(); e = { blockedOn: null, target: e, priority: t }; for (var n = 0; n < _r.length && t !== 0 && t < _r[n].priority; n++); _r.splice(n, 0, e), n === 0 && fp(e) } }; function id(e) { return !(!e || e.nodeType !== 1 && e.nodeType !== 9 && e.nodeType !== 11) } function Pl(e) { return !(!e || e.nodeType !== 1 && e.nodeType !== 9 && e.nodeType !== 11 && (e.nodeType !== 8 || e.nodeValue !== " react-mount-point-unstable ")) } function T0() { } function E2(e, t, n, r, i) { if (i) { if (typeof r == "function") { var s = r; r = function () { var h = ul(o); s.call(h) } } var o = I1(t, r, e, 0, null, !1, !1, "", T0); return e._reactRootContainer = o, e[rr] = o.current, io(e.nodeType === 8 ? e.parentNode : e), fi(), o } for (; i = e.lastChild;)e.removeChild(i); if (typeof r == "function") { var a = r; r = function () { var h = ul(f); a.call(h) } } var f = td(e, 0, !1, null, null, !1, !1, "", T0); return e._reactRootContainer = f, e[rr] = f.current, io(e.nodeType === 8 ? e.parentNode : e), fi(function () { Fl(t, f, n, r) }), f } function Ml(e, t, n, r, i) { var s = n._reactRootContainer; if (s) { var o = s; if (typeof i == "function") { var a = i; i = function () { var f = ul(o); a.call(f) } } Fl(t, o, e, i) } else o = E2(n, t, e, i, r); return ul(o) } ap = function (e) { switch (e.tag) { case 3: var t = e.stateNode; if (t.current.memoizedState.isDehydrated) { var n = Os(t.pendingLanes); n !== 0 && (bf(t, n | 1), Wt(t, De()), !(Ie & 6) && (us = De() + 500, jr())) } break; case 13: fi(function () { var r = ir(e, 1); if (r !== null) { var i = jt(); _n(r, e, 1, i) } }), nd(e, 1) } }; Sf = function (e) { if (e.tag === 13) { var t = ir(e, 134217728); if (t !== null) { var n = jt(); _n(t, e, 134217728, n) } nd(e, 134217728) } }; lp = function (e) { if (e.tag === 13) { var t = Ir(e), n = ir(e, t); if (n !== null) { var r = jt(); _n(n, e, t, r) } nd(e, t) } }; up = function () { return Ce }; cp = function (e, t) { var n = Ce; try { return Ce = e, t() } finally { Ce = n } }; hc = function (e, t, n) { switch (t) { case "input": if (oc(e, n), t = n.name, n.type === "radio" && t != null) { for (n = e; n.parentNode;)n = n.parentNode; for (n = n.querySelectorAll("input[name=" + JSON.stringify("" + t) + '][type="radio"]'), t = 0; t < n.length; t++) { var r = n[t]; if (r !== e && r.form === e.form) { var i = Bl(r); if (!i) throw Error(ue(90)); Vh(r), oc(r, i) } } } break; case "textarea": Hh(e, n); break; case "select": t = n.value, t != null && Ki(e, !!n.multiple, t, !1) } }; Xh = Qf; Qh = fi; var b2 = { usingClientEntryPoint: !1, Events: [So, Pi, Bl, Kh, Zh, Qf] }, As = { findFiberByHostInstance: Zr, bundleType: 0, version: "18.3.1", rendererPackageName: "react-dom" }, S2 = { bundleType: As.bundleType, version: As.version, rendererPackageName: As.rendererPackageName, rendererConfig: As.rendererConfig, overrideHookState: null, overrideHookStateDeletePath: null, overrideHookStateRenamePath: null, overrideProps: null, overridePropsDeletePath: null, overridePropsRenamePath: null, setErrorHandler: null, setSuspenseHandler: null, scheduleUpdate: null, currentDispatcherRef: ar.ReactCurrentDispatcher, findHostInstanceByFiber: function (e) { return e = ep(e), e === null ? null : e.stateNode }, findFiberByHostInstance: As.findFiberByHostInstance || _2, findHostInstancesForRefresh: null, scheduleRefresh: null, scheduleRoot: null, setRefreshHandler: null, getCurrentFiber: null, reconcilerVersion: "18.3.1-next-f1338f8080-20240426" }; if (typeof __REACT_DEVTOOLS_GLOBAL_HOOK__ < "u") { var Qo = __REACT_DEVTOOLS_GLOBAL_HOOK__; if (!Qo.isDisabled && Qo.supportsFiber) try { bl = Qo.inject(S2), Mn = Qo } catch { } } Dt.__SECRET_INTERNALS_DO_NOT_USE_OR_YOU_WILL_BE_FIRED = b2; Dt.createPortal = function (e, t) { var n = 2 < arguments.length && arguments[2] !== void 0 ? arguments[2] : null; if (!id(t)) throw Error(ue(200)); return v2(e, t, null, n) }; Dt.createRoot = function (e, t) { if (!id(e)) throw Error(ue(299)); var n = !1, r = "", i = O1; return t != null && (t.unstable_strictMode === !0 && (n = !0), t.identifierPrefix !== void 0 && (r = t.identifierPrefix), t.onRecoverableError !== void 0 && (i = t.onRecoverableError)), t = td(e, 1, !1, null, null, n, !1, r, i), e[rr] = t.current, io(e.nodeType === 8 ? e.parentNode : e), new rd(t) }; Dt.findDOMNode = function (e) { if (e == null) return null; if (e.nodeType === 1) return e; var t = e._reactInternals; if (t === void 0) throw typeof e.render == "function" ? Error(ue(188)) : (e = Object.keys(e).join(","), Error(ue(268, e))); return e = ep(t), e = e === null ? null : e.stateNode, e }; Dt.flushSync = function (e) { return fi(e) }; Dt.hydrate = function (e, t, n) { if (!Pl(t)) throw Error(ue(200)); return Ml(null, e, t, !0, n) }; Dt.hydrateRoot = function (e, t, n) { if (!id(e)) throw Error(ue(405)); var r = n != null && n.hydratedSources || null, i = !1, s = "", o = O1; if (n != null && (n.unstable_strictMode === !0 && (i = !0), n.identifierPrefix !== void 0 && (s = n.identifierPrefix), n.onRecoverableError !== void 0 && (o = n.onRecoverableError)), t = I1(t, null, e, 1, n ?? null, i, !1, s, o), e[rr] = t.current, io(e), r) for (e = 0; e < r.length; e++)n = r[e], i = n._getVersion, i = i(n._source), t.mutableSourceEagerHydrationData == null ? t.mutableSourceEagerHydrationData = [n, i] : t.mutableSourceEagerHydrationData.push(n, i); return new Cl(t) }; Dt.render = function (e, t, n) { if (!Pl(t)) throw Error(ue(200)); return Ml(null, e, t, !1, n) }; Dt.unmountComponentAtNode = function (e) { if (!Pl(e)) throw Error(ue(40)); return e._reactRootContainer ? (fi(function () { Ml(null, null, e, !1, function () { e._reactRootContainer = null, e[rr] = null }) }), !0) : !1 }; Dt.unstable_batchedUpdates = Qf; Dt.unstable_renderSubtreeIntoContainer = function (e, t, n, r) { if (!Pl(n)) throw Error(ue(200)); if (e == null || e._reactInternals === void 0) throw Error(ue(38)); return Ml(e, t, n, !1, r) }; Dt.version = "18.3.1-next-f1338f8080-20240426"; function U1() { if (!(typeof __REACT_DEVTOOLS_GLOBAL_HOOK__ > "u" || typeof __REACT_DEVTOOLS_GLOBAL_HOOK__.checkDCE != "function")) try { __REACT_DEVTOOLS_GLOBAL_HOOK__.checkDCE(U1) } catch (e) { console.error(e) } } U1(), Uh.exports = Dt; var N2 = Uh.exports, B0 = N2; Ju.createRoot = B0.createRoot, Ju.hydrateRoot = B0.hydrateRoot; var F1 = {}, To = {}; To.byteLength = A2; To.toByteArray = R2; To.fromByteArray = U2; var Cn = [], en = [], T2 = typeof Uint8Array < "u" ? Uint8Array : Array, Ou = "ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/"; for (var vi = 0, B2 = Ou.length; vi < B2; ++vi)Cn[vi] = Ou[vi], en[Ou.charCodeAt(vi)] = vi; en[45] = 62; en[95] = 63; function C1(e) { var t = e.length; if (t % 4 > 0) throw new Error("Invalid string. Length must be a multiple of 4"); var n = e.indexOf("="); n === -1 && (n = t); var r = n === t ? 0 : 4 - n % 4; return [n, r] } function A2(e) { var t = C1(e), n = t[0], r = t[1]; return (n + r) * 3 / 4 - r } function k2(e, t, n) { return (t + n) * 3 / 4 - n } function R2(e) { var t, n = C1(e), r = n[0], i = n[1], s = new T2(k2(e, r, i)), o = 0, a = i > 0 ? r - 4 : r, f; for (f = 0; f < a; f += 4)t = en[e.charCodeAt(f)] << 18 | en[e.charCodeAt(f + 1)] << 12 | en[e.charCodeAt(f + 2)] << 6 | en[e.charCodeAt(f + 3)], s[o++] = t >> 16 & 255, s[o++] = t >> 8 & 255, s[o++] = t & 255; return i === 2 && (t = en[e.charCodeAt(f)] << 2 | en[e.charCodeAt(f + 1)] >> 4, s[o++] = t & 255), i === 1 && (t = en[e.charCodeAt(f)] << 10 | en[e.charCodeAt(f + 1)] << 4 | en[e.charCodeAt(f + 2)] >> 2, s[o++] = t >> 8 & 255, s[o++] = t & 255), s } function I2(e) { return Cn[e >> 18 & 63] + Cn[e >> 12 & 63] + Cn[e >> 6 & 63] + Cn[e & 63] } function O2(e, t, n) { for (var r, i = [], s = t; s < n; s += 3)r = (e[s] << 16 & 16711680) + (e[s + 1] << 8 & 65280) + (e[s + 2] & 255), i.push(I2(r)); return i.join("") } function U2(e) { for (var t, n = e.length, r = n % 3, i = [], s = 16383, o = 0, a = n - r; o < a; o += s)i.push(O2(e, o, o + s > a ? a : o + s)); return r === 1 ? (t = e[n - 1], i.push(Cn[t >> 2] + Cn[t << 4 & 63] + "==")) : r === 2 && (t = (e[n - 2] << 8) + e[n - 1], i.push(Cn[t >> 10] + Cn[t >> 4 & 63] + Cn[t << 2 & 63] + "=")), i.join("") } var Bo = {};/*! ieee754. BSD-3-Clause License. Feross Aboukhadijeh <https://feross.org/opensource> */Bo.read = function (e, t, n, r, i) { var s, o, a = i * 8 - r - 1, f = (1 << a) - 1, h = f >> 1, _ = -7, v = n ? i - 1 : 0, y = n ? -1 : 1, w = e[t + v]; for (v += y, s = w & (1 << -_) - 1, w >>= -_, _ += a; _ > 0; s = s * 256 + e[t + v], v += y, _ -= 8); for (o = s & (1 << -_) - 1, s >>= -_, _ += r; _ > 0; o = o * 256 + e[t + v], v += y, _ -= 8); if (s === 0) s = 1 - h; else { if (s === f) return o ? NaN : (w ? -1 : 1) * (1 / 0); o = o + Math.pow(2, r), s = s - h } return (w ? -1 : 1) * o * Math.pow(2, s - r) }; Bo.write = function (e, t, n, r, i, s) { var o, a, f, h = s * 8 - i - 1, _ = (1 << h) - 1, v = _ >> 1, y = i === 23 ? Math.pow(2, -24) - Math.pow(2, -77) : 0, w = r ? 0 : s - 1, p = r ? 1 : -1, O = t < 0 || t === 0 && 1 / t < 0 ? 1 : 0; for (t = Math.abs(t), isNaN(t) || t === 1 / 0 ? (a = isNaN(t) ? 1 : 0, o = _) : (o = Math.floor(Math.log(t) / Math.LN2), t * (f = Math.pow(2, -o)) < 1 && (o--, f *= 2), o + v >= 1 ? t += y / f : t += y * Math.pow(2, 1 - v), t * f >= 2 && (o++, f /= 2), o + v >= _ ? (a = 0, o = _) : o + v >= 1 ? (a = (t * f - 1) * Math.pow(2, i), o = o + v) : (a = t * Math.pow(2, v - 1) * Math.pow(2, i), o = 0)); i >= 8; e[n + w] = a & 255, w += p, a /= 256, i -= 8); for (o = o << i | a, h += i; h > 0; e[n + w] = o & 255, w += p, o /= 256, h -= 8); e[n + w - p] |= O * 128 };/*!
 * The buffer module from node.js, for the browser.
 *
 * @author   Feross Aboukhadijeh <https://feross.org>
 * @license  MIT
 */(function (e) { const t = To, n = Bo, r = typeof Symbol == "function" && typeof Symbol.for == "function" ? Symbol.for("nodejs.util.inspect.custom") : null; e.Buffer = a, e.SlowBuffer = E, e.INSPECT_MAX_BYTES = 50; const i = 2147483647; e.kMaxLength = i, a.TYPED_ARRAY_SUPPORT = s(), !a.TYPED_ARRAY_SUPPORT && typeof console < "u" && typeof console.error == "function" && console.error("This browser lacks typed array (Uint8Array) support which is required by `buffer` v5.x. Use `buffer` v4.x if you require old browser support."); function s() { try { const g = new Uint8Array(1), c = { foo: function () { return 42 } }; return Object.setPrototypeOf(c, Uint8Array.prototype), Object.setPrototypeOf(g, c), g.foo() === 42 } catch { return !1 } } Object.defineProperty(a.prototype, "parent", { enumerable: !0, get: function () { if (a.isBuffer(this)) return this.buffer } }), Object.defineProperty(a.prototype, "offset", { enumerable: !0, get: function () { if (a.isBuffer(this)) return this.byteOffset } }); function o(g) { if (g > i) throw new RangeError('The value "' + g + '" is invalid for option "size"'); const c = new Uint8Array(g); return Object.setPrototypeOf(c, a.prototype), c } function a(g, c, d) { if (typeof g == "number") { if (typeof c == "string") throw new TypeError('The "string" argument must be of type string. Received type number'); return v(g) } return f(g, c, d) } a.poolSize = 8192; function f(g, c, d) { if (typeof g == "string") return y(g, c); if (ArrayBuffer.isView(g)) return p(g); if (g == null) throw new TypeError("The first argument must be one of type string, Buffer, ArrayBuffer, Array, or Array-like Object. Received type " + typeof g); if (Q(g, ArrayBuffer) || g && Q(g.buffer, ArrayBuffer) || typeof SharedArrayBuffer < "u" && (Q(g, SharedArrayBuffer) || g && Q(g.buffer, SharedArrayBuffer))) return O(g, c, d); if (typeof g == "number") throw new TypeError('The "value" argument must not be of type number. Received type number'); const R = g.valueOf && g.valueOf(); if (R != null && R !== g) return a.from(R, c, d); const L = $(g); if (L) return L; if (typeof Symbol < "u" && Symbol.toPrimitive != null && typeof g[Symbol.toPrimitive] == "function") return a.from(g[Symbol.toPrimitive]("string"), c, d); throw new TypeError("The first argument must be one of type string, Buffer, ArrayBuffer, Array, or Array-like Object. Received type " + typeof g) } a.from = function (g, c, d) { return f(g, c, d) }, Object.setPrototypeOf(a.prototype, Uint8Array.prototype), Object.setPrototypeOf(a, Uint8Array); function h(g) { if (typeof g != "number") throw new TypeError('"size" argument must be of type number'); if (g < 0) throw new RangeError('The value "' + g + '" is invalid for option "size"') } function _(g, c, d) { return h(g), g <= 0 ? o(g) : c !== void 0 ? typeof d == "string" ? o(g).fill(c, d) : o(g).fill(c) : o(g) } a.alloc = function (g, c, d) { return _(g, c, d) }; function v(g) { return h(g), o(g < 0 ? 0 : b(g) | 0) } a.allocUnsafe = function (g) { return v(g) }, a.allocUnsafeSlow = function (g) { return v(g) }; function y(g, c) { if ((typeof c != "string" || c === "") && (c = "utf8"), !a.isEncoding(c)) throw new TypeError("Unknown encoding: " + c); const d = S(g, c) | 0; let R = o(d); const L = R.write(g, c); return L !== d && (R = R.slice(0, L)), R } function w(g) { const c = g.length < 0 ? 0 : b(g.length) | 0, d = o(c); for (let R = 0; R < c; R += 1)d[R] = g[R] & 255; return d } function p(g) { if (Q(g, Uint8Array)) { const c = new Uint8Array(g); return O(c.buffer, c.byteOffset, c.byteLength) } return w(g) } function O(g, c, d) { if (c < 0 || g.byteLength < c) throw new RangeError('"offset" is outside of buffer bounds'); if (g.byteLength < c + (d || 0)) throw new RangeError('"length" is outside of buffer bounds'); let R; return c === void 0 && d === void 0 ? R = new Uint8Array(g) : d === void 0 ? R = new Uint8Array(g, c) : R = new Uint8Array(g, c, d), Object.setPrototypeOf(R, a.prototype), R } function $(g) { if (a.isBuffer(g)) { const c = b(g.length) | 0, d = o(c); return d.length === 0 || g.copy(d, 0, 0, c), d } if (g.length !== void 0) return typeof g.length != "number" || le(g.length) ? o(0) : w(g); if (g.type === "Buffer" && Array.isArray(g.data)) return w(g.data) } function b(g) { if (g >= i) throw new RangeError("Attempt to allocate Buffer larger than maximum size: 0x" + i.toString(16) + " bytes"); return g | 0 } function E(g) { return +g != g && (g = 0), a.alloc(+g) } a.isBuffer = function (c) { return c != null && c._isBuffer === !0 && c !== a.prototype }, a.compare = function (c, d) { if (Q(c, Uint8Array) && (c = a.from(c, c.offset, c.byteLength)), Q(d, Uint8Array) && (d = a.from(d, d.offset, d.byteLength)), !a.isBuffer(c) || !a.isBuffer(d)) throw new TypeError('The "buf1", "buf2" arguments must be one of type Buffer or Uint8Array'); if (c === d) return 0; let R = c.length, L = d.length; for (let ne = 0, te = Math.min(R, L); ne < te; ++ne)if (c[ne] !== d[ne]) { R = c[ne], L = d[ne]; break } return R < L ? -1 : L < R ? 1 : 0 }, a.isEncoding = function (c) { switch (String(c).toLowerCase()) { case "hex": case "utf8": case "utf-8": case "ascii": case "latin1": case "binary": case "base64": case "ucs2": case "ucs-2": case "utf16le": case "utf-16le": return !0; default: return !1 } }, a.concat = function (c, d) { if (!Array.isArray(c)) throw new TypeError('"list" argument must be an Array of Buffers'); if (c.length === 0) return a.alloc(0); let R; if (d === void 0) for (d = 0, R = 0; R < c.length; ++R)d += c[R].length; const L = a.allocUnsafe(d); let ne = 0; for (R = 0; R < c.length; ++R) { let te = c[R]; if (Q(te, Uint8Array)) ne + te.length > L.length ? (a.isBuffer(te) || (te = a.from(te)), te.copy(L, ne)) : Uint8Array.prototype.set.call(L, te, ne); else if (a.isBuffer(te)) te.copy(L, ne); else throw new TypeError('"list" argument must be an Array of Buffers'); ne += te.length } return L }; function S(g, c) { if (a.isBuffer(g)) return g.length; if (ArrayBuffer.isView(g) || Q(g, ArrayBuffer)) return g.byteLength; if (typeof g != "string") throw new TypeError('The "string" argument must be one of type string, Buffer, or ArrayBuffer. Received type ' + typeof g); const d = g.length, R = arguments.length > 2 && arguments[2] === !0; if (!R && d === 0) return 0; let L = !1; for (; ;)switch (c) { case "ascii": case "latin1": case "binary": return d; case "utf8": case "utf-8": return l(g).length; case "ucs2": case "ucs-2": case "utf16le": case "utf-16le": return d * 2; case "hex": return d >>> 1; case "base64": return T(g).length; default: if (L) return R ? -1 : l(g).length; c = ("" + c).toLowerCase(), L = !0 } } a.byteLength = S; function M(g, c, d) { let R = !1; if ((c === void 0 || c < 0) && (c = 0), c > this.length || ((d === void 0 || d > this.length) && (d = this.length), d <= 0) || (d >>>= 0, c >>>= 0, d <= c)) return ""; for (g || (g = "utf8"); ;)switch (g) { case "hex": return D(this, c, d); case "utf8": case "utf-8": return F(this, c, d); case "ascii": return ie(this, c, d); case "latin1": case "binary": return z(this, c, d); case "base64": return N(this, c, d); case "ucs2": case "ucs-2": case "utf16le": case "utf-16le": return ae(this, c, d); default: if (R) throw new TypeError("Unknown encoding: " + g); g = (g + "").toLowerCase(), R = !0 } } a.prototype._isBuffer = !0; function k(g, c, d) { const R = g[c]; g[c] = g[d], g[d] = R } a.prototype.swap16 = function () { const c = this.length; if (c % 2 !== 0) throw new RangeError("Buffer size must be a multiple of 16-bits"); for (let d = 0; d < c; d += 2)k(this, d, d + 1); return this }, a.prototype.swap32 = function () { const c = this.length; if (c % 4 !== 0) throw new RangeError("Buffer size must be a multiple of 32-bits"); for (let d = 0; d < c; d += 4)k(this, d, d + 3), k(this, d + 1, d + 2); return this }, a.prototype.swap64 = function () { const c = this.length; if (c % 8 !== 0) throw new RangeError("Buffer size must be a multiple of 64-bits"); for (let d = 0; d < c; d += 8)k(this, d, d + 7), k(this, d + 1, d + 6), k(this, d + 2, d + 5), k(this, d + 3, d + 4); return this }, a.prototype.toString = function () { const c = this.length; return c === 0 ? "" : arguments.length === 0 ? F(this, 0, c) : M.apply(this, arguments) }, a.prototype.toLocaleString = a.prototype.toString, a.prototype.equals = function (c) { if (!a.isBuffer(c)) throw new TypeError("Argument must be a Buffer"); return this === c ? !0 : a.compare(this, c) === 0 }, a.prototype.inspect = function () { let c = ""; const d = e.INSPECT_MAX_BYTES; return c = this.toString("hex", 0, d).replace(/(.{2})/g, "$1 ").trim(), this.length > d && (c += " ... "), "<Buffer " + c + ">" }, r && (a.prototype[r] = a.prototype.inspect), a.prototype.compare = function (c, d, R, L, ne) { if (Q(c, Uint8Array) && (c = a.from(c, c.offset, c.byteLength)), !a.isBuffer(c)) throw new TypeError('The "target" argument must be one of type Buffer or Uint8Array. Received type ' + typeof c); if (d === void 0 && (d = 0), R === void 0 && (R = c ? c.length : 0), L === void 0 && (L = 0), ne === void 0 && (ne = this.length), d < 0 || R > c.length || L < 0 || ne > this.length) throw new RangeError("out of range index"); if (L >= ne && d >= R) return 0; if (L >= ne) return -1; if (d >= R) return 1; if (d >>>= 0, R >>>= 0, L >>>= 0, ne >>>= 0, this === c) return 0; let te = ne - L, xe = R - d; const be = Math.min(te, xe), ve = this.slice(L, ne), we = c.slice(d, R); for (let Oe = 0; Oe < be; ++Oe)if (ve[Oe] !== we[Oe]) { te = ve[Oe], xe = we[Oe]; break } return te < xe ? -1 : xe < te ? 1 : 0 }; function C(g, c, d, R, L) { if (g.length === 0) return -1; if (typeof d == "string" ? (R = d, d = 0) : d > 2147483647 ? d = 2147483647 : d < -2147483648 && (d = -2147483648), d = +d, le(d) && (d = L ? 0 : g.length - 1), d < 0 && (d = g.length + d), d >= g.length) { if (L) return -1; d = g.length - 1 } else if (d < 0) if (L) d = 0; else return -1; if (typeof c == "string" && (c = a.from(c, R)), a.isBuffer(c)) return c.length === 0 ? -1 : V(g, c, d, R, L); if (typeof c == "number") return c = c & 255, typeof Uint8Array.prototype.indexOf == "function" ? L ? Uint8Array.prototype.indexOf.call(g, c, d) : Uint8Array.prototype.lastIndexOf.call(g, c, d) : V(g, [c], d, R, L); throw new TypeError("val must be string, number or Buffer") } function V(g, c, d, R, L) { let ne = 1, te = g.length, xe = c.length; if (R !== void 0 && (R = String(R).toLowerCase(), R === "ucs2" || R === "ucs-2" || R === "utf16le" || R === "utf-16le")) { if (g.length < 2 || c.length < 2) return -1; ne = 2, te /= 2, xe /= 2, d /= 2 } function be(we, Oe) { return ne === 1 ? we[Oe] : we.readUInt16BE(Oe * ne) } let ve; if (L) { let we = -1; for (ve = d; ve < te; ve++)if (be(g, ve) === be(c, we === -1 ? 0 : ve - we)) { if (we === -1 && (we = ve), ve - we + 1 === xe) return we * ne } else we !== -1 && (ve -= ve - we), we = -1 } else for (d + xe > te && (d = te - xe), ve = d; ve >= 0; ve--) { let we = !0; for (let Oe = 0; Oe < xe; Oe++)if (be(g, ve + Oe) !== be(c, Oe)) { we = !1; break } if (we) return ve } return -1 } a.prototype.includes = function (c, d, R) { return this.indexOf(c, d, R) !== -1 }, a.prototype.indexOf = function (c, d, R) { return C(this, c, d, R, !0) }, a.prototype.lastIndexOf = function (c, d, R) { return C(this, c, d, R, !1) }; function Y(g, c, d, R) { d = Number(d) || 0; const L = g.length - d; R ? (R = Number(R), R > L && (R = L)) : R = L; const ne = c.length; R > ne / 2 && (R = ne / 2); let te; for (te = 0; te < R; ++te) { const xe = parseInt(c.substr(te * 2, 2), 16); if (le(xe)) return te; g[d + te] = xe } return te } function re(g, c, d, R) { return P(l(c, g.length - d), g, d, R) } function U(g, c, d, R) { return P(u(c), g, d, R) } function K(g, c, d, R) { return P(T(c), g, d, R) } function ee(g, c, d, R) { return P(x(c, g.length - d), g, d, R) } a.prototype.write = function (c, d, R, L) { if (d === void 0) L = "utf8", R = this.length, d = 0; else if (R === void 0 && typeof d == "string") L = d, R = this.length, d = 0; else if (isFinite(d)) d = d >>> 0, isFinite(R) ? (R = R >>> 0, L === void 0 && (L = "utf8")) : (L = R, R = void 0); else throw new Error("Buffer.write(string, encoding, offset[, length]) is no longer supported"); const ne = this.length - d; if ((R === void 0 || R > ne) && (R = ne), c.length > 0 && (R < 0 || d < 0) || d > this.length) throw new RangeError("Attempt to write outside buffer bounds"); L || (L = "utf8"); let te = !1; for (; ;)switch (L) { case "hex": return Y(this, c, d, R); case "utf8": case "utf-8": return re(this, c, d, R); case "ascii": case "latin1": case "binary": return U(this, c, d, R); case "base64": return K(this, c, d, R); case "ucs2": case "ucs-2": case "utf16le": case "utf-16le": return ee(this, c, d, R); default: if (te) throw new TypeError("Unknown encoding: " + L); L = ("" + L).toLowerCase(), te = !0 } }, a.prototype.toJSON = function () { return { type: "Buffer", data: Array.prototype.slice.call(this._arr || this, 0) } }; function N(g, c, d) { return c === 0 && d === g.length ? t.fromByteArray(g) : t.fromByteArray(g.slice(c, d)) } function F(g, c, d) { d = Math.min(g.length, d); const R = []; let L = c; for (; L < d;) { const ne = g[L]; let te = null, xe = ne > 239 ? 4 : ne > 223 ? 3 : ne > 191 ? 2 : 1; if (L + xe <= d) { let be, ve, we, Oe; switch (xe) { case 1: ne < 128 && (te = ne); break; case 2: be = g[L + 1], (be & 192) === 128 && (Oe = (ne & 31) << 6 | be & 63, Oe > 127 && (te = Oe)); break; case 3: be = g[L + 1], ve = g[L + 2], (be & 192) === 128 && (ve & 192) === 128 && (Oe = (ne & 15) << 12 | (be & 63) << 6 | ve & 63, Oe > 2047 && (Oe < 55296 || Oe > 57343) && (te = Oe)); break; case 4: be = g[L + 1], ve = g[L + 2], we = g[L + 3], (be & 192) === 128 && (ve & 192) === 128 && (we & 192) === 128 && (Oe = (ne & 15) << 18 | (be & 63) << 12 | (ve & 63) << 6 | we & 63, Oe > 65535 && Oe < 1114112 && (te = Oe)) } } te === null ? (te = 65533, xe = 1) : te > 65535 && (te -= 65536, R.push(te >>> 10 & 1023 | 55296), te = 56320 | te & 1023), R.push(te), L += xe } return J(R) } const G = 4096; function J(g) { const c = g.length; if (c <= G) return String.fromCharCode.apply(String, g); let d = "", R = 0; for (; R < c;)d += String.fromCharCode.apply(String, g.slice(R, R += G)); return d } function ie(g, c, d) { let R = ""; d = Math.min(g.length, d); for (let L = c; L < d; ++L)R += String.fromCharCode(g[L] & 127); return R } function z(g, c, d) { let R = ""; d = Math.min(g.length, d); for (let L = c; L < d; ++L)R += String.fromCharCode(g[L]); return R } function D(g, c, d) { const R = g.length; (!c || c < 0) && (c = 0), (!d || d < 0 || d > R) && (d = R); let L = ""; for (let ne = c; ne < d; ++ne)L += de[g[ne]]; return L } function ae(g, c, d) { const R = g.slice(c, d); let L = ""; for (let ne = 0; ne < R.length - 1; ne += 2)L += String.fromCharCode(R[ne] + R[ne + 1] * 256); return L } a.prototype.slice = function (c, d) { const R = this.length; c = ~~c, d = d === void 0 ? R : ~~d, c < 0 ? (c += R, c < 0 && (c = 0)) : c > R && (c = R), d < 0 ? (d += R, d < 0 && (d = 0)) : d > R && (d = R), d < c && (d = c); const L = this.subarray(c, d); return Object.setPrototypeOf(L, a.prototype), L }; function se(g, c, d) { if (g % 1 !== 0 || g < 0) throw new RangeError("offset is not uint"); if (g + c > d) throw new RangeError("Trying to access beyond buffer length") } a.prototype.readUintLE = a.prototype.readUIntLE = function (c, d, R) { c = c >>> 0, d = d >>> 0, R || se(c, d, this.length); let L = this[c], ne = 1, te = 0; for (; ++te < d && (ne *= 256);)L += this[c + te] * ne; return L }, a.prototype.readUintBE = a.prototype.readUIntBE = function (c, d, R) { c = c >>> 0, d = d >>> 0, R || se(c, d, this.length); let L = this[c + --d], ne = 1; for (; d > 0 && (ne *= 256);)L += this[c + --d] * ne; return L }, a.prototype.readUint8 = a.prototype.readUInt8 = function (c, d) { return c = c >>> 0, d || se(c, 1, this.length), this[c] }, a.prototype.readUint16LE = a.prototype.readUInt16LE = function (c, d) { return c = c >>> 0, d || se(c, 2, this.length), this[c] | this[c + 1] << 8 }, a.prototype.readUint16BE = a.prototype.readUInt16BE = function (c, d) { return c = c >>> 0, d || se(c, 2, this.length), this[c] << 8 | this[c + 1] }, a.prototype.readUint32LE = a.prototype.readUInt32LE = function (c, d) { return c = c >>> 0, d || se(c, 4, this.length), (this[c] | this[c + 1] << 8 | this[c + 2] << 16) + this[c + 3] * 16777216 }, a.prototype.readUint32BE = a.prototype.readUInt32BE = function (c, d) { return c = c >>> 0, d || se(c, 4, this.length), this[c] * 16777216 + (this[c + 1] << 16 | this[c + 2] << 8 | this[c + 3]) }, a.prototype.readBigUInt64LE = pe(function (c) { c = c >>> 0, Z(c, "offset"); const d = this[c], R = this[c + 7]; (d === void 0 || R === void 0) && W(c, this.length - 8); const L = d + this[++c] * 2 ** 8 + this[++c] * 2 ** 16 + this[++c] * 2 ** 24, ne = this[++c] + this[++c] * 2 ** 8 + this[++c] * 2 ** 16 + R * 2 ** 24; return BigInt(L) + (BigInt(ne) << BigInt(32)) }), a.prototype.readBigUInt64BE = pe(function (c) { c = c >>> 0, Z(c, "offset"); const d = this[c], R = this[c + 7]; (d === void 0 || R === void 0) && W(c, this.length - 8); const L = d * 2 ** 24 + this[++c] * 2 ** 16 + this[++c] * 2 ** 8 + this[++c], ne = this[++c] * 2 ** 24 + this[++c] * 2 ** 16 + this[++c] * 2 ** 8 + R; return (BigInt(L) << BigInt(32)) + BigInt(ne) }), a.prototype.readIntLE = function (c, d, R) { c = c >>> 0, d = d >>> 0, R || se(c, d, this.length); let L = this[c], ne = 1, te = 0; for (; ++te < d && (ne *= 256);)L += this[c + te] * ne; return ne *= 128, L >= ne && (L -= Math.pow(2, 8 * d)), L }, a.prototype.readIntBE = function (c, d, R) { c = c >>> 0, d = d >>> 0, R || se(c, d, this.length); let L = d, ne = 1, te = this[c + --L]; for (; L > 0 && (ne *= 256);)te += this[c + --L] * ne; return ne *= 128, te >= ne && (te -= Math.pow(2, 8 * d)), te }, a.prototype.readInt8 = function (c, d) { return c = c >>> 0, d || se(c, 1, this.length), this[c] & 128 ? (255 - this[c] + 1) * -1 : this[c] }, a.prototype.readInt16LE = function (c, d) { c = c >>> 0, d || se(c, 2, this.length); const R = this[c] | this[c + 1] << 8; return R & 32768 ? R | 4294901760 : R }, a.prototype.readInt16BE = function (c, d) { c = c >>> 0, d || se(c, 2, this.length); const R = this[c + 1] | this[c] << 8; return R & 32768 ? R | 4294901760 : R }, a.prototype.readInt32LE = function (c, d) { return c = c >>> 0, d || se(c, 4, this.length), this[c] | this[c + 1] << 8 | this[c + 2] << 16 | this[c + 3] << 24 }, a.prototype.readInt32BE = function (c, d) { return c = c >>> 0, d || se(c, 4, this.length), this[c] << 24 | this[c + 1] << 16 | this[c + 2] << 8 | this[c + 3] }, a.prototype.readBigInt64LE = pe(function (c) { c = c >>> 0, Z(c, "offset"); const d = this[c], R = this[c + 7]; (d === void 0 || R === void 0) && W(c, this.length - 8); const L = this[c + 4] + this[c + 5] * 2 ** 8 + this[c + 6] * 2 ** 16 + (R << 24); return (BigInt(L) << BigInt(32)) + BigInt(d + this[++c] * 2 ** 8 + this[++c] * 2 ** 16 + this[++c] * 2 ** 24) }), a.prototype.readBigInt64BE = pe(function (c) { c = c >>> 0, Z(c, "offset"); const d = this[c], R = this[c + 7]; (d === void 0 || R === void 0) && W(c, this.length - 8); const L = (d << 24) + this[++c] * 2 ** 16 + this[++c] * 2 ** 8 + this[++c]; return (BigInt(L) << BigInt(32)) + BigInt(this[++c] * 2 ** 24 + this[++c] * 2 ** 16 + this[++c] * 2 ** 8 + R) }), a.prototype.readFloatLE = function (c, d) { return c = c >>> 0, d || se(c, 4, this.length), n.read(this, c, !0, 23, 4) }, a.prototype.readFloatBE = function (c, d) { return c = c >>> 0, d || se(c, 4, this.length), n.read(this, c, !1, 23, 4) }, a.prototype.readDoubleLE = function (c, d) { return c = c >>> 0, d || se(c, 8, this.length), n.read(this, c, !0, 52, 8) }, a.prototype.readDoubleBE = function (c, d) { return c = c >>> 0, d || se(c, 8, this.length), n.read(this, c, !1, 52, 8) }; function oe(g, c, d, R, L, ne) { if (!a.isBuffer(g)) throw new TypeError('"buffer" argument must be a Buffer instance'); if (c > L || c < ne) throw new RangeError('"value" argument is out of bounds'); if (d + R > g.length) throw new RangeError("Index out of range") } a.prototype.writeUintLE = a.prototype.writeUIntLE = function (c, d, R, L) { if (c = +c, d = d >>> 0, R = R >>> 0, !L) { const xe = Math.pow(2, 8 * R) - 1; oe(this, c, d, R, xe, 0) } let ne = 1, te = 0; for (this[d] = c & 255; ++te < R && (ne *= 256);)this[d + te] = c / ne & 255; return d + R }, a.prototype.writeUintBE = a.prototype.writeUIntBE = function (c, d, R, L) { if (c = +c, d = d >>> 0, R = R >>> 0, !L) { const xe = Math.pow(2, 8 * R) - 1; oe(this, c, d, R, xe, 0) } let ne = R - 1, te = 1; for (this[d + ne] = c & 255; --ne >= 0 && (te *= 256);)this[d + ne] = c / te & 255; return d + R }, a.prototype.writeUint8 = a.prototype.writeUInt8 = function (c, d, R) { return c = +c, d = d >>> 0, R || oe(this, c, d, 1, 255, 0), this[d] = c & 255, d + 1 }, a.prototype.writeUint16LE = a.prototype.writeUInt16LE = function (c, d, R) { return c = +c, d = d >>> 0, R || oe(this, c, d, 2, 65535, 0), this[d] = c & 255, this[d + 1] = c >>> 8, d + 2 }, a.prototype.writeUint16BE = a.prototype.writeUInt16BE = function (c, d, R) { return c = +c, d = d >>> 0, R || oe(this, c, d, 2, 65535, 0), this[d] = c >>> 8, this[d + 1] = c & 255, d + 2 }, a.prototype.writeUint32LE = a.prototype.writeUInt32LE = function (c, d, R) { return c = +c, d = d >>> 0, R || oe(this, c, d, 4, 4294967295, 0), this[d + 3] = c >>> 24, this[d + 2] = c >>> 16, this[d + 1] = c >>> 8, this[d] = c & 255, d + 4 }, a.prototype.writeUint32BE = a.prototype.writeUInt32BE = function (c, d, R) { return c = +c, d = d >>> 0, R || oe(this, c, d, 4, 4294967295, 0), this[d] = c >>> 24, this[d + 1] = c >>> 16, this[d + 2] = c >>> 8, this[d + 3] = c & 255, d + 4 }; function Ae(g, c, d, R, L) { j(c, R, L, g, d, 7); let ne = Number(c & BigInt(4294967295)); g[d++] = ne, ne = ne >> 8, g[d++] = ne, ne = ne >> 8, g[d++] = ne, ne = ne >> 8, g[d++] = ne; let te = Number(c >> BigInt(32) & BigInt(4294967295)); return g[d++] = te, te = te >> 8, g[d++] = te, te = te >> 8, g[d++] = te, te = te >> 8, g[d++] = te, d } function B(g, c, d, R, L) { j(c, R, L, g, d, 7); let ne = Number(c & BigInt(4294967295)); g[d + 7] = ne, ne = ne >> 8, g[d + 6] = ne, ne = ne >> 8, g[d + 5] = ne, ne = ne >> 8, g[d + 4] = ne; let te = Number(c >> BigInt(32) & BigInt(4294967295)); return g[d + 3] = te, te = te >> 8, g[d + 2] = te, te = te >> 8, g[d + 1] = te, te = te >> 8, g[d] = te, d + 8 } a.prototype.writeBigUInt64LE = pe(function (c, d = 0) { return Ae(this, c, d, BigInt(0), BigInt("0xffffffffffffffff")) }), a.prototype.writeBigUInt64BE = pe(function (c, d = 0) { return B(this, c, d, BigInt(0), BigInt("0xffffffffffffffff")) }), a.prototype.writeIntLE = function (c, d, R, L) { if (c = +c, d = d >>> 0, !L) { const be = Math.pow(2, 8 * R - 1); oe(this, c, d, R, be - 1, -be) } let ne = 0, te = 1, xe = 0; for (this[d] = c & 255; ++ne < R && (te *= 256);)c < 0 && xe === 0 && this[d + ne - 1] !== 0 && (xe = 1), this[d + ne] = (c / te >> 0) - xe & 255; return d + R }, a.prototype.writeIntBE = function (c, d, R, L) { if (c = +c, d = d >>> 0, !L) { const be = Math.pow(2, 8 * R - 1); oe(this, c, d, R, be - 1, -be) } let ne = R - 1, te = 1, xe = 0; for (this[d + ne] = c & 255; --ne >= 0 && (te *= 256);)c < 0 && xe === 0 && this[d + ne + 1] !== 0 && (xe = 1), this[d + ne] = (c / te >> 0) - xe & 255; return d + R }, a.prototype.writeInt8 = function (c, d, R) { return c = +c, d = d >>> 0, R || oe(this, c, d, 1, 127, -128), c < 0 && (c = 255 + c + 1), this[d] = c & 255, d + 1 }, a.prototype.writeInt16LE = function (c, d, R) { return c = +c, d = d >>> 0, R || oe(this, c, d, 2, 32767, -32768), this[d] = c & 255, this[d + 1] = c >>> 8, d + 2 }, a.prototype.writeInt16BE = function (c, d, R) { return c = +c, d = d >>> 0, R || oe(this, c, d, 2, 32767, -32768), this[d] = c >>> 8, this[d + 1] = c & 255, d + 2 }, a.prototype.writeInt32LE = function (c, d, R) { return c = +c, d = d >>> 0, R || oe(this, c, d, 4, 2147483647, -2147483648), this[d] = c & 255, this[d + 1] = c >>> 8, this[d + 2] = c >>> 16, this[d + 3] = c >>> 24, d + 4 }, a.prototype.writeInt32BE = function (c, d, R) { return c = +c, d = d >>> 0, R || oe(this, c, d, 4, 2147483647, -2147483648), c < 0 && (c = 4294967295 + c + 1), this[d] = c >>> 24, this[d + 1] = c >>> 16, this[d + 2] = c >>> 8, this[d + 3] = c & 255, d + 4 }, a.prototype.writeBigInt64LE = pe(function (c, d = 0) { return Ae(this, c, d, -BigInt("0x8000000000000000"), BigInt("0x7fffffffffffffff")) }), a.prototype.writeBigInt64BE = pe(function (c, d = 0) { return B(this, c, d, -BigInt("0x8000000000000000"), BigInt("0x7fffffffffffffff")) }); function Pe(g, c, d, R, L, ne) { if (d + R > g.length) throw new RangeError("Index out of range"); if (d < 0) throw new RangeError("Index out of range") } function Ee(g, c, d, R, L) { return c = +c, d = d >>> 0, L || Pe(g, c, d, 4), n.write(g, c, d, R, 23, 4), d + 4 } a.prototype.writeFloatLE = function (c, d, R) { return Ee(this, c, d, !0, R) }, a.prototype.writeFloatBE = function (c, d, R) { return Ee(this, c, d, !1, R) }; function Ue(g, c, d, R, L) { return c = +c, d = d >>> 0, L || Pe(g, c, d, 8), n.write(g, c, d, R, 52, 8), d + 8 } a.prototype.writeDoubleLE = function (c, d, R) { return Ue(this, c, d, !0, R) }, a.prototype.writeDoubleBE = function (c, d, R) { return Ue(this, c, d, !1, R) }, a.prototype.copy = function (c, d, R, L) { if (!a.isBuffer(c)) throw new TypeError("argument should be a Buffer"); if (R || (R = 0), !L && L !== 0 && (L = this.length), d >= c.length && (d = c.length), d || (d = 0), L > 0 && L < R && (L = R), L === R || c.length === 0 || this.length === 0) return 0; if (d < 0) throw new RangeError("targetStart out of bounds"); if (R < 0 || R >= this.length) throw new RangeError("Index out of range"); if (L < 0) throw new RangeError("sourceEnd out of bounds"); L > this.length && (L = this.length), c.length - d < L - R && (L = c.length - d + R); const ne = L - R; return this === c && typeof Uint8Array.prototype.copyWithin == "function" ? this.copyWithin(d, R, L) : Uint8Array.prototype.set.call(c, this.subarray(R, L), d), ne }, a.prototype.fill = function (c, d, R, L) { if (typeof c == "string") { if (typeof d == "string" ? (L = d, d = 0, R = this.length) : typeof R == "string" && (L = R, R = this.length), L !== void 0 && typeof L != "string") throw new TypeError("encoding must be a string"); if (typeof L == "string" && !a.isEncoding(L)) throw new TypeError("Unknown encoding: " + L); if (c.length === 1) { const te = c.charCodeAt(0); (L === "utf8" && te < 128 || L === "latin1") && (c = te) } } else typeof c == "number" ? c = c & 255 : typeof c == "boolean" && (c = Number(c)); if (d < 0 || this.length < d || this.length < R) throw new RangeError("Out of range index"); if (R <= d) return this; d = d >>> 0, R = R === void 0 ? this.length : R >>> 0, c || (c = 0); let ne; if (typeof c == "number") for (ne = d; ne < R; ++ne)this[ne] = c; else { const te = a.isBuffer(c) ? c : a.from(c, L), xe = te.length; if (xe === 0) throw new TypeError('The value "' + c + '" is invalid for argument "value"'); for (ne = 0; ne < R - d; ++ne)this[ne + d] = te[ne % xe] } return this }; const fe = {}; function ye(g, c, d) { fe[g] = class extends d { constructor() { super(), Object.defineProperty(this, "message", { value: c.apply(this, arguments), writable: !0, configurable: !0 }), this.name = `${this.name} [${g}]`, this.stack, delete this.name } get code() { return g } set code(L) { Object.defineProperty(this, "code", { configurable: !0, enumerable: !0, value: L, writable: !0 }) } toString() { return `${this.name} [${g}]: ${this.message}` } } } ye("ERR_BUFFER_OUT_OF_BOUNDS", function (g) { return g ? `${g} is outside of buffer bounds` : "Attempt to access memory outside buffer bounds" }, RangeError), ye("ERR_INVALID_ARG_TYPE", function (g, c) { return `The "${g}" argument must be of type number. Received type ${typeof c}` }, TypeError), ye("ERR_OUT_OF_RANGE", function (g, c, d) { let R = `The value of "${g}" is out of range.`, L = d; return Number.isInteger(d) && Math.abs(d) > 2 ** 32 ? L = A(String(d)) : typeof d == "bigint" && (L = String(d), (d > BigInt(2) ** BigInt(32) || d < -(BigInt(2) ** BigInt(32))) && (L = A(L)), L += "n"), R += ` It must be ${c}. Received ${L}`, R }, RangeError); function A(g) { let c = "", d = g.length; const R = g[0] === "-" ? 1 : 0; for (; d >= R + 4; d -= 3)c = `_${g.slice(d - 3, d)}${c}`; return `${g.slice(0, d)}${c}` } function I(g, c, d) { Z(c, "offset"), (g[c] === void 0 || g[c + d] === void 0) && W(c, g.length - (d + 1)) } function j(g, c, d, R, L, ne) { if (g > d || g < c) { const te = typeof c == "bigint" ? "n" : ""; let xe; throw c === 0 || c === BigInt(0) ? xe = `>= 0${te} and < 2${te} ** ${(ne + 1) * 8}${te}` : xe = `>= -(2${te} ** ${(ne + 1) * 8 - 1}${te}) and < 2 ** ${(ne + 1) * 8 - 1}${te}`, new fe.ERR_OUT_OF_RANGE("value", xe, g) } I(R, L, ne) } function Z(g, c) { if (typeof g != "number") throw new fe.ERR_INVALID_ARG_TYPE(c, "number", g) } function W(g, c, d) { throw Math.floor(g) !== g ? (Z(g, d), new fe.ERR_OUT_OF_RANGE("offset", "an integer", g)) : c < 0 ? new fe.ERR_BUFFER_OUT_OF_BOUNDS : new fe.ERR_OUT_OF_RANGE("offset", `>= 0 and <= ${c}`, g) } const X = /[^+/0-9A-Za-z-_]/g; function m(g) { if (g = g.split("=")[0], g = g.trim().replace(X, ""), g.length < 2) return ""; for (; g.length % 4 !== 0;)g = g + "="; return g } function l(g, c) { c = c || 1 / 0; let d; const R = g.length; let L = null; const ne = []; for (let te = 0; te < R; ++te) { if (d = g.charCodeAt(te), d > 55295 && d < 57344) { if (!L) { if (d > 56319) { (c -= 3) > -1 && ne.push(239, 191, 189); continue } else if (te + 1 === R) { (c -= 3) > -1 && ne.push(239, 191, 189); continue } L = d; continue } if (d < 56320) { (c -= 3) > -1 && ne.push(239, 191, 189), L = d; continue } d = (L - 55296 << 10 | d - 56320) + 65536 } else L && (c -= 3) > -1 && ne.push(239, 191, 189); if (L = null, d < 128) { if ((c -= 1) < 0) break; ne.push(d) } else if (d < 2048) { if ((c -= 2) < 0) break; ne.push(d >> 6 | 192, d & 63 | 128) } else if (d < 65536) { if ((c -= 3) < 0) break; ne.push(d >> 12 | 224, d >> 6 & 63 | 128, d & 63 | 128) } else if (d < 1114112) { if ((c -= 4) < 0) break; ne.push(d >> 18 | 240, d >> 12 & 63 | 128, d >> 6 & 63 | 128, d & 63 | 128) } else throw new Error("Invalid code point") } return ne } function u(g) { const c = []; for (let d = 0; d < g.length; ++d)c.push(g.charCodeAt(d) & 255); return c } function x(g, c) { let d, R, L; const ne = []; for (let te = 0; te < g.length && !((c -= 2) < 0); ++te)d = g.charCodeAt(te), R = d >> 8, L = d % 256, ne.push(L), ne.push(R); return ne } function T(g) { return t.toByteArray(m(g)) } function P(g, c, d, R) { let L; for (L = 0; L < R && !(L + d >= c.length || L >= g.length); ++L)c[L + d] = g[L]; return L } function Q(g, c) { return g instanceof c || g != null && g.constructor != null && g.constructor.name != null && g.constructor.name === c.name } function le(g) { return g !== g } const de = function () { const g = "0123456789abcdef", c = new Array(256); for (let d = 0; d < 16; ++d) { const R = d * 16; for (let L = 0; L < 16; ++L)c[R + L] = g[d] + g[L] } return c }(); function pe(g) { return typeof BigInt > "u" ? _e : g } function _e() { throw new Error("BigInt not supported") } })(F1); var Wc; (function (e) { e[e.SysFatal = 1] = "SysFatal", e[e.SysTransient = 2] = "SysTransient", e[e.DestinationInvalid = 3] = "DestinationInvalid", e[e.CanisterReject = 4] = "CanisterReject", e[e.CanisterError = 5] = "CanisterError" })(Wc || (Wc = {})); const F2 = "modulepreload", C2 = function (e, t) { return new URL(e, t).href }, A0 = {}, P2 = function (t, n, r) { let i = Promise.resolve(); if (n && n.length > 0) { const o = document.getElementsByTagName("link"), a = document.querySelector("meta[property=csp-nonce]"), f = (a == null ? void 0 : a.nonce) || (a == null ? void 0 : a.getAttribute("nonce")); i = Promise.allSettled(n.map(h => { if (h = C2(h, r), h in A0) return; A0[h] = !0; const _ = h.endsWith(".css"), v = _ ? '[rel="stylesheet"]' : ""; if (!!r) for (let p = o.length - 1; p >= 0; p--) { const O = o[p]; if (O.href === h && (!_ || O.rel === "stylesheet")) return } else if (document.querySelector(`link[href="${h}"]${v}`)) return; const w = document.createElement("link"); if (w.rel = _ ? "stylesheet" : F2, _ || (w.as = "script"), w.crossOrigin = "", w.href = h, f && w.setAttribute("nonce", f), document.head.appendChild(w), _) return new Promise((p, O) => { w.addEventListener("load", p), w.addEventListener("error", () => O(new Error(`Unable to preload CSS for ${h}`))) }) })) } function s(o) { const a = new Event("vite:preloadError", { cancelable: !0 }); if (a.payload = o, window.dispatchEvent(a), !a.defaultPrevented) throw o } return i.then(o => { for (const a of o || []) a.status === "rejected" && s(a.reason); return t().catch(s) }) }, cl = "abcdefghijklmnopqrstuvwxyz234567", cs = Object.create(null); for (let e = 0; e < cl.length; e++)cs[cl[e]] = e; cs[0] = cs.o; cs[1] = cs.i; function M2(e) { let t = 0, n = 0, r = ""; function i(s) { return t < 0 ? n |= s >> -t : n = s << t & 248, t > 3 ? (t -= 8, 1) : (t < 4 && (r += cl[n >> 3], t += 5), 0) } for (let s = 0; s < e.length;)s += i(e[s]); return r + (t < 0 ? cl[n >> 3] : "") } function j2(e) { let t = 0, n = 0; const r = new Uint8Array(e.length * 4 / 3 | 0); let i = 0; function s(o) { let a = cs[o.toLowerCase()]; if (a === void 0) throw new Error(`Invalid character: ${JSON.stringify(o)}`); a <<= 3, n |= a >>> t, t += 5, t >= 8 && (r[i++] = n, t -= 8, t > 0 ? n = a << 5 - t & 255 : n = 0) } for (const o of e) s(o); return r.slice(0, i) } const $2 = new Uint32Array([0, 1996959894, 3993919788, 2567524794, 124634137, 1886057615, 3915621685, 2657392035, 249268274, 2044508324, 3772115230, 2547177864, 162941995, 2125561021, 3887607047, 2428444049, 498536548, 1789927666, 4089016648, 2227061214, 450548861, 1843258603, 4107580753, 2211677639, 325883990, 1684777152, 4251122042, 2321926636, 335633487, 1661365465, 4195302755, 2366115317, 997073096, 1281953886, 3579855332, 2724688242, 1006888145, 1258607687, 3524101629, 2768942443, 901097722, 1119000684, 3686517206, 2898065728, 853044451, 1172266101, 3705015759, 2882616665, 651767980, 1373503546, 3369554304, 3218104598, 565507253, 1454621731, 3485111705, 3099436303, 671266974, 1594198024, 3322730930, 2970347812, 795835527, 1483230225, 3244367275, 3060149565, 1994146192, 31158534, 2563907772, 4023717930, 1907459465, 112637215, 2680153253, 3904427059, 2013776290, 251722036, 2517215374, 3775830040, 2137656763, 141376813, 2439277719, 3865271297, 1802195444, 476864866, 2238001368, 4066508878, 1812370925, 453092731, 2181625025, 4111451223, 1706088902, 314042704, 2344532202, 4240017532, 1658658271, 366619977, 2362670323, 4224994405, 1303535960, 984961486, 2747007092, 3569037538, 1256170817, 1037604311, 2765210733, 3554079995, 1131014506, 879679996, 2909243462, 3663771856, 1141124467, 855842277, 2852801631, 3708648649, 1342533948, 654459306, 3188396048, 3373015174, 1466479909, 544179635, 3110523913, 3462522015, 1591671054, 702138776, 2966460450, 3352799412, 1504918807, 783551873, 3082640443, 3233442989, 3988292384, 2596254646, 62317068, 1957810842, 3939845945, 2647816111, 81470997, 1943803523, 3814918930, 2489596804, 225274430, 2053790376, 3826175755, 2466906013, 167816743, 2097651377, 4027552580, 2265490386, 503444072, 1762050814, 4150417245, 2154129355, 426522225, 1852507879, 4275313526, 2312317920, 282753626, 1742555852, 4189708143, 2394877945, 397917763, 1622183637, 3604390888, 2714866558, 953729732, 1340076626, 3518719985, 2797360999, 1068828381, 1219638859, 3624741850, 2936675148, 906185462, 1090812512, 3747672003, 2825379669, 829329135, 1181335161, 3412177804, 3160834842, 628085408, 1382605366, 3423369109, 3138078467, 570562233, 1426400815, 3317316542, 2998733608, 733239954, 1555261956, 3268935591, 3050360625, 752459403, 1541320221, 2607071920, 3965973030, 1969922972, 40735498, 2617837225, 3943577151, 1913087877, 83908371, 2512341634, 3803740692, 2075208622, 213261112, 2463272603, 3855990285, 2094854071, 198958881, 2262029012, 4057260610, 1759359992, 534414190, 2176718541, 4139329115, 1873836001, 414664567, 2282248934, 4279200368, 1711684554, 285281116, 2405801727, 4167216745, 1634467795, 376229701, 2685067896, 3608007406, 1308918612, 956543938, 2808555105, 3495958263, 1231636301, 1047427035, 2932959818, 3654703836, 1088359270, 936918e3, 2847714899, 3736837829, 1202900863, 817233897, 3183342108, 3401237130, 1404277552, 615818150, 3134207493, 3453421203, 1423857449, 601450431, 3009837614, 3294710456, 1567103746, 711928724, 3020668471, 3272380065, 1510334235, 755167117]); function z2(e) { const t = new Uint8Array(e); let n = -1; for (let r = 0; r < t.length; r++) { const s = (t[r] ^ n) & 255; n = $2[s] ^ n >>> 8 } return (n ^ -1) >>> 0 } const _i = typeof globalThis == "object" && "crypto" in globalThis ? globalThis.crypto : void 0;/*! noble-hashes - MIT License (c) 2022 Paul Miller (paulmillr.com) */function sd(e) { return e instanceof Uint8Array || ArrayBuffer.isView(e) && e.constructor.name === "Uint8Array" } function V2(e) { if (!Number.isSafeInteger(e) || e < 0) throw new Error("positive integer expected, got " + e) } function It(e, ...t) { if (!sd(e)) throw new Error("Uint8Array expected"); if (t.length > 0 && !t.includes(e.length)) throw new Error("Uint8Array expected of length " + t + ", got length=" + e.length) } function k0(e, t = !0) { if (e.destroyed) throw new Error("Hash instance has been destroyed"); if (t && e.finished) throw new Error("Hash#digest() has already been called") } function q2(e, t) { It(e); const n = t.outputLen; if (e.length < n) throw new Error("digestInto() expects output buffer of length at least " + n) } function po(...e) { for (let t = 0; t < e.length; t++)e[t].fill(0) } function Uu(e) { return new DataView(e.buffer, e.byteOffset, e.byteLength) } function Nn(e, t) { return e << 32 - t | e >>> t } const P1 = typeof Uint8Array.from([]).toHex == "function" && typeof Uint8Array.fromHex == "function", H2 = Array.from({ length: 256 }, (e, t) => t.toString(16).padStart(2, "0")); function fs(e) { if (It(e), P1) return e.toHex(); let t = ""; for (let n = 0; n < e.length; n++)t += H2[e[n]]; return t } const Vn = { _0: 48, _9: 57, A: 65, F: 70, a: 97, f: 102 }; function R0(e) { if (e >= Vn._0 && e <= Vn._9) return e - Vn._0; if (e >= Vn.A && e <= Vn.F) return e - (Vn.A - 10); if (e >= Vn.a && e <= Vn.f) return e - (Vn.a - 10) } function M1(e) { if (typeof e != "string") throw new Error("hex string expected, got " + typeof e); if (P1) return Uint8Array.fromHex(e); const t = e.length, n = t / 2; if (t % 2) throw new Error("hex string expected, got unpadded hex of length " + t); const r = new Uint8Array(n); for (let i = 0, s = 0; i < n; i++, s += 2) { const o = R0(e.charCodeAt(s)), a = R0(e.charCodeAt(s + 1)); if (o === void 0 || a === void 0) { const f = e[s] + e[s + 1]; throw new Error('hex string expected, got non-hex character "' + f + '" at index ' + s) } r[i] = o * 16 + a } return r } function Ao(e) { if (typeof e != "string") throw new Error("string expected"); return new Uint8Array(new TextEncoder().encode(e)) } function j1(e) { return typeof e == "string" && (e = Ao(e)), It(e), e } function Je(...e) { let t = 0; for (let r = 0; r < e.length; r++) { const i = e[r]; It(i), t += i.length } const n = new Uint8Array(t); for (let r = 0, i = 0; r < e.length; r++) { const s = e[r]; n.set(s, i), i += s.length } return n } class G2 { } function od(e) { const t = r => e().update(j1(r)).digest(), n = e(); return t.outputLen = n.outputLen, t.blockLen = n.blockLen, t.create = () => e(), t } function $1(e = 32) { if (_i && typeof _i.getRandomValues == "function") return _i.getRandomValues(new Uint8Array(e)); if (_i && typeof _i.randomBytes == "function") return Uint8Array.from(_i.randomBytes(e)); throw new Error("crypto.getRandomValues must be defined") } function L2(e, t, n, r) { if (typeof e.setBigUint64 == "function") return e.setBigUint64(t, n, r); const i = BigInt(32), s = BigInt(4294967295), o = Number(n >> i & s), a = Number(n & s), f = r ? 4 : 0, h = r ? 0 : 4; e.setUint32(t + f, o, r), e.setUint32(t + h, a, r) } function W2(e, t, n) { return e & t ^ ~e & n } function Y2(e, t, n) { return e & t ^ e & n ^ t & n } class z1 extends G2 { constructor(t, n, r, i) { super(), this.finished = !1, this.length = 0, this.pos = 0, this.destroyed = !1, this.blockLen = t, this.outputLen = n, this.padOffset = r, this.isLE = i, this.buffer = new Uint8Array(t), this.view = Uu(this.buffer) } update(t) { k0(this), t = j1(t), It(t); const { view: n, buffer: r, blockLen: i } = this, s = t.length; for (let o = 0; o < s;) { const a = Math.min(i - this.pos, s - o); if (a === i) { const f = Uu(t); for (; i <= s - o; o += i)this.process(f, o); continue } r.set(t.subarray(o, o + a), this.pos), this.pos += a, o += a, this.pos === i && (this.process(n, 0), this.pos = 0) } return this.length += t.length, this.roundClean(), this } digestInto(t) { k0(this), q2(t, this), this.finished = !0; const { buffer: n, view: r, blockLen: i, isLE: s } = this; let { pos: o } = this; n[o++] = 128, po(this.buffer.subarray(o)), this.padOffset > i - o && (this.process(r, 0), o = 0); for (let v = o; v < i; v++)n[v] = 0; L2(r, i - 8, BigInt(this.length * 8), s), this.process(r, 0); const a = Uu(t), f = this.outputLen; if (f % 4) throw new Error("_sha2: outputLen should be aligned to 32bit"); const h = f / 4, _ = this.get(); if (h > _.length) throw new Error("_sha2: outputLen bigger than state"); for (let v = 0; v < h; v++)a.setUint32(4 * v, _[v], s) } digest() { const { buffer: t, outputLen: n } = this; this.digestInto(t); const r = t.slice(0, n); return this.destroy(), r } _cloneInto(t) { t || (t = new this.constructor), t.set(...this.get()); const { blockLen: n, buffer: r, length: i, finished: s, destroyed: o, pos: a } = this; return t.destroyed = o, t.finished = s, t.length = i, t.pos = a, i % n && t.buffer.set(r), t } clone() { return this._cloneInto() } } const fr = Uint32Array.from([1779033703, 3144134277, 1013904242, 2773480762, 1359893119, 2600822924, 528734635, 1541459225]), dr = Uint32Array.from([3238371032, 914150663, 812702999, 4144912697, 4290775857, 1750603025, 1694076839, 3204075428]), St = Uint32Array.from([1779033703, 4089235720, 3144134277, 2227873595, 1013904242, 4271175723, 2773480762, 1595750129, 1359893119, 2917565137, 2600822924, 725511199, 528734635, 4215389547, 1541459225, 327033209]), Do = BigInt(2 ** 32 - 1), I0 = BigInt(32); function K2(e, t = !1) { return t ? { h: Number(e & Do), l: Number(e >> I0 & Do) } : { h: Number(e >> I0 & Do) | 0, l: Number(e & Do) | 0 } } function Z2(e, t = !1) { const n = e.length; let r = new Uint32Array(n), i = new Uint32Array(n); for (let s = 0; s < n; s++) { const { h: o, l: a } = K2(e[s], t);[r[s], i[s]] = [o, a] } return [r, i] } const O0 = (e, t, n) => e >>> n, U0 = (e, t, n) => e << 32 - n | t >>> n, Ei = (e, t, n) => e >>> n | t << 32 - n, bi = (e, t, n) => e << 32 - n | t >>> n, Jo = (e, t, n) => e << 64 - n | t >>> n - 32, ea = (e, t, n) => e >>> n - 32 | t << 64 - n; function qn(e, t, n, r) { const i = (t >>> 0) + (r >>> 0); return { h: e + n + (i / 2 ** 32 | 0) | 0, l: i | 0 } } const X2 = (e, t, n) => (e >>> 0) + (t >>> 0) + (n >>> 0), Q2 = (e, t, n, r) => t + n + r + (e / 2 ** 32 | 0) | 0, D2 = (e, t, n, r) => (e >>> 0) + (t >>> 0) + (n >>> 0) + (r >>> 0), J2 = (e, t, n, r, i) => t + n + r + i + (e / 2 ** 32 | 0) | 0, ex = (e, t, n, r, i) => (e >>> 0) + (t >>> 0) + (n >>> 0) + (r >>> 0) + (i >>> 0), tx = (e, t, n, r, i, s) => t + n + r + i + s + (e / 2 ** 32 | 0) | 0, nx = Uint32Array.from([1116352408, 1899447441, 3049323471, 3921009573, 961987163, 1508970993, 2453635748, 2870763221, 3624381080, 310598401, 607225278, 1426881987, 1925078388, 2162078206, 2614888103, 3248222580, 3835390401, 4022224774, 264347078, 604807628, 770255983, 1249150122, 1555081692, 1996064986, 2554220882, 2821834349, 2952996808, 3210313671, 3336571891, 3584528711, 113926993, 338241895, 666307205, 773529912, 1294757372, 1396182291, 1695183700, 1986661051, 2177026350, 2456956037, 2730485921, 2820302411, 3259730800, 3345764771, 3516065817, 3600352804, 4094571909, 275423344, 430227734, 506948616, 659060556, 883997877, 958139571, 1322822218, 1537002063, 1747873779, 1955562222, 2024104815, 2227730452, 2361852424, 2428436474, 2756734187, 3204031479, 3329325298]), hr = new Uint32Array(64); class V1 extends z1 { constructor(t = 32) { super(64, t, 8, !1), this.A = fr[0] | 0, this.B = fr[1] | 0, this.C = fr[2] | 0, this.D = fr[3] | 0, this.E = fr[4] | 0, this.F = fr[5] | 0, this.G = fr[6] | 0, this.H = fr[7] | 0 } get() { const { A: t, B: n, C: r, D: i, E: s, F: o, G: a, H: f } = this; return [t, n, r, i, s, o, a, f] } set(t, n, r, i, s, o, a, f) { this.A = t | 0, this.B = n | 0, this.C = r | 0, this.D = i | 0, this.E = s | 0, this.F = o | 0, this.G = a | 0, this.H = f | 0 } process(t, n) { for (let v = 0; v < 16; v++, n += 4)hr[v] = t.getUint32(n, !1); for (let v = 16; v < 64; v++) { const y = hr[v - 15], w = hr[v - 2], p = Nn(y, 7) ^ Nn(y, 18) ^ y >>> 3, O = Nn(w, 17) ^ Nn(w, 19) ^ w >>> 10; hr[v] = O + hr[v - 7] + p + hr[v - 16] | 0 } let { A: r, B: i, C: s, D: o, E: a, F: f, G: h, H: _ } = this; for (let v = 0; v < 64; v++) { const y = Nn(a, 6) ^ Nn(a, 11) ^ Nn(a, 25), w = _ + y + W2(a, f, h) + nx[v] + hr[v] | 0, O = (Nn(r, 2) ^ Nn(r, 13) ^ Nn(r, 22)) + Y2(r, i, s) | 0; _ = h, h = f, f = a, a = o + w | 0, o = s, s = i, i = r, r = w + O | 0 } r = r + this.A | 0, i = i + this.B | 0, s = s + this.C | 0, o = o + this.D | 0, a = a + this.E | 0, f = f + this.F | 0, h = h + this.G | 0, _ = _ + this.H | 0, this.set(r, i, s, o, a, f, h, _) } roundClean() { po(hr) } destroy() { this.set(0, 0, 0, 0, 0, 0, 0, 0), po(this.buffer) } } class rx extends V1 { constructor() { super(28), this.A = dr[0] | 0, this.B = dr[1] | 0, this.C = dr[2] | 0, this.D = dr[3] | 0, this.E = dr[4] | 0, this.F = dr[5] | 0, this.G = dr[6] | 0, this.H = dr[7] | 0 } } const q1 = Z2(["0x428a2f98d728ae22", "0x7137449123ef65cd", "0xb5c0fbcfec4d3b2f", "0xe9b5dba58189dbbc", "0x3956c25bf348b538", "0x59f111f1b605d019", "0x923f82a4af194f9b", "0xab1c5ed5da6d8118", "0xd807aa98a3030242", "0x12835b0145706fbe", "0x243185be4ee4b28c", "0x550c7dc3d5ffb4e2", "0x72be5d74f27b896f", "0x80deb1fe3b1696b1", "0x9bdc06a725c71235", "0xc19bf174cf692694", "0xe49b69c19ef14ad2", "0xefbe4786384f25e3", "0x0fc19dc68b8cd5b5", "0x240ca1cc77ac9c65", "0x2de92c6f592b0275", "0x4a7484aa6ea6e483", "0x5cb0a9dcbd41fbd4", "0x76f988da831153b5", "0x983e5152ee66dfab", "0xa831c66d2db43210", "0xb00327c898fb213f", "0xbf597fc7beef0ee4", "0xc6e00bf33da88fc2", "0xd5a79147930aa725", "0x06ca6351e003826f", "0x142929670a0e6e70", "0x27b70a8546d22ffc", "0x2e1b21385c26c926", "0x4d2c6dfc5ac42aed", "0x53380d139d95b3df", "0x650a73548baf63de", "0x766a0abb3c77b2a8", "0x81c2c92e47edaee6", "0x92722c851482353b", "0xa2bfe8a14cf10364", "0xa81a664bbc423001", "0xc24b8b70d0f89791", "0xc76c51a30654be30", "0xd192e819d6ef5218", "0xd69906245565a910", "0xf40e35855771202a", "0x106aa07032bbd1b8", "0x19a4c116b8d2d0c8", "0x1e376c085141ab53", "0x2748774cdf8eeb99", "0x34b0bcb5e19b48a8", "0x391c0cb3c5c95a63", "0x4ed8aa4ae3418acb", "0x5b9cca4f7763e373", "0x682e6ff3d6b2b8a3", "0x748f82ee5defb2fc", "0x78a5636f43172f60", "0x84c87814a1f0ab72", "0x8cc702081a6439ec", "0x90befffa23631e28", "0xa4506cebde82bde9", "0xbef9a3f7b2c67915", "0xc67178f2e372532b", "0xca273eceea26619c", "0xd186b8c721c0c207", "0xeada7dd6cde0eb1e", "0xf57d4f7fee6ed178", "0x06f067aa72176fba", "0x0a637dc5a2c898a6", "0x113f9804bef90dae", "0x1b710b35131c471b", "0x28db77f523047d84", "0x32caab7b40c72493", "0x3c9ebe0a15c9bebc", "0x431d67c49c100d4c", "0x4cc5d4becb3e42b6", "0x597f299cfc657e2a", "0x5fcb6fab3ad6faec", "0x6c44198c4a475817"].map(e => BigInt(e))), ix = q1[0], sx = q1[1], pr = new Uint32Array(80), mr = new Uint32Array(80); class ox extends z1 { constructor(t = 64) { super(128, t, 16, !1), this.Ah = St[0] | 0, this.Al = St[1] | 0, this.Bh = St[2] | 0, this.Bl = St[3] | 0, this.Ch = St[4] | 0, this.Cl = St[5] | 0, this.Dh = St[6] | 0, this.Dl = St[7] | 0, this.Eh = St[8] | 0, this.El = St[9] | 0, this.Fh = St[10] | 0, this.Fl = St[11] | 0, this.Gh = St[12] | 0, this.Gl = St[13] | 0, this.Hh = St[14] | 0, this.Hl = St[15] | 0 } get() { const { Ah: t, Al: n, Bh: r, Bl: i, Ch: s, Cl: o, Dh: a, Dl: f, Eh: h, El: _, Fh: v, Fl: y, Gh: w, Gl: p, Hh: O, Hl: $ } = this; return [t, n, r, i, s, o, a, f, h, _, v, y, w, p, O, $] } set(t, n, r, i, s, o, a, f, h, _, v, y, w, p, O, $) { this.Ah = t | 0, this.Al = n | 0, this.Bh = r | 0, this.Bl = i | 0, this.Ch = s | 0, this.Cl = o | 0, this.Dh = a | 0, this.Dl = f | 0, this.Eh = h | 0, this.El = _ | 0, this.Fh = v | 0, this.Fl = y | 0, this.Gh = w | 0, this.Gl = p | 0, this.Hh = O | 0, this.Hl = $ | 0 } process(t, n) { for (let S = 0; S < 16; S++, n += 4)pr[S] = t.getUint32(n), mr[S] = t.getUint32(n += 4); for (let S = 16; S < 80; S++) { const M = pr[S - 15] | 0, k = mr[S - 15] | 0, C = Ei(M, k, 1) ^ Ei(M, k, 8) ^ O0(M, k, 7), V = bi(M, k, 1) ^ bi(M, k, 8) ^ U0(M, k, 7), Y = pr[S - 2] | 0, re = mr[S - 2] | 0, U = Ei(Y, re, 19) ^ Jo(Y, re, 61) ^ O0(Y, re, 6), K = bi(Y, re, 19) ^ ea(Y, re, 61) ^ U0(Y, re, 6), ee = D2(V, K, mr[S - 7], mr[S - 16]), N = J2(ee, C, U, pr[S - 7], pr[S - 16]); pr[S] = N | 0, mr[S] = ee | 0 } let { Ah: r, Al: i, Bh: s, Bl: o, Ch: a, Cl: f, Dh: h, Dl: _, Eh: v, El: y, Fh: w, Fl: p, Gh: O, Gl: $, Hh: b, Hl: E } = this; for (let S = 0; S < 80; S++) { const M = Ei(v, y, 14) ^ Ei(v, y, 18) ^ Jo(v, y, 41), k = bi(v, y, 14) ^ bi(v, y, 18) ^ ea(v, y, 41), C = v & w ^ ~v & O, V = y & p ^ ~y & $, Y = ex(E, k, V, sx[S], mr[S]), re = tx(Y, b, M, C, ix[S], pr[S]), U = Y | 0, K = Ei(r, i, 28) ^ Jo(r, i, 34) ^ Jo(r, i, 39), ee = bi(r, i, 28) ^ ea(r, i, 34) ^ ea(r, i, 39), N = r & s ^ r & a ^ s & a, F = i & o ^ i & f ^ o & f; b = O | 0, E = $ | 0, O = w | 0, $ = p | 0, w = v | 0, p = y | 0, { h: v, l: y } = qn(h | 0, _ | 0, re | 0, U | 0), h = a | 0, _ = f | 0, a = s | 0, f = o | 0, s = r | 0, o = i | 0; const G = X2(U, ee, F); r = Q2(G, re, K, N), i = G | 0 } ({ h: r, l: i } = qn(this.Ah | 0, this.Al | 0, r | 0, i | 0)), { h: s, l: o } = qn(this.Bh | 0, this.Bl | 0, s | 0, o | 0), { h: a, l: f } = qn(this.Ch | 0, this.Cl | 0, a | 0, f | 0), { h, l: _ } = qn(this.Dh | 0, this.Dl | 0, h | 0, _ | 0), { h: v, l: y } = qn(this.Eh | 0, this.El | 0, v | 0, y | 0), { h: w, l: p } = qn(this.Fh | 0, this.Fl | 0, w | 0, p | 0), { h: O, l: $ } = qn(this.Gh | 0, this.Gl | 0, O | 0, $ | 0), { h: b, l: E } = qn(this.Hh | 0, this.Hl | 0, b | 0, E | 0), this.set(r, i, s, o, a, f, h, _, v, y, w, p, O, $, b, E) } roundClean() { po(pr, mr) } destroy() { po(this.buffer), this.set(0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0) } } const H1 = od(() => new V1), ax = od(() => new rx), lx = od(() => new ox), ux = H1, cx = ax; function fx(e) { return cx.create().update(new Uint8Array(e)).digest() } const ta = "__principal__", dx = 2, F0 = 4, hx = "aaaaa-aa", px = e => { var t; return new Uint8Array(((t = e.match(/.{1,2}/g)) !== null && t !== void 0 ? t : []).map(n => parseInt(n, 16))) }, mx = e => e.reduce((t, n) => t + n.toString(16).padStart(2, "0"), ""); let Se = class _a { constructor(t) { this._arr = t, this._isPrincipal = !0 } static anonymous() { return new this(new Uint8Array([F0])) } static managementCanister() { return this.fromText(hx) } static selfAuthenticating(t) { const n = fx(t); return new this(new Uint8Array([...n, dx])) } static from(t) { if (typeof t == "string") return _a.fromText(t); if (Object.getPrototypeOf(t) === Uint8Array.prototype) return new _a(t); if (typeof t == "object" && t !== null && t._isPrincipal === !0) return new _a(t._arr); throw new Error(`Impossible to convert ${JSON.stringify(t)} to Principal.`) } static fromHex(t) { return new this(px(t)) } static fromText(t) { let n = t; if (t.includes(ta)) { const o = JSON.parse(t); ta in o && (n = o[ta]) } const r = n.toLowerCase().replace(/-/g, ""); let i = j2(r); i = i.slice(4, i.length); const s = new this(i); if (s.toText() !== n) throw new Error(`Principal "${s.toText()}" does not have a valid checksum (original value "${n}" may not be a valid Principal ID).`); return s } static fromUint8Array(t) { return new this(t) } isAnonymous() { return this._arr.byteLength === 1 && this._arr[0] === F0 } toUint8Array() { return this._arr } toHex() { return mx(this._arr).toUpperCase() } toText() { const t = new ArrayBuffer(4); new DataView(t).setUint32(0, z2(this._arr)); const r = new Uint8Array(t), i = Uint8Array.from(this._arr), s = new Uint8Array([...r, ...i]), a = M2(s).match(/.{1,5}/g); if (!a) throw new Error; return a.join("-") } toString() { return this.toText() } toJSON() { return { [ta]: this.toText() } } compareTo(t) { for (let n = 0; n < Math.min(this._arr.length, t._arr.length); n++) { if (this._arr[n] < t._arr[n]) return "lt"; if (this._arr[n] > t._arr[n]) return "gt" } return this._arr.length < t._arr.length ? "lt" : this._arr.length > t._arr.length ? "gt" : "eq" } ltEq(t) { const n = this.compareTo(t); return n == "lt" || n == "eq" } gtEq(t) { const n = this.compareTo(t); return n == "gt" || n == "eq" } }; function $n(...e) { const t = new Uint8Array(e.reduce((r, i) => r + i.byteLength, 0)); let n = 0; for (const r of e) t.set(new Uint8Array(r), n), n += r.byteLength; return t.buffer } function ht(e) { return [...new Uint8Array(e)].map(t => t.toString(16).padStart(2, "0")).join("") } const yx = new RegExp(/^[0-9a-fA-F]+$/); function fl(e) { if (!yx.test(e)) throw new Error("Invalid hexadecimal string."); const t = [...e].reduce((n, r, i) => (n[i / 2 | 0] = (n[i / 2 | 0] || "") + r, n), []).map(n => Number.parseInt(n, 16)); return new Uint8Array(t).buffer } function G1(e, t) { if (e.byteLength !== t.byteLength) return e.byteLength - t.byteLength; const n = new Uint8Array(e), r = new Uint8Array(t); for (let i = 0; i < n.length; i++)if (n[i] !== r[i]) return n[i] - r[i]; return 0 } function jl(e, t) { return G1(e, t) === 0 } function Ea(e) { return new DataView(e.buffer, e.byteOffset, e.byteLength).buffer } function Fs(e) { return e instanceof Uint8Array ? Ea(e) : e instanceof ArrayBuffer ? e : Array.isArray(e) ? Ea(new Uint8Array(e)) : "buffer" in e ? Fs(e.buffer) : Ea(new Uint8Array(e)) } class Ze extends Error { constructor(t) { super(t), this.message = t, this.name = "AgentError", this.__proto__ = Ze.prototype, Object.setPrototypeOf(this, Ze.prototype) } } function Fe(...e) { const t = new Uint8Array(e.reduce((r, i) => r + i.byteLength, 0)); let n = 0; for (const r of e) t.set(new Uint8Array(r), n), n += r.byteLength; return t } class ws { constructor(t, n = (t == null ? void 0 : t.byteLength) || 0) { this._buffer = dl(t || new ArrayBuffer(0)), this._view = new Uint8Array(this._buffer, 0, n) } save() { return this._view } restore(t) { this._view = t } get buffer() { return dl(this._view.slice()) } get byteLength() { return this._view.byteLength } read(t) { const n = this._view.subarray(0, t); return this._view = this._view.subarray(t), n.slice().buffer } readUint8() { const t = this._view[0]; return this._view = this._view.subarray(1), t } write(t) { const n = new Uint8Array(t), r = this._view.byteLength; this._view.byteOffset + this._view.byteLength + n.byteLength >= this._buffer.byteLength ? this.alloc(n.byteLength) : this._view = new Uint8Array(this._buffer, this._view.byteOffset, this._view.byteLength + n.byteLength), this._view.set(n, r) } get end() { return this._view.byteLength === 0 } alloc(t) { const n = new ArrayBuffer((this._buffer.byteLength + t) * 1.2 | 0), r = new Uint8Array(n, 0, this._view.byteLength + t); r.set(this._view), this._buffer = n, this._view = r } } function Fu(e) { return new DataView(e.buffer, e.byteOffset, e.byteLength).buffer } function dl(e) { return e instanceof Uint8Array ? Fu(e) : e instanceof ArrayBuffer ? e : Array.isArray(e) ? Fu(new Uint8Array(e)) : "buffer" in e ? dl(e.buffer) : Fu(new Uint8Array(e)) } function gx(e) { const n = new TextEncoder().encode(e); let r = 0; for (const i of n) r = (r * 223 + i) % 2 ** 32; return r } function Pn(e) { if (/^_\d+_$/.test(e) || /^_0x[0-9a-fA-F]+_$/.test(e)) { const t = +e.slice(1, -1); if (Number.isSafeInteger(t) && t >= 0 && t < 2 ** 32) return t } return gx(e) } function L1() { throw new Error("unexpected end of buffer") } function di(e, t) { return e.byteLength < t && L1(), e.read(t) } function hi(e) { const t = e.readUint8(); return t === void 0 && L1(), t } function Xe(e) { if (typeof e == "number" && (e = BigInt(e)), e < BigInt(0)) throw new Error("Cannot leb encode negative values."); const t = (e === BigInt(0) ? 0 : Math.ceil(Math.log2(Number(e)))) + 1, n = new ws(new ArrayBuffer(t), 0); for (; ;) { const r = Number(e & BigInt(127)); if (e /= BigInt(128), e === BigInt(0)) { n.write(new Uint8Array([r])); break } else n.write(new Uint8Array([r | 128])) } return n.buffer } function ft(e) { let t = BigInt(1), n = BigInt(0), r; do r = hi(e), n += BigInt(r & 127).valueOf() * t, t *= BigInt(128); while (r >= 128); return n } function at(e) { typeof e == "number" && (e = BigInt(e)); const t = e < BigInt(0); t && (e = -e - BigInt(1)); const n = (e === BigInt(0) ? 0 : Math.ceil(Math.log2(Number(e)))) + 1, r = new ws(new ArrayBuffer(n), 0); for (; ;) { const s = i(e); if (e /= BigInt(128), t && e === BigInt(0) && s & 64 || !t && e === BigInt(0) && !(s & 64)) { r.write(new Uint8Array([s])); break } else r.write(new Uint8Array([s | 128])) } function i(s) { const o = s % BigInt(128); return Number(t ? BigInt(128) - o - BigInt(1) : o) } return r.buffer } function yr(e) { const t = new Uint8Array(e.buffer); let n = 0; for (; n < t.byteLength; n++)if (t[n] < 128) { if (!(t[n] & 64)) return ft(e); break } const r = new Uint8Array(di(e, n + 1)); let i = BigInt(0); for (let s = r.byteLength - 1; s >= 0; s--)i = i * BigInt(128) + BigInt(128 - (r[s] & 127) - 1); return -i - BigInt(1) } function wx(e, t) { if (BigInt(e) < BigInt(0)) throw new Error("Cannot write negative values."); return W1(e, t) } function W1(e, t) { e = BigInt(e); const n = new ws(new ArrayBuffer(Math.min(1, t)), 0); let r = 0, i = BigInt(256), s = BigInt(0), o = Number(e % i); for (n.write(new Uint8Array([o])); ++r < t;)e < 0 && s === BigInt(0) && o !== 0 && (s = BigInt(1)), o = Number((e / i - s) % BigInt(256)), n.write(new Uint8Array([o])), i *= BigInt(256); return n.buffer } function Y1(e, t) { let n = BigInt(hi(e)), r = BigInt(1), i = 0; for (; ++i < t;) { r *= BigInt(256); const s = BigInt(hi(e)); n = n + r * s } return n } function xx(e, t) { let n = Y1(e, t); const r = BigInt(2) ** (BigInt(8) * BigInt(t - 1) + BigInt(7)); return n >= r && (n -= r * BigInt(2)), n } function Yc(e) { const t = BigInt(e); if (e < 0) throw new RangeError("Input must be non-negative"); return BigInt(1) << t } const ba = "DIDL", C0 = 400; function mo(e, t, n) { return e.map((r, i) => n(r, t[i])) } class vx { constructor() { this._typs = [], this._idx = new Map } has(t) { return this._idx.has(t.name) } add(t, n) { const r = this._typs.length; this._idx.set(t.name, r), this._typs.push(n) } merge(t, n) { const r = this._idx.get(t.name), i = this._idx.get(n); if (r === void 0) throw new Error("Missing type index for " + t); if (i === void 0) throw new Error("Missing type index for " + n); this._typs[r] = this._typs[i], this._typs.splice(i, 1), this._idx.delete(n) } encode() { const t = Xe(this._typs.length), n = Fe(...this._typs); return Fe(t, n) } indexOf(t) { if (!this._idx.has(t)) throw new Error("Missing type index for " + t); return at(this._idx.get(t) || 0) } } class _x { visitType(t, n) { throw new Error("Not implemented") } visitPrimitive(t, n) { return this.visitType(t, n) } visitEmpty(t, n) { return this.visitPrimitive(t, n) } visitBool(t, n) { return this.visitPrimitive(t, n) } visitNull(t, n) { return this.visitPrimitive(t, n) } visitReserved(t, n) { return this.visitPrimitive(t, n) } visitText(t, n) { return this.visitPrimitive(t, n) } visitNumber(t, n) { return this.visitPrimitive(t, n) } visitInt(t, n) { return this.visitNumber(t, n) } visitNat(t, n) { return this.visitNumber(t, n) } visitFloat(t, n) { return this.visitPrimitive(t, n) } visitFixedInt(t, n) { return this.visitNumber(t, n) } visitFixedNat(t, n) { return this.visitNumber(t, n) } visitPrincipal(t, n) { return this.visitPrimitive(t, n) } visitConstruct(t, n) { return this.visitType(t, n) } visitVec(t, n, r) { return this.visitConstruct(t, r) } visitOpt(t, n, r) { return this.visitConstruct(t, r) } visitRecord(t, n, r) { return this.visitConstruct(t, r) } visitTuple(t, n, r) { const i = n.map((s, o) => [`_${o}_`, s]); return this.visitRecord(t, i, r) } visitVariant(t, n, r) { return this.visitConstruct(t, r) } visitRec(t, n, r) { return this.visitConstruct(n, r) } visitFunc(t, n) { return this.visitConstruct(t, n) } visitService(t, n) { return this.visitConstruct(t, n) } } class $l { display() { return this.name } valueToString(t) { return et(t) } buildTypeTable(t) { t.has(this) || this._buildTypeTableImpl(t) } } class cn extends $l { checkType(t) { if (this.name !== t.name) throw new Error(`type mismatch: type on the wire ${t.name}, expect type ${this.name}`); return t } _buildTypeTableImpl(t) { } } class $r extends $l { checkType(t) { if (t instanceof lr) { const n = t.getType(); if (typeof n > "u") throw new Error("type mismatch with uninitialized type"); return n } throw new Error(`type mismatch: type on the wire ${t.name}, expect type ${this.name}`) } encodeType(t) { return t.indexOf(this.name) } } class K1 extends cn { accept(t, n) { return t.visitEmpty(this, n) } covariant(t) { throw new Error(`Invalid ${this.display()} argument: ${et(t)}`) } encodeValue() { throw new Error("Empty cannot appear as a function argument") } valueToString() { throw new Error("Empty cannot appear as a value") } encodeType() { return at(-17) } decodeValue() { throw new Error("Empty cannot appear as an output") } get name() { return "empty" } } class Z1 extends $l { checkType(t) { throw new Error("Method not implemented for unknown.") } accept(t, n) { throw t.visitType(this, n) } covariant(t) { throw new Error(`Invalid ${this.display()} argument: ${et(t)}`) } encodeValue() { throw new Error("Unknown cannot appear as a function argument") } valueToString() { throw new Error("Unknown cannot appear as a value") } encodeType() { throw new Error("Unknown cannot be serialized") } decodeValue(t, n) { let r = n.decodeValue(t, n); Object(r) !== r && (r = Object(r)); let i; return n instanceof lr ? i = () => n.getType() : i = () => n, Object.defineProperty(r, "type", { value: i, writable: !0, enumerable: !1, configurable: !0 }), r } _buildTypeTableImpl() { throw new Error("Unknown cannot be serialized") } get name() { return "Unknown" } } class X1 extends cn { accept(t, n) { return t.visitBool(this, n) } covariant(t) { if (typeof t == "boolean") return !0; throw new Error(`Invalid ${this.display()} argument: ${et(t)}`) } encodeValue(t) { return new Uint8Array([t ? 1 : 0]) } encodeType() { return at(-2) } decodeValue(t, n) { switch (this.checkType(n), hi(t)) { case 0: return !1; case 1: return !0; default: throw new Error("Boolean value out of range") } } get name() { return "bool" } } class hl extends cn { accept(t, n) { return t.visitNull(this, n) } covariant(t) { if (t === null) return !0; throw new Error(`Invalid ${this.display()} argument: ${et(t)}`) } encodeValue() { return new ArrayBuffer(0) } encodeType() { return at(-1) } decodeValue(t, n) { return this.checkType(n), null } get name() { return "null" } } class ds extends cn { accept(t, n) { return t.visitReserved(this, n) } covariant(t) { return !0 } encodeValue() { return new ArrayBuffer(0) } encodeType() { return at(-16) } decodeValue(t, n) { return n.name !== this.name && n.decodeValue(t, n), null } get name() { return "reserved" } } class Q1 extends cn { accept(t, n) { return t.visitText(this, n) } covariant(t) { if (typeof t == "string") return !0; throw new Error(`Invalid ${this.display()} argument: ${et(t)}`) } encodeValue(t) { const n = new TextEncoder().encode(t), r = Xe(n.byteLength); return Fe(r, n) } encodeType() { return at(-15) } decodeValue(t, n) { this.checkType(n); const r = ft(t), i = di(t, Number(r)); return new TextDecoder("utf8", { fatal: !0 }).decode(i) } get name() { return "text" } valueToString(t) { return '"' + t + '"' } } class D1 extends cn { accept(t, n) { return t.visitInt(this, n) } covariant(t) { if (typeof t == "bigint" || Number.isInteger(t)) return !0; throw new Error(`Invalid ${this.display()} argument: ${et(t)}`) } encodeValue(t) { return at(t) } encodeType() { return at(-4) } decodeValue(t, n) { return this.checkType(n), yr(t) } get name() { return "int" } valueToString(t) { return t.toString() } } class J1 extends cn { accept(t, n) { return t.visitNat(this, n) } covariant(t) { if (typeof t == "bigint" && t >= BigInt(0) || Number.isInteger(t) && t >= 0) return !0; throw new Error(`Invalid ${this.display()} argument: ${et(t)}`) } encodeValue(t) { return Xe(t) } encodeType() { return at(-3) } decodeValue(t, n) { return this.checkType(n), ft(t) } get name() { return "nat" } valueToString(t) { return t.toString() } } class ad extends cn { constructor(t) { if (super(), this._bits = t, t !== 32 && t !== 64) throw new Error("not a valid float type") } accept(t, n) { return t.visitFloat(this, n) } covariant(t) { if (typeof t == "number" || t instanceof Number) return !0; throw new Error(`Invalid ${this.display()} argument: ${et(t)}`) } encodeValue(t) { const n = new ArrayBuffer(this._bits / 8), r = new DataView(n); return this._bits === 32 ? r.setFloat32(0, t, !0) : r.setFloat64(0, t, !0), n } encodeType() { const t = this._bits === 32 ? -13 : -14; return at(t) } decodeValue(t, n) { this.checkType(n); const r = di(t, this._bits / 8), i = new DataView(r); return this._bits === 32 ? i.getFloat32(0, !0) : i.getFloat64(0, !0) } get name() { return "float" + this._bits } valueToString(t) { return t.toString() } } class pi extends cn { constructor(t) { super(), this._bits = t } accept(t, n) { return t.visitFixedInt(this, n) } covariant(t) { const n = Yc(this._bits - 1) * BigInt(-1), r = Yc(this._bits - 1) - BigInt(1); let i = !1; if (typeof t == "bigint") i = t >= n && t <= r; else if (Number.isInteger(t)) { const s = BigInt(t); i = s >= n && s <= r } else i = !1; if (i) return !0; throw new Error(`Invalid ${this.display()} argument: ${et(t)}`) } encodeValue(t) { return W1(t, this._bits / 8) } encodeType() { const t = Math.log2(this._bits) - 3; return at(-9 - t) } decodeValue(t, n) { this.checkType(n); const r = xx(t, this._bits / 8); return this._bits <= 32 ? Number(r) : r } get name() { return `int${this._bits}` } valueToString(t) { return t.toString() } } class Ur extends cn { constructor(t) { super(), this._bits = t } accept(t, n) { return t.visitFixedNat(this, n) } covariant(t) { const n = Yc(this._bits); let r = !1; if (typeof t == "bigint" && t >= BigInt(0) ? r = t < n : Number.isInteger(t) && t >= 0 ? r = BigInt(t) < n : r = !1, r) return !0; throw new Error(`Invalid ${this.display()} argument: ${et(t)}`) } encodeValue(t) { return wx(t, this._bits / 8) } encodeType() { const t = Math.log2(this._bits) - 3; return at(-5 - t) } decodeValue(t, n) { this.checkType(n); const r = Y1(t, this._bits / 8); return this._bits <= 32 ? Number(r) : r } get name() { return `nat${this._bits}` } valueToString(t) { return t.toString() } } class zl extends $r {
  constructor(t) { super(), this._type = t, this._blobOptimization = !1, t instanceof Ur && t._bits === 8 && (this._blobOptimization = !0) } accept(t, n) { return t.visitVec(this, this._type, n) } covariant(t) {
    const n = this._type instanceof Ur ? this._type._bits : this._type instanceof pi ? this._type._bits : 0; if (ArrayBuffer.isView(t) && n == t.BYTES_PER_ELEMENT * 8 || Array.isArray(t) && t.every((r, i) => {
      try { return this._type.covariant(r) } catch (s) {
        throw new Error(`Invalid ${this.display()} argument: 

index ${i} -> ${s.message}`)
      }
    })) return !0; throw new Error(`Invalid ${this.display()} argument: ${et(t)}`)
  } encodeValue(t) { const n = Xe(t.length); if (this._blobOptimization) return Fe(n, new Uint8Array(t)); if (ArrayBuffer.isView(t)) return Fe(n, new Uint8Array(t.buffer)); const r = new ws(new ArrayBuffer(n.byteLength + t.length), 0); r.write(n); for (const i of t) { const s = this._type.encodeValue(i); r.write(new Uint8Array(s)) } return r.buffer } _buildTypeTableImpl(t) { this._type.buildTypeTable(t); const n = at(-19), r = this._type.encodeType(t); t.add(this, Fe(n, r)) } decodeValue(t, n) { const r = this.checkType(n); if (!(r instanceof zl)) throw new Error("Not a vector type"); const i = Number(ft(t)); if (this._type instanceof Ur) { if (this._type._bits == 8) return new Uint8Array(t.read(i)); if (this._type._bits == 16) return new Uint16Array(t.read(i * 2)); if (this._type._bits == 32) return new Uint32Array(t.read(i * 4)); if (this._type._bits == 64) return new BigUint64Array(t.read(i * 8)) } if (this._type instanceof pi) { if (this._type._bits == 8) return new Int8Array(t.read(i)); if (this._type._bits == 16) return new Int16Array(t.read(i * 2)); if (this._type._bits == 32) return new Int32Array(t.read(i * 4)); if (this._type._bits == 64) return new BigInt64Array(t.read(i * 8)) } const s = []; for (let o = 0; o < i; o++)s.push(this._type.decodeValue(t, r._type)); return s } get name() { return `vec ${this._type.name}` } display() { return `vec ${this._type.display()}` } valueToString(t) { return "vec {" + t.map(r => this._type.valueToString(r)).join("; ") + "}" }
} class mi extends $r {
  constructor(t) { super(), this._type = t } accept(t, n) { return t.visitOpt(this, this._type, n) } covariant(t) {
    try { if (Array.isArray(t) && (t.length === 0 || t.length === 1 && this._type.covariant(t[0]))) return !0 } catch (n) {
      throw new Error(`Invalid ${this.display()} argument: ${et(t)} 

-> ${n.message}`)
    } throw new Error(`Invalid ${this.display()} argument: ${et(t)}`)
  } encodeValue(t) { return t.length === 0 ? new Uint8Array([0]) : Fe(new Uint8Array([1]), this._type.encodeValue(t[0])) } _buildTypeTableImpl(t) { this._type.buildTypeTable(t); const n = at(-18), r = this._type.encodeType(t); t.add(this, Fe(n, r)) } decodeValue(t, n) { if (n instanceof hl) return []; if (n instanceof ds) return []; let r = n; if (n instanceof lr) { const i = n.getType(); if (typeof i > "u") throw new Error("type mismatch with uninitialized type"); r = i } if (r instanceof mi) switch (hi(t)) { case 0: return []; case 1: { const i = t.save(); try { return [this._type.decodeValue(t, r._type)] } catch { return t.restore(i), r._type.decodeValue(t, r._type), [] } } default: throw new Error("Not an option value") } else { if (this._type instanceof hl || this._type instanceof mi || this._type instanceof ds) return r.decodeValue(t, r), []; { const i = t.save(); try { return [this._type.decodeValue(t, n)] } catch { return t.restore(i), r.decodeValue(t, n), [] } } } } get name() { return `opt ${this._type.name}` } display() { return `opt ${this._type.display()}` } valueToString(t) { return t.length === 0 ? "null" : `opt ${this._type.valueToString(t[0])}` }
} class ko extends $r {
  constructor(t = {}) { super(), this._fields = Object.entries(t).sort((n, r) => Pn(n[0]) - Pn(r[0])) } accept(t, n) { return t.visitRecord(this, this._fields, n) } tryAsTuple() { const t = []; for (let n = 0; n < this._fields.length; n++) { const [r, i] = this._fields[n]; if (r !== `_${n}_`) return null; t.push(i) } return t } covariant(t) {
    if (typeof t == "object" && this._fields.every(([n, r]) => {
      if (!t.hasOwnProperty(n)) throw new Error(`Record is missing key "${n}".`); try { return r.covariant(t[n]) } catch (i) {
        throw new Error(`Invalid ${this.display()} argument: 

field ${n} -> ${i.message}`)
      }
    })) return !0; throw new Error(`Invalid ${this.display()} argument: ${et(t)}`)
  } encodeValue(t) { const n = this._fields.map(([i]) => t[i]), r = mo(this._fields, n, ([, i], s) => i.encodeValue(s)); return Fe(...r) } _buildTypeTableImpl(t) { this._fields.forEach(([s, o]) => o.buildTypeTable(t)); const n = at(-20), r = Xe(this._fields.length), i = this._fields.map(([s, o]) => Fe(Xe(Pn(s)), o.encodeType(t))); t.add(this, Fe(n, r, Fe(...i))) } decodeValue(t, n) { const r = this.checkType(n); if (!(r instanceof ko)) throw new Error("Not a record type"); const i = {}; let s = 0, o = 0; for (; o < r._fields.length;) { const [a, f] = r._fields[o]; if (s >= this._fields.length) { f.decodeValue(t, f), o++; continue } const [h, _] = this._fields[s], v = Pn(this._fields[s][0]), y = Pn(a); if (v === y) i[h] = _.decodeValue(t, f), s++, o++; else if (y > v) if (_ instanceof mi || _ instanceof ds) i[h] = [], s++; else throw new Error("Cannot find required field " + h); else f.decodeValue(t, f), o++ } for (const [a, f] of this._fields.slice(s)) if (f instanceof mi || f instanceof ds) i[a] = []; else throw new Error("Cannot find required field " + a); return i } get name() { return `record {${this._fields.map(([n, r]) => n + ":" + r.name).join("; ")}}` } display() { return `record {${this._fields.map(([n, r]) => n + ":" + r.display()).join("; ")}}` } valueToString(t) { const n = this._fields.map(([i]) => t[i]); return `record {${mo(this._fields, n, ([i, s], o) => i + "=" + s.valueToString(o)).join("; ")}}` }
} class Vl extends ko {
  constructor(t) { const n = {}; t.forEach((r, i) => n["_" + i + "_"] = r), super(n), this._components = t } accept(t, n) { return t.visitTuple(this, this._components, n) } covariant(t) {
    if (Array.isArray(t) && t.length >= this._fields.length && this._components.every((n, r) => {
      try { return n.covariant(t[r]) } catch (i) {
        throw new Error(`Invalid ${this.display()} argument: 

index ${r} -> ${i.message}`)
      }
    })) return !0; throw new Error(`Invalid ${this.display()} argument: ${et(t)}`)
  } encodeValue(t) { const n = mo(this._components, t, (r, i) => r.encodeValue(i)); return Fe(...n) } decodeValue(t, n) { const r = this.checkType(n); if (!(r instanceof Vl)) throw new Error("not a tuple type"); if (r._components.length < this._components.length) throw new Error("tuple mismatch"); const i = []; for (const [s, o] of r._components.entries()) s >= this._components.length ? o.decodeValue(t, o) : i.push(this._components[s].decodeValue(t, o)); return i } display() { return `record {${this._components.map(n => n.display()).join("; ")}}` } valueToString(t) { return `record {${mo(this._components, t, (r, i) => r.valueToString(i)).join("; ")}}` }
} class ql extends $r {
  constructor(t = {}) { super(), this._fields = Object.entries(t).sort((n, r) => Pn(n[0]) - Pn(r[0])) } accept(t, n) { return t.visitVariant(this, this._fields, n) } covariant(t) {
    if (typeof t == "object" && Object.entries(t).length === 1 && this._fields.every(([n, r]) => {
      try { return !t.hasOwnProperty(n) || r.covariant(t[n]) } catch (i) {
        throw new Error(`Invalid ${this.display()} argument: 

variant ${n} -> ${i.message}`)
      }
    })) return !0; throw new Error(`Invalid ${this.display()} argument: ${et(t)}`)
  } encodeValue(t) { for (let n = 0; n < this._fields.length; n++) { const [r, i] = this._fields[n]; if (t.hasOwnProperty(r)) { const s = Xe(n), o = i.encodeValue(t[r]); return Fe(s, o) } } throw Error("Variant has no data: " + t) } _buildTypeTableImpl(t) { this._fields.forEach(([, s]) => { s.buildTypeTable(t) }); const n = at(-21), r = Xe(this._fields.length), i = this._fields.map(([s, o]) => Fe(Xe(Pn(s)), o.encodeType(t))); t.add(this, Fe(n, r, ...i)) } decodeValue(t, n) { const r = this.checkType(n); if (!(r instanceof ql)) throw new Error("Not a variant type"); const i = Number(ft(t)); if (i >= r._fields.length) throw Error("Invalid variant index: " + i); const [s, o] = r._fields[i]; for (const [a, f] of this._fields) if (Pn(s) === Pn(a)) { const h = f.decodeValue(t, o); return { [a]: h } } throw new Error("Cannot find field hash " + s) } get name() { return `variant {${this._fields.map(([n, r]) => n + ":" + r.name).join("; ")}}` } display() { return `variant {${this._fields.map(([n, r]) => n + (r.name === "null" ? "" : `:${r.display()}`)).join("; ")}}` } valueToString(t) { for (const [n, r] of this._fields) if (t.hasOwnProperty(n)) { const i = r.valueToString(t[n]); return i === "null" ? `variant {${n}}` : `variant {${n}=${i}}` } throw new Error("Variant has no data: " + t) }
} class lr extends $r { constructor() { super(...arguments), this._id = lr._counter++, this._type = void 0 } accept(t, n) { if (!this._type) throw Error("Recursive type uninitialized."); return t.visitRec(this, this._type, n) } fill(t) { this._type = t } getType() { return this._type } covariant(t) { if (this._type && this._type.covariant(t)) return !0; throw new Error(`Invalid ${this.display()} argument: ${et(t)}`) } encodeValue(t) { if (!this._type) throw Error("Recursive type uninitialized."); return this._type.encodeValue(t) } _buildTypeTableImpl(t) { if (!this._type) throw Error("Recursive type uninitialized."); t.add(this, new Uint8Array([])), this._type.buildTypeTable(t), t.merge(this, this._type.name) } decodeValue(t, n) { if (!this._type) throw Error("Recursive type uninitialized."); return this._type.decodeValue(t, n) } get name() { return `rec_${this._id}` } display() { if (!this._type) throw Error("Recursive type uninitialized."); return `${this.name}.${this._type.name}` } valueToString(t) { if (!this._type) throw Error("Recursive type uninitialized."); return this._type.valueToString(t) } } lr._counter = 0; function ld(e) { if (hi(e) !== 1) throw new Error("Cannot decode principal"); const n = Number(ft(e)); return Se.fromUint8Array(new Uint8Array(di(e, n))) } class em extends cn { accept(t, n) { return t.visitPrincipal(this, n) } covariant(t) { if (t && t._isPrincipal) return !0; throw new Error(`Invalid ${this.display()} argument: ${et(t)}`) } encodeValue(t) { const n = t.toUint8Array(), r = Xe(n.byteLength); return Fe(new Uint8Array([1]), r, n) } encodeType() { return at(-24) } decodeValue(t, n) { return this.checkType(n), ld(t) } get name() { return "principal" } valueToString(t) { return `${this.name} "${t.toText()}"` } } class ud extends $r { constructor(t, n, r = []) { super(), this.argTypes = t, this.retTypes = n, this.annotations = r } static argsToString(t, n) { if (t.length !== n.length) throw new Error("arity mismatch"); return "(" + t.map((r, i) => r.valueToString(n[i])).join(", ") + ")" } accept(t, n) { return t.visitFunc(this, n) } covariant(t) { if (Array.isArray(t) && t.length === 2 && t[0] && t[0]._isPrincipal && typeof t[1] == "string") return !0; throw new Error(`Invalid ${this.display()} argument: ${et(t)}`) } encodeValue([t, n]) { const r = t.toUint8Array(), i = Xe(r.byteLength), s = Fe(new Uint8Array([1]), i, r), o = new TextEncoder().encode(n), a = Xe(o.byteLength); return Fe(new Uint8Array([1]), s, a, o) } _buildTypeTableImpl(t) { this.argTypes.forEach(h => h.buildTypeTable(t)), this.retTypes.forEach(h => h.buildTypeTable(t)); const n = at(-22), r = Xe(this.argTypes.length), i = Fe(...this.argTypes.map(h => h.encodeType(t))), s = Xe(this.retTypes.length), o = Fe(...this.retTypes.map(h => h.encodeType(t))), a = Xe(this.annotations.length), f = Fe(...this.annotations.map(h => this.encodeAnnotation(h))); t.add(this, Fe(n, r, i, s, o, a, f)) } decodeValue(t) { if (hi(t) !== 1) throw new Error("Cannot decode function reference"); const r = ld(t), i = Number(ft(t)), s = di(t, i), a = new TextDecoder("utf8", { fatal: !0 }).decode(s); return [r, a] } get name() { const t = this.argTypes.map(i => i.name).join(", "), n = this.retTypes.map(i => i.name).join(", "), r = " " + this.annotations.join(" "); return `(${t}) -> (${n})${r}` } valueToString([t, n]) { return `func "${t.toText()}".${n}` } display() { const t = this.argTypes.map(i => i.display()).join(", "), n = this.retTypes.map(i => i.display()).join(", "), r = " " + this.annotations.join(" "); return `(${t})  (${n})${r}` } encodeAnnotation(t) { if (t === "query") return new Uint8Array([1]); if (t === "oneway") return new Uint8Array([2]); if (t === "composite_query") return new Uint8Array([3]); throw new Error("Illegal function annotation") } } class tm extends $r { constructor(t) { super(), this._fields = Object.entries(t).sort((n, r) => n[0] < r[0] ? -1 : n[0] > r[0] ? 1 : 0) } accept(t, n) { return t.visitService(this, n) } covariant(t) { if (t && t._isPrincipal) return !0; throw new Error(`Invalid ${this.display()} argument: ${et(t)}`) } encodeValue(t) { const n = t.toUint8Array(), r = Xe(n.length); return Fe(new Uint8Array([1]), r, n) } _buildTypeTableImpl(t) { this._fields.forEach(([s, o]) => o.buildTypeTable(t)); const n = at(-23), r = Xe(this._fields.length), i = this._fields.map(([s, o]) => { const a = new TextEncoder().encode(s), f = Xe(a.length); return Fe(f, a, o.encodeType(t)) }); t.add(this, Fe(n, r, ...i)) } decodeValue(t) { return ld(t) } get name() { return `service {${this._fields.map(([n, r]) => n + ":" + r.name).join("; ")}}` } valueToString(t) { return `service "${t.toText()}"` } } function et(e) { const t = JSON.stringify(e, (n, r) => typeof r == "bigint" ? `BigInt(${r})` : r); return t && t.length > C0 ? t.substring(0, C0 - 3) + "..." : t } function Kc(e, t) {
  if (t.length < e.length) throw Error("Wrong number of message arguments"); const n = new vx; e.forEach(f => f.buildTypeTable(n)); const r = new TextEncoder().encode(ba), i = n.encode(), s = Xe(t.length), o = Fe(...e.map(f => f.encodeType(n))), a = Fe(...mo(e, t, (f, h) => {
    try { f.covariant(h) } catch (_) {
      throw new Error(_.message + `

`)
    } return f.encodeValue(h)
  })); return Fe(r, i, s, o, a)
} function nm(e, t) { const n = new ws(t); if (t.byteLength < ba.length) throw new Error("Message length smaller than magic number"); const r = di(n, ba.length), i = new TextDecoder().decode(r); if (i !== ba) throw new Error("Wrong magic number: " + JSON.stringify(i)); function s(w) { const p = [], O = Number(ft(w)); for (let E = 0; E < O; E++) { const S = Number(yr(w)); switch (S) { case -18: case -19: { const M = Number(yr(w)); p.push([S, M]); break } case -20: case -21: { const M = []; let k = Number(ft(w)), C; for (; k--;) { const V = Number(ft(w)); if (V >= Math.pow(2, 32)) throw new Error("field id out of 32-bit range"); if (typeof C == "number" && C >= V) throw new Error("field id collision or not sorted"); C = V; const Y = Number(yr(w)); M.push([V, Y]) } p.push([S, M]); break } case -22: { const M = []; let k = Number(ft(w)); for (; k--;)M.push(Number(yr(w))); const C = []; let V = Number(ft(w)); for (; V--;)C.push(Number(yr(w))); const Y = []; let re = Number(ft(w)); for (; re--;)switch (Number(ft(w))) { case 1: { Y.push("query"); break } case 2: { Y.push("oneway"); break } case 3: { Y.push("composite_query"); break } default: throw new Error("unknown annotation") }p.push([S, [M, C, Y]]); break } case -23: { let M = Number(ft(w)); const k = []; for (; M--;) { const C = Number(ft(w)), V = new TextDecoder().decode(di(w, C)), Y = yr(w); k.push([V, Y]) } p.push([S, k]); break } default: throw new Error("Illegal op_code: " + S) } } const $ = [], b = Number(ft(w)); for (let E = 0; E < b; E++)$.push(Number(yr(w))); return [p, $] } const [o, a] = s(n); if (a.length < e.length) throw new Error("Wrong number of return values"); const f = o.map(w => Tm()); function h(w) { if (w < -24) throw new Error("future value not supported"); if (w < 0) switch (w) { case -1: return om; case -2: return sm; case -3: return um; case -4: return lm; case -5: return ym; case -6: return gm; case -7: return wm; case -8: return xm; case -9: return dm; case -10: return hm; case -11: return pm; case -12: return mm; case -13: return cm; case -14: return fm; case -15: return am; case -16: return im; case -17: return rm; case -24: return vm; default: throw new Error("Illegal op_code: " + w) }if (w >= o.length) throw new Error("type index out of range"); return f[w] } function _(w) { switch (w[0]) { case -19: { const p = h(w[1]); return Em(p) } case -18: { const p = h(w[1]); return bm(p) } case -20: { const p = {}; for (const [b, E] of w[1]) { const S = `_${b}_`; p[S] = h(E) } const O = Sm(p), $ = O.tryAsTuple(); return Array.isArray($) ? _m(...$) : O } case -21: { const p = {}; for (const [O, $] of w[1]) { const b = `_${O}_`; p[b] = h($) } return Nm(p) } case -22: { const [p, O, $] = w[1]; return Bm(p.map(b => h(b)), O.map(b => h(b)), $) } case -23: { const p = {}, O = w[1]; for (const [$, b] of O) { let E = h(b); if (E instanceof lr && (E = E.getType()), !(E instanceof ud)) throw new Error("Illegal service definition: services can only contain functions"); p[$] = E } return Am(p) } default: throw new Error("Illegal op_code: " + w[0]) } } o.forEach((w, p) => { if (w[0] === -22) { const O = _(w); f[p].fill(O) } }), o.forEach((w, p) => { if (w[0] !== -22) { const O = _(w); f[p].fill(O) } }); const v = a.map(w => h(w)), y = e.map((w, p) => w.decodeValue(n, v[p])); for (let w = e.length; w < v.length; w++)v[w].decodeValue(n, v[w]); if (n.byteLength > 0) throw new Error("decode: Left-over bytes"); return y } const rm = new K1, im = new ds, Ex = new Z1, sm = new X1, om = new hl, am = new Q1, lm = new D1, um = new J1, cm = new ad(32), fm = new ad(64), dm = new pi(8), hm = new pi(16), pm = new pi(32), mm = new pi(64), ym = new Ur(8), gm = new Ur(16), wm = new Ur(32), xm = new Ur(64), vm = new em; function _m(...e) { return new Vl(e) } function Em(e) { return new zl(e) } function bm(e) { return new mi(e) } function Sm(e) { return new ko(e) } function Nm(e) { return new ql(e) } function Tm() { return new lr } function Bm(e, t, n = []) { return new ud(e, t, n) } function Am(e) { return new tm(e) } const bx = Object.freeze(Object.defineProperty({ __proto__: null, Bool: sm, BoolClass: X1, ConstructType: $r, Empty: rm, EmptyClass: K1, FixedIntClass: pi, FixedNatClass: Ur, Float32: cm, Float64: fm, FloatClass: ad, Func: Bm, FuncClass: ud, Int: lm, Int16: hm, Int32: pm, Int64: mm, Int8: dm, IntClass: D1, Nat: um, Nat16: gm, Nat32: wm, Nat64: xm, Nat8: ym, NatClass: J1, Null: om, NullClass: hl, Opt: bm, OptClass: mi, PrimitiveType: cn, Principal: vm, PrincipalClass: em, Rec: Tm, RecClass: lr, Record: Sm, RecordClass: ko, Reserved: im, ReservedClass: ds, Service: Am, ServiceClass: tm, Text: am, TextClass: Q1, Tuple: _m, TupleClass: Vl, Type: $l, Unknown: Ex, UnknownClass: Z1, Variant: Nm, VariantClass: ql, Vec: Em, VecClass: zl, Visitor: _x, decode: nm, encode: Kc }, Symbol.toStringTag, { value: "Module" })); var km = {}, Ro = {};/*!
 * The buffer module from node.js, for the browser.
 *
 * @author   Feross Aboukhadijeh <https://feross.org>
 * @license  MIT
 */(function (e) { var t = To, n = Bo, r = typeof Symbol == "function" && typeof Symbol.for == "function" ? Symbol.for("nodejs.util.inspect.custom") : null; e.Buffer = a, e.SlowBuffer = E, e.INSPECT_MAX_BYTES = 50; var i = 2147483647; e.kMaxLength = i, a.TYPED_ARRAY_SUPPORT = s(), !a.TYPED_ARRAY_SUPPORT && typeof console < "u" && typeof console.error == "function" && console.error("This browser lacks typed array (Uint8Array) support which is required by `buffer` v5.x. Use `buffer` v4.x if you require old browser support."); function s() { try { var m = new Uint8Array(1), l = { foo: function () { return 42 } }; return Object.setPrototypeOf(l, Uint8Array.prototype), Object.setPrototypeOf(m, l), m.foo() === 42 } catch { return !1 } } Object.defineProperty(a.prototype, "parent", { enumerable: !0, get: function () { if (a.isBuffer(this)) return this.buffer } }), Object.defineProperty(a.prototype, "offset", { enumerable: !0, get: function () { if (a.isBuffer(this)) return this.byteOffset } }); function o(m) { if (m > i) throw new RangeError('The value "' + m + '" is invalid for option "size"'); var l = new Uint8Array(m); return Object.setPrototypeOf(l, a.prototype), l } function a(m, l, u) { if (typeof m == "number") { if (typeof l == "string") throw new TypeError('The "string" argument must be of type string. Received type number'); return v(m) } return f(m, l, u) } a.poolSize = 8192; function f(m, l, u) { if (typeof m == "string") return y(m, l); if (ArrayBuffer.isView(m)) return p(m); if (m == null) throw new TypeError("The first argument must be one of type string, Buffer, ArrayBuffer, Array, or Array-like Object. Received type " + typeof m); if (Z(m, ArrayBuffer) || m && Z(m.buffer, ArrayBuffer) || typeof SharedArrayBuffer < "u" && (Z(m, SharedArrayBuffer) || m && Z(m.buffer, SharedArrayBuffer))) return O(m, l, u); if (typeof m == "number") throw new TypeError('The "value" argument must not be of type number. Received type number'); var x = m.valueOf && m.valueOf(); if (x != null && x !== m) return a.from(x, l, u); var T = $(m); if (T) return T; if (typeof Symbol < "u" && Symbol.toPrimitive != null && typeof m[Symbol.toPrimitive] == "function") return a.from(m[Symbol.toPrimitive]("string"), l, u); throw new TypeError("The first argument must be one of type string, Buffer, ArrayBuffer, Array, or Array-like Object. Received type " + typeof m) } a.from = function (m, l, u) { return f(m, l, u) }, Object.setPrototypeOf(a.prototype, Uint8Array.prototype), Object.setPrototypeOf(a, Uint8Array); function h(m) { if (typeof m != "number") throw new TypeError('"size" argument must be of type number'); if (m < 0) throw new RangeError('The value "' + m + '" is invalid for option "size"') } function _(m, l, u) { return h(m), m <= 0 ? o(m) : l !== void 0 ? typeof u == "string" ? o(m).fill(l, u) : o(m).fill(l) : o(m) } a.alloc = function (m, l, u) { return _(m, l, u) }; function v(m) { return h(m), o(m < 0 ? 0 : b(m) | 0) } a.allocUnsafe = function (m) { return v(m) }, a.allocUnsafeSlow = function (m) { return v(m) }; function y(m, l) { if ((typeof l != "string" || l === "") && (l = "utf8"), !a.isEncoding(l)) throw new TypeError("Unknown encoding: " + l); var u = S(m, l) | 0, x = o(u), T = x.write(m, l); return T !== u && (x = x.slice(0, T)), x } function w(m) { for (var l = m.length < 0 ? 0 : b(m.length) | 0, u = o(l), x = 0; x < l; x += 1)u[x] = m[x] & 255; return u } function p(m) { if (Z(m, Uint8Array)) { var l = new Uint8Array(m); return O(l.buffer, l.byteOffset, l.byteLength) } return w(m) } function O(m, l, u) { if (l < 0 || m.byteLength < l) throw new RangeError('"offset" is outside of buffer bounds'); if (m.byteLength < l + (u || 0)) throw new RangeError('"length" is outside of buffer bounds'); var x; return l === void 0 && u === void 0 ? x = new Uint8Array(m) : u === void 0 ? x = new Uint8Array(m, l) : x = new Uint8Array(m, l, u), Object.setPrototypeOf(x, a.prototype), x } function $(m) { if (a.isBuffer(m)) { var l = b(m.length) | 0, u = o(l); return u.length === 0 || m.copy(u, 0, 0, l), u } if (m.length !== void 0) return typeof m.length != "number" || W(m.length) ? o(0) : w(m); if (m.type === "Buffer" && Array.isArray(m.data)) return w(m.data) } function b(m) { if (m >= i) throw new RangeError("Attempt to allocate Buffer larger than maximum size: 0x" + i.toString(16) + " bytes"); return m | 0 } function E(m) { return +m != m && (m = 0), a.alloc(+m) } a.isBuffer = function (l) { return l != null && l._isBuffer === !0 && l !== a.prototype }, a.compare = function (l, u) { if (Z(l, Uint8Array) && (l = a.from(l, l.offset, l.byteLength)), Z(u, Uint8Array) && (u = a.from(u, u.offset, u.byteLength)), !a.isBuffer(l) || !a.isBuffer(u)) throw new TypeError('The "buf1", "buf2" arguments must be one of type Buffer or Uint8Array'); if (l === u) return 0; for (var x = l.length, T = u.length, P = 0, Q = Math.min(x, T); P < Q; ++P)if (l[P] !== u[P]) { x = l[P], T = u[P]; break } return x < T ? -1 : T < x ? 1 : 0 }, a.isEncoding = function (l) { switch (String(l).toLowerCase()) { case "hex": case "utf8": case "utf-8": case "ascii": case "latin1": case "binary": case "base64": case "ucs2": case "ucs-2": case "utf16le": case "utf-16le": return !0; default: return !1 } }, a.concat = function (l, u) { if (!Array.isArray(l)) throw new TypeError('"list" argument must be an Array of Buffers'); if (l.length === 0) return a.alloc(0); var x; if (u === void 0) for (u = 0, x = 0; x < l.length; ++x)u += l[x].length; var T = a.allocUnsafe(u), P = 0; for (x = 0; x < l.length; ++x) { var Q = l[x]; if (Z(Q, Uint8Array)) P + Q.length > T.length ? a.from(Q).copy(T, P) : Uint8Array.prototype.set.call(T, Q, P); else if (a.isBuffer(Q)) Q.copy(T, P); else throw new TypeError('"list" argument must be an Array of Buffers'); P += Q.length } return T }; function S(m, l) { if (a.isBuffer(m)) return m.length; if (ArrayBuffer.isView(m) || Z(m, ArrayBuffer)) return m.byteLength; if (typeof m != "string") throw new TypeError('The "string" argument must be one of type string, Buffer, or ArrayBuffer. Received type ' + typeof m); var u = m.length, x = arguments.length > 2 && arguments[2] === !0; if (!x && u === 0) return 0; for (var T = !1; ;)switch (l) { case "ascii": case "latin1": case "binary": return u; case "utf8": case "utf-8": return fe(m).length; case "ucs2": case "ucs-2": case "utf16le": case "utf-16le": return u * 2; case "hex": return u >>> 1; case "base64": return I(m).length; default: if (T) return x ? -1 : fe(m).length; l = ("" + l).toLowerCase(), T = !0 } } a.byteLength = S; function M(m, l, u) { var x = !1; if ((l === void 0 || l < 0) && (l = 0), l > this.length || ((u === void 0 || u > this.length) && (u = this.length), u <= 0) || (u >>>= 0, l >>>= 0, u <= l)) return ""; for (m || (m = "utf8"); ;)switch (m) { case "hex": return D(this, l, u); case "utf8": case "utf-8": return F(this, l, u); case "ascii": return ie(this, l, u); case "latin1": case "binary": return z(this, l, u); case "base64": return N(this, l, u); case "ucs2": case "ucs-2": case "utf16le": case "utf-16le": return ae(this, l, u); default: if (x) throw new TypeError("Unknown encoding: " + m); m = (m + "").toLowerCase(), x = !0 } } a.prototype._isBuffer = !0; function k(m, l, u) { var x = m[l]; m[l] = m[u], m[u] = x } a.prototype.swap16 = function () { var l = this.length; if (l % 2 !== 0) throw new RangeError("Buffer size must be a multiple of 16-bits"); for (var u = 0; u < l; u += 2)k(this, u, u + 1); return this }, a.prototype.swap32 = function () { var l = this.length; if (l % 4 !== 0) throw new RangeError("Buffer size must be a multiple of 32-bits"); for (var u = 0; u < l; u += 4)k(this, u, u + 3), k(this, u + 1, u + 2); return this }, a.prototype.swap64 = function () { var l = this.length; if (l % 8 !== 0) throw new RangeError("Buffer size must be a multiple of 64-bits"); for (var u = 0; u < l; u += 8)k(this, u, u + 7), k(this, u + 1, u + 6), k(this, u + 2, u + 5), k(this, u + 3, u + 4); return this }, a.prototype.toString = function () { var l = this.length; return l === 0 ? "" : arguments.length === 0 ? F(this, 0, l) : M.apply(this, arguments) }, a.prototype.toLocaleString = a.prototype.toString, a.prototype.equals = function (l) { if (!a.isBuffer(l)) throw new TypeError("Argument must be a Buffer"); return this === l ? !0 : a.compare(this, l) === 0 }, a.prototype.inspect = function () { var l = "", u = e.INSPECT_MAX_BYTES; return l = this.toString("hex", 0, u).replace(/(.{2})/g, "$1 ").trim(), this.length > u && (l += " ... "), "<Buffer " + l + ">" }, r && (a.prototype[r] = a.prototype.inspect), a.prototype.compare = function (l, u, x, T, P) { if (Z(l, Uint8Array) && (l = a.from(l, l.offset, l.byteLength)), !a.isBuffer(l)) throw new TypeError('The "target" argument must be one of type Buffer or Uint8Array. Received type ' + typeof l); if (u === void 0 && (u = 0), x === void 0 && (x = l ? l.length : 0), T === void 0 && (T = 0), P === void 0 && (P = this.length), u < 0 || x > l.length || T < 0 || P > this.length) throw new RangeError("out of range index"); if (T >= P && u >= x) return 0; if (T >= P) return -1; if (u >= x) return 1; if (u >>>= 0, x >>>= 0, T >>>= 0, P >>>= 0, this === l) return 0; for (var Q = P - T, le = x - u, de = Math.min(Q, le), pe = this.slice(T, P), _e = l.slice(u, x), g = 0; g < de; ++g)if (pe[g] !== _e[g]) { Q = pe[g], le = _e[g]; break } return Q < le ? -1 : le < Q ? 1 : 0 }; function C(m, l, u, x, T) { if (m.length === 0) return -1; if (typeof u == "string" ? (x = u, u = 0) : u > 2147483647 ? u = 2147483647 : u < -2147483648 && (u = -2147483648), u = +u, W(u) && (u = T ? 0 : m.length - 1), u < 0 && (u = m.length + u), u >= m.length) { if (T) return -1; u = m.length - 1 } else if (u < 0) if (T) u = 0; else return -1; if (typeof l == "string" && (l = a.from(l, x)), a.isBuffer(l)) return l.length === 0 ? -1 : V(m, l, u, x, T); if (typeof l == "number") return l = l & 255, typeof Uint8Array.prototype.indexOf == "function" ? T ? Uint8Array.prototype.indexOf.call(m, l, u) : Uint8Array.prototype.lastIndexOf.call(m, l, u) : V(m, [l], u, x, T); throw new TypeError("val must be string, number or Buffer") } function V(m, l, u, x, T) { var P = 1, Q = m.length, le = l.length; if (x !== void 0 && (x = String(x).toLowerCase(), x === "ucs2" || x === "ucs-2" || x === "utf16le" || x === "utf-16le")) { if (m.length < 2 || l.length < 2) return -1; P = 2, Q /= 2, le /= 2, u /= 2 } function de(d, R) { return P === 1 ? d[R] : d.readUInt16BE(R * P) } var pe; if (T) { var _e = -1; for (pe = u; pe < Q; pe++)if (de(m, pe) === de(l, _e === -1 ? 0 : pe - _e)) { if (_e === -1 && (_e = pe), pe - _e + 1 === le) return _e * P } else _e !== -1 && (pe -= pe - _e), _e = -1 } else for (u + le > Q && (u = Q - le), pe = u; pe >= 0; pe--) { for (var g = !0, c = 0; c < le; c++)if (de(m, pe + c) !== de(l, c)) { g = !1; break } if (g) return pe } return -1 } a.prototype.includes = function (l, u, x) { return this.indexOf(l, u, x) !== -1 }, a.prototype.indexOf = function (l, u, x) { return C(this, l, u, x, !0) }, a.prototype.lastIndexOf = function (l, u, x) { return C(this, l, u, x, !1) }; function Y(m, l, u, x) { u = Number(u) || 0; var T = m.length - u; x ? (x = Number(x), x > T && (x = T)) : x = T; var P = l.length; x > P / 2 && (x = P / 2); for (var Q = 0; Q < x; ++Q) { var le = parseInt(l.substr(Q * 2, 2), 16); if (W(le)) return Q; m[u + Q] = le } return Q } function re(m, l, u, x) { return j(fe(l, m.length - u), m, u, x) } function U(m, l, u, x) { return j(ye(l), m, u, x) } function K(m, l, u, x) { return j(I(l), m, u, x) } function ee(m, l, u, x) { return j(A(l, m.length - u), m, u, x) } a.prototype.write = function (l, u, x, T) { if (u === void 0) T = "utf8", x = this.length, u = 0; else if (x === void 0 && typeof u == "string") T = u, x = this.length, u = 0; else if (isFinite(u)) u = u >>> 0, isFinite(x) ? (x = x >>> 0, T === void 0 && (T = "utf8")) : (T = x, x = void 0); else throw new Error("Buffer.write(string, encoding, offset[, length]) is no longer supported"); var P = this.length - u; if ((x === void 0 || x > P) && (x = P), l.length > 0 && (x < 0 || u < 0) || u > this.length) throw new RangeError("Attempt to write outside buffer bounds"); T || (T = "utf8"); for (var Q = !1; ;)switch (T) { case "hex": return Y(this, l, u, x); case "utf8": case "utf-8": return re(this, l, u, x); case "ascii": case "latin1": case "binary": return U(this, l, u, x); case "base64": return K(this, l, u, x); case "ucs2": case "ucs-2": case "utf16le": case "utf-16le": return ee(this, l, u, x); default: if (Q) throw new TypeError("Unknown encoding: " + T); T = ("" + T).toLowerCase(), Q = !0 } }, a.prototype.toJSON = function () { return { type: "Buffer", data: Array.prototype.slice.call(this._arr || this, 0) } }; function N(m, l, u) { return l === 0 && u === m.length ? t.fromByteArray(m) : t.fromByteArray(m.slice(l, u)) } function F(m, l, u) { u = Math.min(m.length, u); for (var x = [], T = l; T < u;) { var P = m[T], Q = null, le = P > 239 ? 4 : P > 223 ? 3 : P > 191 ? 2 : 1; if (T + le <= u) { var de, pe, _e, g; switch (le) { case 1: P < 128 && (Q = P); break; case 2: de = m[T + 1], (de & 192) === 128 && (g = (P & 31) << 6 | de & 63, g > 127 && (Q = g)); break; case 3: de = m[T + 1], pe = m[T + 2], (de & 192) === 128 && (pe & 192) === 128 && (g = (P & 15) << 12 | (de & 63) << 6 | pe & 63, g > 2047 && (g < 55296 || g > 57343) && (Q = g)); break; case 4: de = m[T + 1], pe = m[T + 2], _e = m[T + 3], (de & 192) === 128 && (pe & 192) === 128 && (_e & 192) === 128 && (g = (P & 15) << 18 | (de & 63) << 12 | (pe & 63) << 6 | _e & 63, g > 65535 && g < 1114112 && (Q = g)) } } Q === null ? (Q = 65533, le = 1) : Q > 65535 && (Q -= 65536, x.push(Q >>> 10 & 1023 | 55296), Q = 56320 | Q & 1023), x.push(Q), T += le } return J(x) } var G = 4096; function J(m) { var l = m.length; if (l <= G) return String.fromCharCode.apply(String, m); for (var u = "", x = 0; x < l;)u += String.fromCharCode.apply(String, m.slice(x, x += G)); return u } function ie(m, l, u) { var x = ""; u = Math.min(m.length, u); for (var T = l; T < u; ++T)x += String.fromCharCode(m[T] & 127); return x } function z(m, l, u) { var x = ""; u = Math.min(m.length, u); for (var T = l; T < u; ++T)x += String.fromCharCode(m[T]); return x } function D(m, l, u) { var x = m.length; (!l || l < 0) && (l = 0), (!u || u < 0 || u > x) && (u = x); for (var T = "", P = l; P < u; ++P)T += X[m[P]]; return T } function ae(m, l, u) { for (var x = m.slice(l, u), T = "", P = 0; P < x.length - 1; P += 2)T += String.fromCharCode(x[P] + x[P + 1] * 256); return T } a.prototype.slice = function (l, u) { var x = this.length; l = ~~l, u = u === void 0 ? x : ~~u, l < 0 ? (l += x, l < 0 && (l = 0)) : l > x && (l = x), u < 0 ? (u += x, u < 0 && (u = 0)) : u > x && (u = x), u < l && (u = l); var T = this.subarray(l, u); return Object.setPrototypeOf(T, a.prototype), T }; function se(m, l, u) { if (m % 1 !== 0 || m < 0) throw new RangeError("offset is not uint"); if (m + l > u) throw new RangeError("Trying to access beyond buffer length") } a.prototype.readUintLE = a.prototype.readUIntLE = function (l, u, x) { l = l >>> 0, u = u >>> 0, x || se(l, u, this.length); for (var T = this[l], P = 1, Q = 0; ++Q < u && (P *= 256);)T += this[l + Q] * P; return T }, a.prototype.readUintBE = a.prototype.readUIntBE = function (l, u, x) { l = l >>> 0, u = u >>> 0, x || se(l, u, this.length); for (var T = this[l + --u], P = 1; u > 0 && (P *= 256);)T += this[l + --u] * P; return T }, a.prototype.readUint8 = a.prototype.readUInt8 = function (l, u) { return l = l >>> 0, u || se(l, 1, this.length), this[l] }, a.prototype.readUint16LE = a.prototype.readUInt16LE = function (l, u) { return l = l >>> 0, u || se(l, 2, this.length), this[l] | this[l + 1] << 8 }, a.prototype.readUint16BE = a.prototype.readUInt16BE = function (l, u) { return l = l >>> 0, u || se(l, 2, this.length), this[l] << 8 | this[l + 1] }, a.prototype.readUint32LE = a.prototype.readUInt32LE = function (l, u) { return l = l >>> 0, u || se(l, 4, this.length), (this[l] | this[l + 1] << 8 | this[l + 2] << 16) + this[l + 3] * 16777216 }, a.prototype.readUint32BE = a.prototype.readUInt32BE = function (l, u) { return l = l >>> 0, u || se(l, 4, this.length), this[l] * 16777216 + (this[l + 1] << 16 | this[l + 2] << 8 | this[l + 3]) }, a.prototype.readIntLE = function (l, u, x) { l = l >>> 0, u = u >>> 0, x || se(l, u, this.length); for (var T = this[l], P = 1, Q = 0; ++Q < u && (P *= 256);)T += this[l + Q] * P; return P *= 128, T >= P && (T -= Math.pow(2, 8 * u)), T }, a.prototype.readIntBE = function (l, u, x) { l = l >>> 0, u = u >>> 0, x || se(l, u, this.length); for (var T = u, P = 1, Q = this[l + --T]; T > 0 && (P *= 256);)Q += this[l + --T] * P; return P *= 128, Q >= P && (Q -= Math.pow(2, 8 * u)), Q }, a.prototype.readInt8 = function (l, u) { return l = l >>> 0, u || se(l, 1, this.length), this[l] & 128 ? (255 - this[l] + 1) * -1 : this[l] }, a.prototype.readInt16LE = function (l, u) { l = l >>> 0, u || se(l, 2, this.length); var x = this[l] | this[l + 1] << 8; return x & 32768 ? x | 4294901760 : x }, a.prototype.readInt16BE = function (l, u) { l = l >>> 0, u || se(l, 2, this.length); var x = this[l + 1] | this[l] << 8; return x & 32768 ? x | 4294901760 : x }, a.prototype.readInt32LE = function (l, u) { return l = l >>> 0, u || se(l, 4, this.length), this[l] | this[l + 1] << 8 | this[l + 2] << 16 | this[l + 3] << 24 }, a.prototype.readInt32BE = function (l, u) { return l = l >>> 0, u || se(l, 4, this.length), this[l] << 24 | this[l + 1] << 16 | this[l + 2] << 8 | this[l + 3] }, a.prototype.readFloatLE = function (l, u) { return l = l >>> 0, u || se(l, 4, this.length), n.read(this, l, !0, 23, 4) }, a.prototype.readFloatBE = function (l, u) { return l = l >>> 0, u || se(l, 4, this.length), n.read(this, l, !1, 23, 4) }, a.prototype.readDoubleLE = function (l, u) { return l = l >>> 0, u || se(l, 8, this.length), n.read(this, l, !0, 52, 8) }, a.prototype.readDoubleBE = function (l, u) { return l = l >>> 0, u || se(l, 8, this.length), n.read(this, l, !1, 52, 8) }; function oe(m, l, u, x, T, P) { if (!a.isBuffer(m)) throw new TypeError('"buffer" argument must be a Buffer instance'); if (l > T || l < P) throw new RangeError('"value" argument is out of bounds'); if (u + x > m.length) throw new RangeError("Index out of range") } a.prototype.writeUintLE = a.prototype.writeUIntLE = function (l, u, x, T) { if (l = +l, u = u >>> 0, x = x >>> 0, !T) { var P = Math.pow(2, 8 * x) - 1; oe(this, l, u, x, P, 0) } var Q = 1, le = 0; for (this[u] = l & 255; ++le < x && (Q *= 256);)this[u + le] = l / Q & 255; return u + x }, a.prototype.writeUintBE = a.prototype.writeUIntBE = function (l, u, x, T) { if (l = +l, u = u >>> 0, x = x >>> 0, !T) { var P = Math.pow(2, 8 * x) - 1; oe(this, l, u, x, P, 0) } var Q = x - 1, le = 1; for (this[u + Q] = l & 255; --Q >= 0 && (le *= 256);)this[u + Q] = l / le & 255; return u + x }, a.prototype.writeUint8 = a.prototype.writeUInt8 = function (l, u, x) { return l = +l, u = u >>> 0, x || oe(this, l, u, 1, 255, 0), this[u] = l & 255, u + 1 }, a.prototype.writeUint16LE = a.prototype.writeUInt16LE = function (l, u, x) { return l = +l, u = u >>> 0, x || oe(this, l, u, 2, 65535, 0), this[u] = l & 255, this[u + 1] = l >>> 8, u + 2 }, a.prototype.writeUint16BE = a.prototype.writeUInt16BE = function (l, u, x) { return l = +l, u = u >>> 0, x || oe(this, l, u, 2, 65535, 0), this[u] = l >>> 8, this[u + 1] = l & 255, u + 2 }, a.prototype.writeUint32LE = a.prototype.writeUInt32LE = function (l, u, x) { return l = +l, u = u >>> 0, x || oe(this, l, u, 4, 4294967295, 0), this[u + 3] = l >>> 24, this[u + 2] = l >>> 16, this[u + 1] = l >>> 8, this[u] = l & 255, u + 4 }, a.prototype.writeUint32BE = a.prototype.writeUInt32BE = function (l, u, x) { return l = +l, u = u >>> 0, x || oe(this, l, u, 4, 4294967295, 0), this[u] = l >>> 24, this[u + 1] = l >>> 16, this[u + 2] = l >>> 8, this[u + 3] = l & 255, u + 4 }, a.prototype.writeIntLE = function (l, u, x, T) { if (l = +l, u = u >>> 0, !T) { var P = Math.pow(2, 8 * x - 1); oe(this, l, u, x, P - 1, -P) } var Q = 0, le = 1, de = 0; for (this[u] = l & 255; ++Q < x && (le *= 256);)l < 0 && de === 0 && this[u + Q - 1] !== 0 && (de = 1), this[u + Q] = (l / le >> 0) - de & 255; return u + x }, a.prototype.writeIntBE = function (l, u, x, T) { if (l = +l, u = u >>> 0, !T) { var P = Math.pow(2, 8 * x - 1); oe(this, l, u, x, P - 1, -P) } var Q = x - 1, le = 1, de = 0; for (this[u + Q] = l & 255; --Q >= 0 && (le *= 256);)l < 0 && de === 0 && this[u + Q + 1] !== 0 && (de = 1), this[u + Q] = (l / le >> 0) - de & 255; return u + x }, a.prototype.writeInt8 = function (l, u, x) { return l = +l, u = u >>> 0, x || oe(this, l, u, 1, 127, -128), l < 0 && (l = 255 + l + 1), this[u] = l & 255, u + 1 }, a.prototype.writeInt16LE = function (l, u, x) { return l = +l, u = u >>> 0, x || oe(this, l, u, 2, 32767, -32768), this[u] = l & 255, this[u + 1] = l >>> 8, u + 2 }, a.prototype.writeInt16BE = function (l, u, x) { return l = +l, u = u >>> 0, x || oe(this, l, u, 2, 32767, -32768), this[u] = l >>> 8, this[u + 1] = l & 255, u + 2 }, a.prototype.writeInt32LE = function (l, u, x) { return l = +l, u = u >>> 0, x || oe(this, l, u, 4, 2147483647, -2147483648), this[u] = l & 255, this[u + 1] = l >>> 8, this[u + 2] = l >>> 16, this[u + 3] = l >>> 24, u + 4 }, a.prototype.writeInt32BE = function (l, u, x) { return l = +l, u = u >>> 0, x || oe(this, l, u, 4, 2147483647, -2147483648), l < 0 && (l = 4294967295 + l + 1), this[u] = l >>> 24, this[u + 1] = l >>> 16, this[u + 2] = l >>> 8, this[u + 3] = l & 255, u + 4 }; function Ae(m, l, u, x, T, P) { if (u + x > m.length) throw new RangeError("Index out of range"); if (u < 0) throw new RangeError("Index out of range") } function B(m, l, u, x, T) { return l = +l, u = u >>> 0, T || Ae(m, l, u, 4), n.write(m, l, u, x, 23, 4), u + 4 } a.prototype.writeFloatLE = function (l, u, x) { return B(this, l, u, !0, x) }, a.prototype.writeFloatBE = function (l, u, x) { return B(this, l, u, !1, x) }; function Pe(m, l, u, x, T) { return l = +l, u = u >>> 0, T || Ae(m, l, u, 8), n.write(m, l, u, x, 52, 8), u + 8 } a.prototype.writeDoubleLE = function (l, u, x) { return Pe(this, l, u, !0, x) }, a.prototype.writeDoubleBE = function (l, u, x) { return Pe(this, l, u, !1, x) }, a.prototype.copy = function (l, u, x, T) { if (!a.isBuffer(l)) throw new TypeError("argument should be a Buffer"); if (x || (x = 0), !T && T !== 0 && (T = this.length), u >= l.length && (u = l.length), u || (u = 0), T > 0 && T < x && (T = x), T === x || l.length === 0 || this.length === 0) return 0; if (u < 0) throw new RangeError("targetStart out of bounds"); if (x < 0 || x >= this.length) throw new RangeError("Index out of range"); if (T < 0) throw new RangeError("sourceEnd out of bounds"); T > this.length && (T = this.length), l.length - u < T - x && (T = l.length - u + x); var P = T - x; return this === l && typeof Uint8Array.prototype.copyWithin == "function" ? this.copyWithin(u, x, T) : Uint8Array.prototype.set.call(l, this.subarray(x, T), u), P }, a.prototype.fill = function (l, u, x, T) { if (typeof l == "string") { if (typeof u == "string" ? (T = u, u = 0, x = this.length) : typeof x == "string" && (T = x, x = this.length), T !== void 0 && typeof T != "string") throw new TypeError("encoding must be a string"); if (typeof T == "string" && !a.isEncoding(T)) throw new TypeError("Unknown encoding: " + T); if (l.length === 1) { var P = l.charCodeAt(0); (T === "utf8" && P < 128 || T === "latin1") && (l = P) } } else typeof l == "number" ? l = l & 255 : typeof l == "boolean" && (l = Number(l)); if (u < 0 || this.length < u || this.length < x) throw new RangeError("Out of range index"); if (x <= u) return this; u = u >>> 0, x = x === void 0 ? this.length : x >>> 0, l || (l = 0); var Q; if (typeof l == "number") for (Q = u; Q < x; ++Q)this[Q] = l; else { var le = a.isBuffer(l) ? l : a.from(l, T), de = le.length; if (de === 0) throw new TypeError('The value "' + l + '" is invalid for argument "value"'); for (Q = 0; Q < x - u; ++Q)this[Q + u] = le[Q % de] } return this }; var Ee = /[^+/0-9A-Za-z-_]/g; function Ue(m) { if (m = m.split("=")[0], m = m.trim().replace(Ee, ""), m.length < 2) return ""; for (; m.length % 4 !== 0;)m = m + "="; return m } function fe(m, l) { l = l || 1 / 0; for (var u, x = m.length, T = null, P = [], Q = 0; Q < x; ++Q) { if (u = m.charCodeAt(Q), u > 55295 && u < 57344) { if (!T) { if (u > 56319) { (l -= 3) > -1 && P.push(239, 191, 189); continue } else if (Q + 1 === x) { (l -= 3) > -1 && P.push(239, 191, 189); continue } T = u; continue } if (u < 56320) { (l -= 3) > -1 && P.push(239, 191, 189), T = u; continue } u = (T - 55296 << 10 | u - 56320) + 65536 } else T && (l -= 3) > -1 && P.push(239, 191, 189); if (T = null, u < 128) { if ((l -= 1) < 0) break; P.push(u) } else if (u < 2048) { if ((l -= 2) < 0) break; P.push(u >> 6 | 192, u & 63 | 128) } else if (u < 65536) { if ((l -= 3) < 0) break; P.push(u >> 12 | 224, u >> 6 & 63 | 128, u & 63 | 128) } else if (u < 1114112) { if ((l -= 4) < 0) break; P.push(u >> 18 | 240, u >> 12 & 63 | 128, u >> 6 & 63 | 128, u & 63 | 128) } else throw new Error("Invalid code point") } return P } function ye(m) { for (var l = [], u = 0; u < m.length; ++u)l.push(m.charCodeAt(u) & 255); return l } function A(m, l) { for (var u, x, T, P = [], Q = 0; Q < m.length && !((l -= 2) < 0); ++Q)u = m.charCodeAt(Q), x = u >> 8, T = u % 256, P.push(T), P.push(x); return P } function I(m) { return t.toByteArray(Ue(m)) } function j(m, l, u, x) { for (var T = 0; T < x && !(T + u >= l.length || T >= m.length); ++T)l[T + u] = m[T]; return T } function Z(m, l) { return m instanceof l || m != null && m.constructor != null && m.constructor.name != null && m.constructor.name === l.name } function W(m) { return m !== m } var X = function () { for (var m = "0123456789abcdef", l = new Array(256), u = 0; u < 16; ++u)for (var x = u * 16, T = 0; T < 16; ++T)l[x + T] = m[u] + m[T]; return l }() })(Ro); var Rm = { exports: {} }; (function (e) { (function (t) { var n, r = /^-?(?:\d+(?:\.\d*)?|\.\d+)(?:e[+-]?\d+)?$/i, i = Math.ceil, s = Math.floor, o = "[BigNumber Error] ", a = o + "Number primitive has more than 15 significant digits: ", f = 1e14, h = 14, _ = 9007199254740991, v = [1, 10, 100, 1e3, 1e4, 1e5, 1e6, 1e7, 1e8, 1e9, 1e10, 1e11, 1e12, 1e13], y = 1e7, w = 1e9; function p(C) { var V, Y, re, U = B.prototype = { constructor: B, toString: null, valueOf: null }, K = new B(1), ee = 20, N = 4, F = -7, G = 21, J = -1e7, ie = 1e7, z = !1, D = 1, ae = 0, se = { prefix: "", groupSize: 3, secondaryGroupSize: 0, groupSeparator: ",", decimalSeparator: ".", fractionGroupSize: 0, fractionGroupSeparator: "", suffix: "" }, oe = "0123456789abcdefghijklmnopqrstuvwxyz", Ae = !0; function B(A, I) { var j, Z, W, X, m, l, u, x, T = this; if (!(T instanceof B)) return new B(A, I); if (I == null) { if (A && A._isBigNumber === !0) { T.s = A.s, !A.c || A.e > ie ? T.c = T.e = null : A.e < J ? T.c = [T.e = 0] : (T.e = A.e, T.c = A.c.slice()); return } if ((l = typeof A == "number") && A * 0 == 0) { if (T.s = 1 / A < 0 ? (A = -A, -1) : 1, A === ~~A) { for (X = 0, m = A; m >= 10; m /= 10, X++); X > ie ? T.c = T.e = null : (T.e = X, T.c = [A]); return } x = String(A) } else { if (!r.test(x = String(A))) return re(T, x, l); T.s = x.charCodeAt(0) == 45 ? (x = x.slice(1), -1) : 1 } (X = x.indexOf(".")) > -1 && (x = x.replace(".", "")), (m = x.search(/e/i)) > 0 ? (X < 0 && (X = m), X += +x.slice(m + 1), x = x.substring(0, m)) : X < 0 && (X = x.length) } else { if (E(I, 2, oe.length, "Base"), I == 10 && Ae) return T = new B(A), fe(T, ee + T.e + 1, N); if (x = String(A), l = typeof A == "number") { if (A * 0 != 0) return re(T, x, l, I); if (T.s = 1 / A < 0 ? (x = x.slice(1), -1) : 1, B.DEBUG && x.replace(/^0\.0*|\./, "").length > 15) throw Error(a + A) } else T.s = x.charCodeAt(0) === 45 ? (x = x.slice(1), -1) : 1; for (j = oe.slice(0, I), X = m = 0, u = x.length; m < u; m++)if (j.indexOf(Z = x.charAt(m)) < 0) { if (Z == ".") { if (m > X) { X = u; continue } } else if (!W && (x == x.toUpperCase() && (x = x.toLowerCase()) || x == x.toLowerCase() && (x = x.toUpperCase()))) { W = !0, m = -1, X = 0; continue } return re(T, String(A), l, I) } l = !1, x = Y(x, I, 10, T.s), (X = x.indexOf(".")) > -1 ? x = x.replace(".", "") : X = x.length } for (m = 0; x.charCodeAt(m) === 48; m++); for (u = x.length; x.charCodeAt(--u) === 48;); if (x = x.slice(m, ++u)) { if (u -= m, l && B.DEBUG && u > 15 && (A > _ || A !== s(A))) throw Error(a + T.s * A); if ((X = X - m - 1) > ie) T.c = T.e = null; else if (X < J) T.c = [T.e = 0]; else { if (T.e = X, T.c = [], m = (X + 1) % h, X < 0 && (m += h), m < u) { for (m && T.c.push(+x.slice(0, m)), u -= h; m < u;)T.c.push(+x.slice(m, m += h)); m = h - (x = x.slice(m)).length } else m -= u; for (; m--; x += "0"); T.c.push(+x) } } else T.c = [T.e = 0] } B.clone = p, B.ROUND_UP = 0, B.ROUND_DOWN = 1, B.ROUND_CEIL = 2, B.ROUND_FLOOR = 3, B.ROUND_HALF_UP = 4, B.ROUND_HALF_DOWN = 5, B.ROUND_HALF_EVEN = 6, B.ROUND_HALF_CEIL = 7, B.ROUND_HALF_FLOOR = 8, B.EUCLID = 9, B.config = B.set = function (A) { var I, j; if (A != null) if (typeof A == "object") { if (A.hasOwnProperty(I = "DECIMAL_PLACES") && (j = A[I], E(j, 0, w, I), ee = j), A.hasOwnProperty(I = "ROUNDING_MODE") && (j = A[I], E(j, 0, 8, I), N = j), A.hasOwnProperty(I = "EXPONENTIAL_AT") && (j = A[I], j && j.pop ? (E(j[0], -w, 0, I), E(j[1], 0, w, I), F = j[0], G = j[1]) : (E(j, -w, w, I), F = -(G = j < 0 ? -j : j))), A.hasOwnProperty(I = "RANGE")) if (j = A[I], j && j.pop) E(j[0], -w, -1, I), E(j[1], 1, w, I), J = j[0], ie = j[1]; else if (E(j, -w, w, I), j) J = -(ie = j < 0 ? -j : j); else throw Error(o + I + " cannot be zero: " + j); if (A.hasOwnProperty(I = "CRYPTO")) if (j = A[I], j === !!j) if (j) if (typeof crypto < "u" && crypto && (crypto.getRandomValues || crypto.randomBytes)) z = j; else throw z = !j, Error(o + "crypto unavailable"); else z = j; else throw Error(o + I + " not true or false: " + j); if (A.hasOwnProperty(I = "MODULO_MODE") && (j = A[I], E(j, 0, 9, I), D = j), A.hasOwnProperty(I = "POW_PRECISION") && (j = A[I], E(j, 0, w, I), ae = j), A.hasOwnProperty(I = "FORMAT")) if (j = A[I], typeof j == "object") se = j; else throw Error(o + I + " not an object: " + j); if (A.hasOwnProperty(I = "ALPHABET")) if (j = A[I], typeof j == "string" && !/^.?$|[+\-.\s]|(.).*\1/.test(j)) Ae = j.slice(0, 10) == "0123456789", oe = j; else throw Error(o + I + " invalid: " + j) } else throw Error(o + "Object expected: " + A); return { DECIMAL_PLACES: ee, ROUNDING_MODE: N, EXPONENTIAL_AT: [F, G], RANGE: [J, ie], CRYPTO: z, MODULO_MODE: D, POW_PRECISION: ae, FORMAT: se, ALPHABET: oe } }, B.isBigNumber = function (A) { if (!A || A._isBigNumber !== !0) return !1; if (!B.DEBUG) return !0; var I, j, Z = A.c, W = A.e, X = A.s; e: if ({}.toString.call(Z) == "[object Array]") { if ((X === 1 || X === -1) && W >= -w && W <= w && W === s(W)) { if (Z[0] === 0) { if (W === 0 && Z.length === 1) return !0; break e } if (I = (W + 1) % h, I < 1 && (I += h), String(Z[0]).length == I) { for (I = 0; I < Z.length; I++)if (j = Z[I], j < 0 || j >= f || j !== s(j)) break e; if (j !== 0) return !0 } } } else if (Z === null && W === null && (X === null || X === 1 || X === -1)) return !0; throw Error(o + "Invalid BigNumber: " + A) }, B.maximum = B.max = function () { return Ee(arguments, -1) }, B.minimum = B.min = function () { return Ee(arguments, 1) }, B.random = function () { var A = 9007199254740992, I = Math.random() * A & 2097151 ? function () { return s(Math.random() * A) } : function () { return (Math.random() * 1073741824 | 0) * 8388608 + (Math.random() * 8388608 | 0) }; return function (j) { var Z, W, X, m, l, u = 0, x = [], T = new B(K); if (j == null ? j = ee : E(j, 0, w), m = i(j / h), z) if (crypto.getRandomValues) { for (Z = crypto.getRandomValues(new Uint32Array(m *= 2)); u < m;)l = Z[u] * 131072 + (Z[u + 1] >>> 11), l >= 9e15 ? (W = crypto.getRandomValues(new Uint32Array(2)), Z[u] = W[0], Z[u + 1] = W[1]) : (x.push(l % 1e14), u += 2); u = m / 2 } else if (crypto.randomBytes) { for (Z = crypto.randomBytes(m *= 7); u < m;)l = (Z[u] & 31) * 281474976710656 + Z[u + 1] * 1099511627776 + Z[u + 2] * 4294967296 + Z[u + 3] * 16777216 + (Z[u + 4] << 16) + (Z[u + 5] << 8) + Z[u + 6], l >= 9e15 ? crypto.randomBytes(7).copy(Z, u) : (x.push(l % 1e14), u += 7); u = m / 7 } else throw z = !1, Error(o + "crypto unavailable"); if (!z) for (; u < m;)l = I(), l < 9e15 && (x[u++] = l % 1e14); for (m = x[--u], j %= h, m && j && (l = v[h - j], x[u] = s(m / l) * l); x[u] === 0; x.pop(), u--); if (u < 0) x = [X = 0]; else { for (X = -1; x[0] === 0; x.splice(0, 1), X -= h); for (u = 1, l = x[0]; l >= 10; l /= 10, u++); u < h && (X -= h - u) } return T.e = X, T.c = x, T } }(), B.sum = function () { for (var A = 1, I = arguments, j = new B(I[0]); A < I.length;)j = j.plus(I[A++]); return j }, Y = function () { var A = "0123456789"; function I(j, Z, W, X) { for (var m, l = [0], u, x = 0, T = j.length; x < T;) { for (u = l.length; u--; l[u] *= Z); for (l[0] += X.indexOf(j.charAt(x++)), m = 0; m < l.length; m++)l[m] > W - 1 && (l[m + 1] == null && (l[m + 1] = 0), l[m + 1] += l[m] / W | 0, l[m] %= W) } return l.reverse() } return function (j, Z, W, X, m) { var l, u, x, T, P, Q, le, de, pe = j.indexOf("."), _e = ee, g = N; for (pe >= 0 && (T = ae, ae = 0, j = j.replace(".", ""), de = new B(Z), Q = de.pow(j.length - pe), ae = T, de.c = I(k($(Q.c), Q.e, "0"), 10, W, A), de.e = de.c.length), le = I(j, Z, W, m ? (l = oe, A) : (l = A, oe)), x = T = le.length; le[--T] == 0; le.pop()); if (!le[0]) return l.charAt(0); if (pe < 0 ? --x : (Q.c = le, Q.e = x, Q.s = X, Q = V(Q, de, _e, g, W), le = Q.c, P = Q.r, x = Q.e), u = x + _e + 1, pe = le[u], T = W / 2, P = P || u < 0 || le[u + 1] != null, P = g < 4 ? (pe != null || P) && (g == 0 || g == (Q.s < 0 ? 3 : 2)) : pe > T || pe == T && (g == 4 || P || g == 6 && le[u - 1] & 1 || g == (Q.s < 0 ? 8 : 7)), u < 1 || !le[0]) j = P ? k(l.charAt(1), -_e, l.charAt(0)) : l.charAt(0); else { if (le.length = u, P) for (--W; ++le[--u] > W;)le[u] = 0, u || (++x, le = [1].concat(le)); for (T = le.length; !le[--T];); for (pe = 0, j = ""; pe <= T; j += l.charAt(le[pe++])); j = k(j, x, l.charAt(0)) } return j } }(), V = function () { function A(Z, W, X) { var m, l, u, x, T = 0, P = Z.length, Q = W % y, le = W / y | 0; for (Z = Z.slice(); P--;)u = Z[P] % y, x = Z[P] / y | 0, m = le * u + x * Q, l = Q * u + m % y * y + T, T = (l / X | 0) + (m / y | 0) + le * x, Z[P] = l % X; return T && (Z = [T].concat(Z)), Z } function I(Z, W, X, m) { var l, u; if (X != m) u = X > m ? 1 : -1; else for (l = u = 0; l < X; l++)if (Z[l] != W[l]) { u = Z[l] > W[l] ? 1 : -1; break } return u } function j(Z, W, X, m) { for (var l = 0; X--;)Z[X] -= l, l = Z[X] < W[X] ? 1 : 0, Z[X] = l * m + Z[X] - W[X]; for (; !Z[0] && Z.length > 1; Z.splice(0, 1)); } return function (Z, W, X, m, l) { var u, x, T, P, Q, le, de, pe, _e, g, c, d, R, L, ne, te, xe, be = Z.s == W.s ? 1 : -1, ve = Z.c, we = W.c; if (!ve || !ve[0] || !we || !we[0]) return new B(!Z.s || !W.s || (ve ? we && ve[0] == we[0] : !we) ? NaN : ve && ve[0] == 0 || !we ? be * 0 : be / 0); for (pe = new B(be), _e = pe.c = [], x = Z.e - W.e, be = X + x + 1, l || (l = f, x = O(Z.e / h) - O(W.e / h), be = be / h | 0), T = 0; we[T] == (ve[T] || 0); T++); if (we[T] > (ve[T] || 0) && x--, be < 0) _e.push(1), P = !0; else { for (L = ve.length, te = we.length, T = 0, be += 2, Q = s(l / (we[0] + 1)), Q > 1 && (we = A(we, Q, l), ve = A(ve, Q, l), te = we.length, L = ve.length), R = te, g = ve.slice(0, te), c = g.length; c < te; g[c++] = 0); xe = we.slice(), xe = [0].concat(xe), ne = we[0], we[1] >= l / 2 && ne++; do { if (Q = 0, u = I(we, g, te, c), u < 0) { if (d = g[0], te != c && (d = d * l + (g[1] || 0)), Q = s(d / ne), Q > 1) for (Q >= l && (Q = l - 1), le = A(we, Q, l), de = le.length, c = g.length; I(le, g, de, c) == 1;)Q--, j(le, te < de ? xe : we, de, l), de = le.length, u = 1; else Q == 0 && (u = Q = 1), le = we.slice(), de = le.length; if (de < c && (le = [0].concat(le)), j(g, le, c, l), c = g.length, u == -1) for (; I(we, g, te, c) < 1;)Q++, j(g, te < c ? xe : we, c, l), c = g.length } else u === 0 && (Q++, g = [0]); _e[T++] = Q, g[0] ? g[c++] = ve[R] || 0 : (g = [ve[R]], c = 1) } while ((R++ < L || g[0] != null) && be--); P = g[0] != null, _e[0] || _e.splice(0, 1) } if (l == f) { for (T = 1, be = _e[0]; be >= 10; be /= 10, T++); fe(pe, X + (pe.e = T + x * h - 1) + 1, m, P) } else pe.e = x, pe.r = +P; return pe } }(); function Pe(A, I, j, Z) { var W, X, m, l, u; if (j == null ? j = N : E(j, 0, 8), !A.c) return A.toString(); if (W = A.c[0], m = A.e, I == null) u = $(A.c), u = Z == 1 || Z == 2 && (m <= F || m >= G) ? M(u, m) : k(u, m, "0"); else if (A = fe(new B(A), I, j), X = A.e, u = $(A.c), l = u.length, Z == 1 || Z == 2 && (I <= X || X <= F)) { for (; l < I; u += "0", l++); u = M(u, X) } else if (I -= m + (Z === 2 && X > m), u = k(u, X, "0"), X + 1 > l) { if (--I > 0) for (u += "."; I--; u += "0"); } else if (I += X - l, I > 0) for (X + 1 == l && (u += "."); I--; u += "0"); return A.s < 0 && W ? "-" + u : u } function Ee(A, I) { for (var j, Z, W = 1, X = new B(A[0]); W < A.length; W++)Z = new B(A[W]), (!Z.s || (j = b(X, Z)) === I || j === 0 && X.s === I) && (X = Z); return X } function Ue(A, I, j) { for (var Z = 1, W = I.length; !I[--W]; I.pop()); for (W = I[0]; W >= 10; W /= 10, Z++); return (j = Z + j * h - 1) > ie ? A.c = A.e = null : j < J ? A.c = [A.e = 0] : (A.e = j, A.c = I), A } re = function () { var A = /^(-?)0([xbo])(?=\w[\w.]*$)/i, I = /^([^.]+)\.$/, j = /^\.([^.]+)$/, Z = /^-?(Infinity|NaN)$/, W = /^\s*\+(?=[\w.])|^\s+|\s+$/g; return function (X, m, l, u) { var x, T = l ? m : m.replace(W, ""); if (Z.test(T)) X.s = isNaN(T) ? null : T < 0 ? -1 : 1; else { if (!l && (T = T.replace(A, function (P, Q, le) { return x = (le = le.toLowerCase()) == "x" ? 16 : le == "b" ? 2 : 8, !u || u == x ? Q : P }), u && (x = u, T = T.replace(I, "$1").replace(j, "0.$1")), m != T)) return new B(T, x); if (B.DEBUG) throw Error(o + "Not a" + (u ? " base " + u : "") + " number: " + m); X.s = null } X.c = X.e = null } }(); function fe(A, I, j, Z) { var W, X, m, l, u, x, T, P = A.c, Q = v; if (P) { e: { for (W = 1, l = P[0]; l >= 10; l /= 10, W++); if (X = I - W, X < 0) X += h, m = I, u = P[x = 0], T = s(u / Q[W - m - 1] % 10); else if (x = i((X + 1) / h), x >= P.length) if (Z) { for (; P.length <= x; P.push(0)); u = T = 0, W = 1, X %= h, m = X - h + 1 } else break e; else { for (u = l = P[x], W = 1; l >= 10; l /= 10, W++); X %= h, m = X - h + W, T = m < 0 ? 0 : s(u / Q[W - m - 1] % 10) } if (Z = Z || I < 0 || P[x + 1] != null || (m < 0 ? u : u % Q[W - m - 1]), Z = j < 4 ? (T || Z) && (j == 0 || j == (A.s < 0 ? 3 : 2)) : T > 5 || T == 5 && (j == 4 || Z || j == 6 && (X > 0 ? m > 0 ? u / Q[W - m] : 0 : P[x - 1]) % 10 & 1 || j == (A.s < 0 ? 8 : 7)), I < 1 || !P[0]) return P.length = 0, Z ? (I -= A.e + 1, P[0] = Q[(h - I % h) % h], A.e = -I || 0) : P[0] = A.e = 0, A; if (X == 0 ? (P.length = x, l = 1, x--) : (P.length = x + 1, l = Q[h - X], P[x] = m > 0 ? s(u / Q[W - m] % Q[m]) * l : 0), Z) for (; ;)if (x == 0) { for (X = 1, m = P[0]; m >= 10; m /= 10, X++); for (m = P[0] += l, l = 1; m >= 10; m /= 10, l++); X != l && (A.e++, P[0] == f && (P[0] = 1)); break } else { if (P[x] += l, P[x] != f) break; P[x--] = 0, l = 1 } for (X = P.length; P[--X] === 0; P.pop()); } A.e > ie ? A.c = A.e = null : A.e < J && (A.c = [A.e = 0]) } return A } function ye(A) { var I, j = A.e; return j === null ? A.toString() : (I = $(A.c), I = j <= F || j >= G ? M(I, j) : k(I, j, "0"), A.s < 0 ? "-" + I : I) } return U.absoluteValue = U.abs = function () { var A = new B(this); return A.s < 0 && (A.s = 1), A }, U.comparedTo = function (A, I) { return b(this, new B(A, I)) }, U.decimalPlaces = U.dp = function (A, I) { var j, Z, W, X = this; if (A != null) return E(A, 0, w), I == null ? I = N : E(I, 0, 8), fe(new B(X), A + X.e + 1, I); if (!(j = X.c)) return null; if (Z = ((W = j.length - 1) - O(this.e / h)) * h, W = j[W]) for (; W % 10 == 0; W /= 10, Z--); return Z < 0 && (Z = 0), Z }, U.dividedBy = U.div = function (A, I) { return V(this, new B(A, I), ee, N) }, U.dividedToIntegerBy = U.idiv = function (A, I) { return V(this, new B(A, I), 0, 1) }, U.exponentiatedBy = U.pow = function (A, I) { var j, Z, W, X, m, l, u, x, T, P = this; if (A = new B(A), A.c && !A.isInteger()) throw Error(o + "Exponent not an integer: " + ye(A)); if (I != null && (I = new B(I)), l = A.e > 14, !P.c || !P.c[0] || P.c[0] == 1 && !P.e && P.c.length == 1 || !A.c || !A.c[0]) return T = new B(Math.pow(+ye(P), l ? A.s * (2 - S(A)) : +ye(A))), I ? T.mod(I) : T; if (u = A.s < 0, I) { if (I.c ? !I.c[0] : !I.s) return new B(NaN); Z = !u && P.isInteger() && I.isInteger(), Z && (P = P.mod(I)) } else { if (A.e > 9 && (P.e > 0 || P.e < -1 || (P.e == 0 ? P.c[0] > 1 || l && P.c[1] >= 24e7 : P.c[0] < 8e13 || l && P.c[0] <= 9999975e7))) return X = P.s < 0 && S(A) ? -0 : 0, P.e > -1 && (X = 1 / X), new B(u ? 1 / X : X); ae && (X = i(ae / h + 2)) } for (l ? (j = new B(.5), u && (A.s = 1), x = S(A)) : (W = Math.abs(+ye(A)), x = W % 2), T = new B(K); ;) { if (x) { if (T = T.times(P), !T.c) break; X ? T.c.length > X && (T.c.length = X) : Z && (T = T.mod(I)) } if (W) { if (W = s(W / 2), W === 0) break; x = W % 2 } else if (A = A.times(j), fe(A, A.e + 1, 1), A.e > 14) x = S(A); else { if (W = +ye(A), W === 0) break; x = W % 2 } P = P.times(P), X ? P.c && P.c.length > X && (P.c.length = X) : Z && (P = P.mod(I)) } return Z ? T : (u && (T = K.div(T)), I ? T.mod(I) : X ? fe(T, ae, N, m) : T) }, U.integerValue = function (A) { var I = new B(this); return A == null ? A = N : E(A, 0, 8), fe(I, I.e + 1, A) }, U.isEqualTo = U.eq = function (A, I) { return b(this, new B(A, I)) === 0 }, U.isFinite = function () { return !!this.c }, U.isGreaterThan = U.gt = function (A, I) { return b(this, new B(A, I)) > 0 }, U.isGreaterThanOrEqualTo = U.gte = function (A, I) { return (I = b(this, new B(A, I))) === 1 || I === 0 }, U.isInteger = function () { return !!this.c && O(this.e / h) > this.c.length - 2 }, U.isLessThan = U.lt = function (A, I) { return b(this, new B(A, I)) < 0 }, U.isLessThanOrEqualTo = U.lte = function (A, I) { return (I = b(this, new B(A, I))) === -1 || I === 0 }, U.isNaN = function () { return !this.s }, U.isNegative = function () { return this.s < 0 }, U.isPositive = function () { return this.s > 0 }, U.isZero = function () { return !!this.c && this.c[0] == 0 }, U.minus = function (A, I) { var j, Z, W, X, m = this, l = m.s; if (A = new B(A, I), I = A.s, !l || !I) return new B(NaN); if (l != I) return A.s = -I, m.plus(A); var u = m.e / h, x = A.e / h, T = m.c, P = A.c; if (!u || !x) { if (!T || !P) return T ? (A.s = -I, A) : new B(P ? m : NaN); if (!T[0] || !P[0]) return P[0] ? (A.s = -I, A) : new B(T[0] ? m : N == 3 ? -0 : 0) } if (u = O(u), x = O(x), T = T.slice(), l = u - x) { for ((X = l < 0) ? (l = -l, W = T) : (x = u, W = P), W.reverse(), I = l; I--; W.push(0)); W.reverse() } else for (Z = (X = (l = T.length) < (I = P.length)) ? l : I, l = I = 0; I < Z; I++)if (T[I] != P[I]) { X = T[I] < P[I]; break } if (X && (W = T, T = P, P = W, A.s = -A.s), I = (Z = P.length) - (j = T.length), I > 0) for (; I--; T[j++] = 0); for (I = f - 1; Z > l;) { if (T[--Z] < P[Z]) { for (j = Z; j && !T[--j]; T[j] = I); --T[j], T[Z] += f } T[Z] -= P[Z] } for (; T[0] == 0; T.splice(0, 1), --x); return T[0] ? Ue(A, T, x) : (A.s = N == 3 ? -1 : 1, A.c = [A.e = 0], A) }, U.modulo = U.mod = function (A, I) { var j, Z, W = this; return A = new B(A, I), !W.c || !A.s || A.c && !A.c[0] ? new B(NaN) : !A.c || W.c && !W.c[0] ? new B(W) : (D == 9 ? (Z = A.s, A.s = 1, j = V(W, A, 0, 3), A.s = Z, j.s *= Z) : j = V(W, A, 0, D), A = W.minus(j.times(A)), !A.c[0] && D == 1 && (A.s = W.s), A) }, U.multipliedBy = U.times = function (A, I) { var j, Z, W, X, m, l, u, x, T, P, Q, le, de, pe, _e, g = this, c = g.c, d = (A = new B(A, I)).c; if (!c || !d || !c[0] || !d[0]) return !g.s || !A.s || c && !c[0] && !d || d && !d[0] && !c ? A.c = A.e = A.s = null : (A.s *= g.s, !c || !d ? A.c = A.e = null : (A.c = [0], A.e = 0)), A; for (Z = O(g.e / h) + O(A.e / h), A.s *= g.s, u = c.length, P = d.length, u < P && (de = c, c = d, d = de, W = u, u = P, P = W), W = u + P, de = []; W--; de.push(0)); for (pe = f, _e = y, W = P; --W >= 0;) { for (j = 0, Q = d[W] % _e, le = d[W] / _e | 0, m = u, X = W + m; X > W;)x = c[--m] % _e, T = c[m] / _e | 0, l = le * x + T * Q, x = Q * x + l % _e * _e + de[X] + j, j = (x / pe | 0) + (l / _e | 0) + le * T, de[X--] = x % pe; de[X] = j } return j ? ++Z : de.splice(0, 1), Ue(A, de, Z) }, U.negated = function () { var A = new B(this); return A.s = -A.s || null, A }, U.plus = function (A, I) { var j, Z = this, W = Z.s; if (A = new B(A, I), I = A.s, !W || !I) return new B(NaN); if (W != I) return A.s = -I, Z.minus(A); var X = Z.e / h, m = A.e / h, l = Z.c, u = A.c; if (!X || !m) { if (!l || !u) return new B(W / 0); if (!l[0] || !u[0]) return u[0] ? A : new B(l[0] ? Z : W * 0) } if (X = O(X), m = O(m), l = l.slice(), W = X - m) { for (W > 0 ? (m = X, j = u) : (W = -W, j = l), j.reverse(); W--; j.push(0)); j.reverse() } for (W = l.length, I = u.length, W - I < 0 && (j = u, u = l, l = j, I = W), W = 0; I;)W = (l[--I] = l[I] + u[I] + W) / f | 0, l[I] = f === l[I] ? 0 : l[I] % f; return W && (l = [W].concat(l), ++m), Ue(A, l, m) }, U.precision = U.sd = function (A, I) { var j, Z, W, X = this; if (A != null && A !== !!A) return E(A, 1, w), I == null ? I = N : E(I, 0, 8), fe(new B(X), A, I); if (!(j = X.c)) return null; if (W = j.length - 1, Z = W * h + 1, W = j[W]) { for (; W % 10 == 0; W /= 10, Z--); for (W = j[0]; W >= 10; W /= 10, Z++); } return A && X.e + 1 > Z && (Z = X.e + 1), Z }, U.shiftedBy = function (A) { return E(A, -_, _), this.times("1e" + A) }, U.squareRoot = U.sqrt = function () { var A, I, j, Z, W, X = this, m = X.c, l = X.s, u = X.e, x = ee + 4, T = new B("0.5"); if (l !== 1 || !m || !m[0]) return new B(!l || l < 0 && (!m || m[0]) ? NaN : m ? X : 1 / 0); if (l = Math.sqrt(+ye(X)), l == 0 || l == 1 / 0 ? (I = $(m), (I.length + u) % 2 == 0 && (I += "0"), l = Math.sqrt(+I), u = O((u + 1) / 2) - (u < 0 || u % 2), l == 1 / 0 ? I = "5e" + u : (I = l.toExponential(), I = I.slice(0, I.indexOf("e") + 1) + u), j = new B(I)) : j = new B(l + ""), j.c[0]) { for (u = j.e, l = u + x, l < 3 && (l = 0); ;)if (W = j, j = T.times(W.plus(V(X, W, x, 1))), $(W.c).slice(0, l) === (I = $(j.c)).slice(0, l)) if (j.e < u && --l, I = I.slice(l - 3, l + 1), I == "9999" || !Z && I == "4999") { if (!Z && (fe(W, W.e + ee + 2, 0), W.times(W).eq(X))) { j = W; break } x += 4, l += 4, Z = 1 } else { (!+I || !+I.slice(1) && I.charAt(0) == "5") && (fe(j, j.e + ee + 2, 1), A = !j.times(j).eq(X)); break } } return fe(j, j.e + ee + 1, N, A) }, U.toExponential = function (A, I) { return A != null && (E(A, 0, w), A++), Pe(this, A, I, 1) }, U.toFixed = function (A, I) { return A != null && (E(A, 0, w), A = A + this.e + 1), Pe(this, A, I) }, U.toFormat = function (A, I, j) { var Z, W = this; if (j == null) A != null && I && typeof I == "object" ? (j = I, I = null) : A && typeof A == "object" ? (j = A, A = I = null) : j = se; else if (typeof j != "object") throw Error(o + "Argument not an object: " + j); if (Z = W.toFixed(A, I), W.c) { var X, m = Z.split("."), l = +j.groupSize, u = +j.secondaryGroupSize, x = j.groupSeparator || "", T = m[0], P = m[1], Q = W.s < 0, le = Q ? T.slice(1) : T, de = le.length; if (u && (X = l, l = u, u = X, de -= X), l > 0 && de > 0) { for (X = de % l || l, T = le.substr(0, X); X < de; X += l)T += x + le.substr(X, l); u > 0 && (T += x + le.slice(X)), Q && (T = "-" + T) } Z = P ? T + (j.decimalSeparator || "") + ((u = +j.fractionGroupSize) ? P.replace(new RegExp("\\d{" + u + "}\\B", "g"), "$&" + (j.fractionGroupSeparator || "")) : P) : T } return (j.prefix || "") + Z + (j.suffix || "") }, U.toFraction = function (A) { var I, j, Z, W, X, m, l, u, x, T, P, Q, le = this, de = le.c; if (A != null && (l = new B(A), !l.isInteger() && (l.c || l.s !== 1) || l.lt(K))) throw Error(o + "Argument " + (l.isInteger() ? "out of range: " : "not an integer: ") + ye(l)); if (!de) return new B(le); for (I = new B(K), x = j = new B(K), Z = u = new B(K), Q = $(de), X = I.e = Q.length - le.e - 1, I.c[0] = v[(m = X % h) < 0 ? h + m : m], A = !A || l.comparedTo(I) > 0 ? X > 0 ? I : x : l, m = ie, ie = 1 / 0, l = new B(Q), u.c[0] = 0; T = V(l, I, 0, 1), W = j.plus(T.times(Z)), W.comparedTo(A) != 1;)j = Z, Z = W, x = u.plus(T.times(W = x)), u = W, I = l.minus(T.times(W = I)), l = W; return W = V(A.minus(j), Z, 0, 1), u = u.plus(W.times(x)), j = j.plus(W.times(Z)), u.s = x.s = le.s, X = X * 2, P = V(x, Z, X, N).minus(le).abs().comparedTo(V(u, j, X, N).minus(le).abs()) < 1 ? [x, Z] : [u, j], ie = m, P }, U.toNumber = function () { return +ye(this) }, U.toPrecision = function (A, I) { return A != null && E(A, 1, w), Pe(this, A, I, 2) }, U.toString = function (A) { var I, j = this, Z = j.s, W = j.e; return W === null ? Z ? (I = "Infinity", Z < 0 && (I = "-" + I)) : I = "NaN" : (A == null ? I = W <= F || W >= G ? M($(j.c), W) : k($(j.c), W, "0") : A === 10 && Ae ? (j = fe(new B(j), ee + W + 1, N), I = k($(j.c), j.e, "0")) : (E(A, 2, oe.length, "Base"), I = Y(k($(j.c), W, "0"), 10, A, Z, !0)), Z < 0 && j.c[0] && (I = "-" + I)), I }, U.valueOf = U.toJSON = function () { return ye(this) }, U._isBigNumber = !0, C != null && B.set(C), B } function O(C) { var V = C | 0; return C > 0 || C === V ? V : V - 1 } function $(C) { for (var V, Y, re = 1, U = C.length, K = C[0] + ""; re < U;) { for (V = C[re++] + "", Y = h - V.length; Y--; V = "0" + V); K += V } for (U = K.length; K.charCodeAt(--U) === 48;); return K.slice(0, U + 1 || 1) } function b(C, V) { var Y, re, U = C.c, K = V.c, ee = C.s, N = V.s, F = C.e, G = V.e; if (!ee || !N) return null; if (Y = U && !U[0], re = K && !K[0], Y || re) return Y ? re ? 0 : -N : ee; if (ee != N) return ee; if (Y = ee < 0, re = F == G, !U || !K) return re ? 0 : !U ^ Y ? 1 : -1; if (!re) return F > G ^ Y ? 1 : -1; for (N = (F = U.length) < (G = K.length) ? F : G, ee = 0; ee < N; ee++)if (U[ee] != K[ee]) return U[ee] > K[ee] ^ Y ? 1 : -1; return F == G ? 0 : F > G ^ Y ? 1 : -1 } function E(C, V, Y, re) { if (C < V || C > Y || C !== s(C)) throw Error(o + (re || "Argument") + (typeof C == "number" ? C < V || C > Y ? " out of range: " : " not an integer: " : " not a primitive number: ") + String(C)) } function S(C) { var V = C.c.length - 1; return O(C.e / h) == V && C.c[V] % 2 != 0 } function M(C, V) { return (C.length > 1 ? C.charAt(0) + "." + C.slice(1) : C) + (V < 0 ? "e" : "e+") + V } function k(C, V, Y) { var re, U; if (V < 0) { for (U = Y + "."; ++V; U += Y); C = U + C } else if (re = C.length, ++V > re) { for (U = Y, V -= re; --V; U += Y); C += U } else V < re && (C = C.slice(0, V) + "." + C.slice(V)); return C } n = p(), n.default = n.BigNumber = n, e.exports ? e.exports = n : (t || (t = typeof self < "u" && self ? self : window), t.BigNumber = n) })(ns) })(Rm); var Hl = Rm.exports, Sx = function (t, n, r) { var i = new t.Uint8Array(r), s = n.pushInt, o = n.pushInt32, a = n.pushInt32Neg, f = n.pushInt64, h = n.pushInt64Neg, _ = n.pushFloat, v = n.pushFloatSingle, y = n.pushFloatDouble, w = n.pushTrue, p = n.pushFalse, O = n.pushUndefined, $ = n.pushNull, b = n.pushInfinity, E = n.pushInfinityNeg, S = n.pushNaN, M = n.pushNaNNeg, k = n.pushArrayStart, C = n.pushArrayStartFixed, V = n.pushArrayStartFixed32, Y = n.pushArrayStartFixed64, re = n.pushObjectStart, U = n.pushObjectStartFixed, K = n.pushObjectStartFixed32, ee = n.pushObjectStartFixed64, N = n.pushByteString, F = n.pushByteStringStart, G = n.pushUtf8String, J = n.pushUtf8StringStart, ie = n.pushSimpleUnassigned, z = n.pushTagStart, D = n.pushTagStart4, ae = n.pushTagStart8, se = n.pushTagUnassigned, oe = n.pushBreak, Ae = t.Math.pow, B = 0, Pe = 0, Ee = 0; function Ue(q) { for (q = q | 0, B = 0, Pe = q; (B | 0) < (Pe | 0) && (Ee = Dy[i[B] & 255](i[B] | 0) | 0, !((Ee | 0) > 0));); return Ee | 0 } function fe(q) { return q = q | 0, ((B | 0) + (q | 0) | 0) < (Pe | 0) ? 0 : 1 } function ye(q) { return q = q | 0, i[q | 0] << 8 | i[q + 1 | 0] | 0 } function A(q) { return q = q | 0, i[q | 0] << 24 | i[q + 1 | 0] << 16 | i[q + 2 | 0] << 8 | i[q + 3 | 0] | 0 } function I(q) { return q = q | 0, s(q | 0), B = B + 1 | 0, 0 } function j(q) { return q = q | 0, fe(1) | 0 ? 1 : (s(i[B + 1 | 0] | 0), B = B + 2 | 0, 0) } function Z(q) { return q = q | 0, fe(2) | 0 ? 1 : (s(ye(B + 1 | 0) | 0), B = B + 3 | 0, 0) } function W(q) { return q = q | 0, fe(4) | 0 ? 1 : (o(ye(B + 1 | 0) | 0, ye(B + 3 | 0) | 0), B = B + 5 | 0, 0) } function X(q) { return q = q | 0, fe(8) | 0 ? 1 : (f(ye(B + 1 | 0) | 0, ye(B + 3 | 0) | 0, ye(B + 5 | 0) | 0, ye(B + 7 | 0) | 0), B = B + 9 | 0, 0) } function m(q) { return q = q | 0, s(-1 - (q - 32 | 0) | 0), B = B + 1 | 0, 0 } function l(q) { return q = q | 0, fe(1) | 0 ? 1 : (s(-1 - (i[B + 1 | 0] | 0) | 0), B = B + 2 | 0, 0) } function u(q) { q = q | 0; var ke = 0; return fe(2) | 0 ? 1 : (ke = ye(B + 1 | 0) | 0, s(-1 - (ke | 0) | 0), B = B + 3 | 0, 0) } function x(q) { return q = q | 0, fe(4) | 0 ? 1 : (a(ye(B + 1 | 0) | 0, ye(B + 3 | 0) | 0), B = B + 5 | 0, 0) } function T(q) { return q = q | 0, fe(8) | 0 ? 1 : (h(ye(B + 1 | 0) | 0, ye(B + 3 | 0) | 0, ye(B + 5 | 0) | 0, ye(B + 7 | 0) | 0), B = B + 9 | 0, 0) } function P(q) { q = q | 0; var ke = 0, Re = 0, Te = 0; return Te = q - 64 | 0, fe(Te | 0) | 0 ? 1 : (ke = B + 1 | 0, Re = (B + 1 | 0) + (Te | 0) | 0, N(ke | 0, Re | 0), B = Re | 0, 0) } function Q(q) { q = q | 0; var ke = 0, Re = 0, Te = 0; return fe(1) | 0 || (Te = i[B + 1 | 0] | 0, ke = B + 2 | 0, Re = (B + 2 | 0) + (Te | 0) | 0, fe(Te + 1 | 0) | 0) ? 1 : (N(ke | 0, Re | 0), B = Re | 0, 0) } function le(q) { q = q | 0; var ke = 0, Re = 0, Te = 0; return fe(2) | 0 || (Te = ye(B + 1 | 0) | 0, ke = B + 3 | 0, Re = (B + 3 | 0) + (Te | 0) | 0, fe(Te + 2 | 0) | 0) ? 1 : (N(ke | 0, Re | 0), B = Re | 0, 0) } function de(q) { q = q | 0; var ke = 0, Re = 0, Te = 0; return fe(4) | 0 || (Te = A(B + 1 | 0) | 0, ke = B + 5 | 0, Re = (B + 5 | 0) + (Te | 0) | 0, fe(Te + 4 | 0) | 0) ? 1 : (N(ke | 0, Re | 0), B = Re | 0, 0) } function pe(q) { return q = q | 0, 1 } function _e(q) { return q = q | 0, F(), B = B + 1 | 0, 0 } function g(q) { q = q | 0; var ke = 0, Re = 0, Te = 0; return Te = q - 96 | 0, fe(Te | 0) | 0 ? 1 : (ke = B + 1 | 0, Re = (B + 1 | 0) + (Te | 0) | 0, G(ke | 0, Re | 0), B = Re | 0, 0) } function c(q) { q = q | 0; var ke = 0, Re = 0, Te = 0; return fe(1) | 0 || (Te = i[B + 1 | 0] | 0, ke = B + 2 | 0, Re = (B + 2 | 0) + (Te | 0) | 0, fe(Te + 1 | 0) | 0) ? 1 : (G(ke | 0, Re | 0), B = Re | 0, 0) } function d(q) { q = q | 0; var ke = 0, Re = 0, Te = 0; return fe(2) | 0 || (Te = ye(B + 1 | 0) | 0, ke = B + 3 | 0, Re = (B + 3 | 0) + (Te | 0) | 0, fe(Te + 2 | 0) | 0) ? 1 : (G(ke | 0, Re | 0), B = Re | 0, 0) } function R(q) { q = q | 0; var ke = 0, Re = 0, Te = 0; return fe(4) | 0 || (Te = A(B + 1 | 0) | 0, ke = B + 5 | 0, Re = (B + 5 | 0) + (Te | 0) | 0, fe(Te + 4 | 0) | 0) ? 1 : (G(ke | 0, Re | 0), B = Re | 0, 0) } function L(q) { return q = q | 0, 1 } function ne(q) { return q = q | 0, J(), B = B + 1 | 0, 0 } function te(q) { return q = q | 0, C(q - 128 | 0), B = B + 1 | 0, 0 } function xe(q) { return q = q | 0, fe(1) | 0 ? 1 : (C(i[B + 1 | 0] | 0), B = B + 2 | 0, 0) } function be(q) { return q = q | 0, fe(2) | 0 ? 1 : (C(ye(B + 1 | 0) | 0), B = B + 3 | 0, 0) } function ve(q) { return q = q | 0, fe(4) | 0 ? 1 : (V(ye(B + 1 | 0) | 0, ye(B + 3 | 0) | 0), B = B + 5 | 0, 0) } function we(q) { return q = q | 0, fe(8) | 0 ? 1 : (Y(ye(B + 1 | 0) | 0, ye(B + 3 | 0) | 0, ye(B + 5 | 0) | 0, ye(B + 7 | 0) | 0), B = B + 9 | 0, 0) } function Oe(q) { return q = q | 0, k(), B = B + 1 | 0, 0 } function ze(q) { q = q | 0; var ke = 0; return ke = q - 160 | 0, fe(ke | 0) | 0 ? 1 : (U(ke | 0), B = B + 1 | 0, 0) } function tu(q) { return q = q | 0, fe(1) | 0 ? 1 : (U(i[B + 1 | 0] | 0), B = B + 2 | 0, 0) } function nu(q) { return q = q | 0, fe(2) | 0 ? 1 : (U(ye(B + 1 | 0) | 0), B = B + 3 | 0, 0) } function ru(q) { return q = q | 0, fe(4) | 0 ? 1 : (K(ye(B + 1 | 0) | 0, ye(B + 3 | 0) | 0), B = B + 5 | 0, 0) } function iu(q) { return q = q | 0, fe(8) | 0 ? 1 : (ee(ye(B + 1 | 0) | 0, ye(B + 3 | 0) | 0, ye(B + 5 | 0) | 0, ye(B + 7 | 0) | 0), B = B + 9 | 0, 0) } function su(q) { return q = q | 0, re(), B = B + 1 | 0, 0 } function ur(q) { return q = q | 0, z(q - 192 | 0 | 0), B = B + 1 | 0, 0 } function v8(q) { return q = q | 0, z(q | 0), B = B + 1 | 0, 0 } function _8(q) { return q = q | 0, z(q | 0), B = B + 1 | 0, 0 } function E8(q) { return q = q | 0, z(q | 0), B = B + 1 | 0, 0 } function b8(q) { return q = q | 0, z(q | 0), B = B + 1 | 0, 0 } function ut(q) { return q = q | 0, z(q - 192 | 0 | 0), B = B + 1 | 0, 0 } function S8(q) { return q = q | 0, z(q | 0), B = B + 1 | 0, 0 } function N8(q) { return q = q | 0, z(q | 0), B = B + 1 | 0, 0 } function T8(q) { return q = q | 0, z(q | 0), B = B + 1 | 0, 0 } function $y(q) { return q = q | 0, fe(1) | 0 ? 1 : (z(i[B + 1 | 0] | 0), B = B + 2 | 0, 0) } function zy(q) { return q = q | 0, fe(2) | 0 ? 1 : (z(ye(B + 1 | 0) | 0), B = B + 3 | 0, 0) } function Vy(q) { return q = q | 0, fe(4) | 0 ? 1 : (D(ye(B + 1 | 0) | 0, ye(B + 3 | 0) | 0), B = B + 5 | 0, 0) } function qy(q) { return q = q | 0, fe(8) | 0 ? 1 : (ae(ye(B + 1 | 0) | 0, ye(B + 3 | 0) | 0, ye(B + 5 | 0) | 0, ye(B + 7 | 0) | 0), B = B + 9 | 0, 0) } function tt(q) { return q = q | 0, ie((q | 0) - 224 | 0), B = B + 1 | 0, 0 } function Hy(q) { return q = q | 0, p(), B = B + 1 | 0, 0 } function Gy(q) { return q = q | 0, w(), B = B + 1 | 0, 0 } function Ly(q) { return q = q | 0, $(), B = B + 1 | 0, 0 } function Wy(q) { return q = q | 0, O(), B = B + 1 | 0, 0 } function Yy(q) { return q = q | 0, fe(1) | 0 ? 1 : (ie(i[B + 1 | 0] | 0), B = B + 2 | 0, 0) } function Ky(q) { q = q | 0; var ke = 0, Re = 0, Te = 1, Fo = 0, vs = 0, B8 = 0; return fe(2) | 0 ? 1 : (ke = i[B + 1 | 0] | 0, Re = i[B + 2 | 0] | 0, (ke | 0) & 128 && (Te = -1), Fo = +(((ke | 0) & 124) >> 2), vs = +(((ke | 0) & 3) << 8 | Re), +Fo == 0 ? _(+(+Te * 5960464477539063e-23 * +vs)) : +Fo == 31 ? +Te == 1 ? +vs > 0 ? S() : b() : +vs > 0 ? M() : E() : _(+(+Te * Ae(2, +(+Fo - 25)) * +(1024 + vs))), B = B + 3 | 0, 0) } function Zy(q) { return q = q | 0, fe(4) | 0 ? 1 : (v(i[B + 1 | 0] | 0, i[B + 2 | 0] | 0, i[B + 3 | 0] | 0, i[B + 4 | 0] | 0), B = B + 5 | 0, 0) } function Xy(q) { return q = q | 0, fe(8) | 0 ? 1 : (y(i[B + 1 | 0] | 0, i[B + 2 | 0] | 0, i[B + 3 | 0] | 0, i[B + 4 | 0] | 0, i[B + 5 | 0] | 0, i[B + 6 | 0] | 0, i[B + 7 | 0] | 0, i[B + 8 | 0] | 0), B = B + 9 | 0, 0) } function je(q) { return q = q | 0, 1 } function Qy(q) { return q = q | 0, oe(), B = B + 1 | 0, 0 } var Dy = [I, I, I, I, I, I, I, I, I, I, I, I, I, I, I, I, I, I, I, I, I, I, I, I, j, Z, W, X, je, je, je, je, m, m, m, m, m, m, m, m, m, m, m, m, m, m, m, m, m, m, m, m, m, m, m, m, l, u, x, T, je, je, je, je, P, P, P, P, P, P, P, P, P, P, P, P, P, P, P, P, P, P, P, P, P, P, P, P, Q, le, de, pe, je, je, je, _e, g, g, g, g, g, g, g, g, g, g, g, g, g, g, g, g, g, g, g, g, g, g, g, g, c, d, R, L, je, je, je, ne, te, te, te, te, te, te, te, te, te, te, te, te, te, te, te, te, te, te, te, te, te, te, te, te, xe, be, ve, we, je, je, je, Oe, ze, ze, ze, ze, ze, ze, ze, ze, ze, ze, ze, ze, ze, ze, ze, ze, ze, ze, ze, ze, ze, ze, ze, ze, tu, nu, ru, iu, je, je, je, su, ur, ur, ur, ur, ur, ur, ut, ut, ut, ut, ut, ut, ut, ut, ut, ut, ut, ut, ut, ut, ut, ut, ut, ut, $y, zy, Vy, qy, je, je, je, je, tt, tt, tt, tt, tt, tt, tt, tt, tt, tt, tt, tt, tt, tt, tt, tt, tt, tt, tt, tt, Hy, Gy, Ly, Wy, Yy, Ky, Zy, Xy, je, je, je, Qy]; return { parse: Ue } }, Gl = {}, Ot = {}; const cd = Hl.BigNumber; Ot.MT = { POS_INT: 0, NEG_INT: 1, BYTE_STRING: 2, UTF8_STRING: 3, ARRAY: 4, MAP: 5, TAG: 6, SIMPLE_FLOAT: 7 }; Ot.TAG = { DATE_STRING: 0, DATE_EPOCH: 1, POS_BIGINT: 2, NEG_BIGINT: 3, DECIMAL_FRAC: 4, BIGFLOAT: 5, BASE64URL_EXPECTED: 21, BASE64_EXPECTED: 22, BASE16_EXPECTED: 23, CBOR: 24, URI: 32, BASE64URL: 33, BASE64: 34, REGEXP: 35, MIME: 36 }; Ot.NUMBYTES = { ZERO: 0, ONE: 24, TWO: 25, FOUR: 26, EIGHT: 27, INDEFINITE: 31 }; Ot.SIMPLE = { FALSE: 20, TRUE: 21, NULL: 22, UNDEFINED: 23 }; Ot.SYMS = { NULL: Symbol("null"), UNDEFINED: Symbol("undef"), PARENT: Symbol("parent"), BREAK: Symbol("break"), STREAM: Symbol("stream") }; Ot.SHIFT32 = Math.pow(2, 32); Ot.SHIFT16 = Math.pow(2, 16); Ot.MAX_SAFE_HIGH = 2097151; Ot.NEG_ONE = new cd(-1); Ot.TEN = new cd(10); Ot.TWO = new cd(2); Ot.PARENT = { ARRAY: 0, OBJECT: 1, MAP: 2, TAG: 3, BYTE_STRING: 4, UTF8_STRING: 5 }; (function (e) { const { Buffer: t } = Ro, n = Hl.BigNumber, r = Ot, i = r.SHIFT32, s = r.SHIFT16, o = 2097151; e.parseHalf = function (h) { var _, v, y; return y = h[0] & 128 ? -1 : 1, _ = (h[0] & 124) >> 2, v = (h[0] & 3) << 8 | h[1], _ ? _ === 31 ? y * (v ? NaN : 1 / 0) : y * Math.pow(2, _ - 25) * (1024 + v) : y * 5960464477539063e-23 * v }; function a(f) { return f < 16 ? "0" + f.toString(16) : f.toString(16) } e.arrayBufferToBignumber = function (f) { const h = f.byteLength; let _ = ""; for (let v = 0; v < h; v++)_ += a(f[v]); return new n(_, 16) }, e.buildMap = f => { const h = new Map, _ = Object.keys(f), v = _.length; for (let y = 0; y < v; y++)h.set(_[y], f[_[y]]); return h }, e.buildInt32 = (f, h) => f * s + h, e.buildInt64 = (f, h, _, v) => { const y = e.buildInt32(f, h), w = e.buildInt32(_, v); return y > o ? new n(y).times(i).plus(w) : y * i + w }, e.writeHalf = function (h, _) { const v = t.allocUnsafe(4); v.writeFloatBE(_, 0); const y = v.readUInt32BE(0); if (y & 8191) return !1; var w = y >> 16 & 32768; const p = y >> 23 & 255, O = y & 8388607; if (p >= 113 && p <= 142) w += (p - 112 << 10) + (O >> 13); else if (p >= 103 && p < 113) { if (O & (1 << 126 - p) - 1) return !1; w += O + 8388608 >> 126 - p } else return !1; return h.writeUInt16BE(w, 0), !0 }, e.keySorter = function (f, h) { var _ = f[0].byteLength, v = h[0].byteLength; return _ > v ? 1 : v > _ ? -1 : f[0].compare(h[0]) }, e.isNegativeZero = f => f === 0 && 1 / f < 0, e.nextPowerOf2 = f => { let h = 0; if (f && !(f & f - 1)) return f; for (; f !== 0;)f >>= 1, h += 1; return 1 << h } })(Gl); const fd = Ot, Nx = fd.MT, na = fd.SIMPLE, Cu = fd.SYMS; let Tx = class Zc { constructor(t) { if (typeof t != "number") throw new Error("Invalid Simple type: " + typeof t); if (t < 0 || t > 255 || (t | 0) !== t) throw new Error("value must be a small positive integer: " + t); this.value = t } toString() { return "simple(" + this.value + ")" } inspect() { return "simple(" + this.value + ")" } encodeCBOR(t) { return t._pushInt(this.value, Nx.SIMPLE_FLOAT) } static isSimple(t) { return t instanceof Zc } static decode(t, n) { switch (n == null && (n = !0), t) { case na.FALSE: return !1; case na.TRUE: return !0; case na.NULL: return n ? null : Cu.NULL; case na.UNDEFINED: return n ? void 0 : Cu.UNDEFINED; case -1: if (!n) throw new Error("Invalid BREAK"); return Cu.BREAK; default: return new Zc(t) } } }; var Im = Tx; let Bx = class Xc { constructor(t, n, r) { if (this.tag = t, this.value = n, this.err = r, typeof this.tag != "number") throw new Error("Invalid tag type (" + typeof this.tag + ")"); if (this.tag < 0 || (this.tag | 0) !== this.tag) throw new Error("Tag must be a positive integer: " + this.tag) } toString() { return `${this.tag}(${JSON.stringify(this.value)})` } encodeCBOR(t) { return t._pushTag(this.tag), t.pushAny(this.value) } convert(t) { var n, r; if (r = t != null ? t[this.tag] : void 0, typeof r != "function" && (r = Xc["_tag" + this.tag], typeof r != "function")) return this; try { return r.call(Xc, this.value) } catch (i) { return n = i, this.err = n, this } } }; var Om = Bx; const Um = self.location ? self.location.protocol + "//" + self.location.host : "", Qc = self.URL; let Ax = class { constructor(t = "", n = Um) { this.super = new Qc(t, n), this.path = this.pathname + this.search, this.auth = this.username && this.password ? this.username + ":" + this.password : null, this.query = this.search && this.search.startsWith("?") ? this.search.slice(1) : null } get hash() { return this.super.hash } get host() { return this.super.host } get hostname() { return this.super.hostname } get href() { return this.super.href } get origin() { return this.super.origin } get password() { return this.super.password } get pathname() { return this.super.pathname } get port() { return this.super.port } get protocol() { return this.super.protocol } get search() { return this.super.search } get searchParams() { return this.super.searchParams } get username() { return this.super.username } set hash(t) { this.super.hash = t } set host(t) { this.super.host = t } set hostname(t) { this.super.hostname = t } set href(t) { this.super.href = t } set origin(t) { this.super.origin = t } set password(t) { this.super.password = t } set pathname(t) { this.super.pathname = t } set port(t) { this.super.port = t } set protocol(t) { this.super.protocol = t } set search(t) { this.super.search = t } set searchParams(t) { this.super.searchParams = t } set username(t) { this.super.username = t } createObjectURL(t) { return this.super.createObjectURL(t) } revokeObjectURL(t) { this.super.revokeObjectURL(t) } toJSON() { return this.super.toJSON() } toString() { return this.super.toString() } format() { return this.toString() } }; function kx(e) { if (typeof e == "string") return new Qc(e).toString(); if (!(e instanceof Qc)) { const t = e.username && e.password ? `${e.username}:${e.password}@` : "", n = e.auth ? e.auth + "@" : "", r = e.port ? ":" + e.port : "", i = e.protocol ? e.protocol + "//" : "", s = e.host || "", o = e.hostname || "", a = e.search || (e.query ? "?" + e.query : ""), f = e.hash || "", h = e.pathname || "", _ = e.path || h + a; return `${i}${t || n}${s || o + r}${_}${f}` } } var Fm = { URLWithLegacySupport: Ax, URLSearchParams: self.URLSearchParams, defaultBase: Um, format: kx }; const { URLWithLegacySupport: R8, format: I8 } = Fm, { URLWithLegacySupport: Rx, format: O8, URLSearchParams: U8, defaultBase: F8 } = Fm; var Cm = { URL: Rx }; const { Buffer: Si } = Ro, P0 = Bo, Ix = Hl.BigNumber, Ox = Sx, Ut = Gl, Me = Ot, Ux = Im, Fx = Om, { URL: Cx } = Cm; let Dc = class Jc { constructor(t) { t = t || {}, !t.size || t.size < 65536 ? t.size = 65536 : t.size = Ut.nextPowerOf2(t.size), this._heap = new ArrayBuffer(t.size), this._heap8 = new Uint8Array(this._heap), this._buffer = Si.from(this._heap), this._reset(), this._knownTags = Object.assign({ 0: n => new Date(n), 1: n => new Date(n * 1e3), 2: n => Ut.arrayBufferToBignumber(n), 3: n => Me.NEG_ONE.minus(Ut.arrayBufferToBignumber(n)), 4: n => Me.TEN.pow(n[0]).times(n[1]), 5: n => Me.TWO.pow(n[0]).times(n[1]), 32: n => new Cx(n), 35: n => new RegExp(n) }, t.tags), this.parser = Ox(ns, { log: console.log.bind(console), pushInt: this.pushInt.bind(this), pushInt32: this.pushInt32.bind(this), pushInt32Neg: this.pushInt32Neg.bind(this), pushInt64: this.pushInt64.bind(this), pushInt64Neg: this.pushInt64Neg.bind(this), pushFloat: this.pushFloat.bind(this), pushFloatSingle: this.pushFloatSingle.bind(this), pushFloatDouble: this.pushFloatDouble.bind(this), pushTrue: this.pushTrue.bind(this), pushFalse: this.pushFalse.bind(this), pushUndefined: this.pushUndefined.bind(this), pushNull: this.pushNull.bind(this), pushInfinity: this.pushInfinity.bind(this), pushInfinityNeg: this.pushInfinityNeg.bind(this), pushNaN: this.pushNaN.bind(this), pushNaNNeg: this.pushNaNNeg.bind(this), pushArrayStart: this.pushArrayStart.bind(this), pushArrayStartFixed: this.pushArrayStartFixed.bind(this), pushArrayStartFixed32: this.pushArrayStartFixed32.bind(this), pushArrayStartFixed64: this.pushArrayStartFixed64.bind(this), pushObjectStart: this.pushObjectStart.bind(this), pushObjectStartFixed: this.pushObjectStartFixed.bind(this), pushObjectStartFixed32: this.pushObjectStartFixed32.bind(this), pushObjectStartFixed64: this.pushObjectStartFixed64.bind(this), pushByteString: this.pushByteString.bind(this), pushByteStringStart: this.pushByteStringStart.bind(this), pushUtf8String: this.pushUtf8String.bind(this), pushUtf8StringStart: this.pushUtf8StringStart.bind(this), pushSimpleUnassigned: this.pushSimpleUnassigned.bind(this), pushTagUnassigned: this.pushTagUnassigned.bind(this), pushTagStart: this.pushTagStart.bind(this), pushTagStart4: this.pushTagStart4.bind(this), pushTagStart8: this.pushTagStart8.bind(this), pushBreak: this.pushBreak.bind(this) }, this._heap) } get _depth() { return this._parents.length } get _currentParent() { return this._parents[this._depth - 1] } get _ref() { return this._currentParent.ref } _closeParent() { var t = this._parents.pop(); if (t.length > 0) throw new Error(`Missing ${t.length} elements`); switch (t.type) { case Me.PARENT.TAG: this._push(this.createTag(t.ref[0], t.ref[1])); break; case Me.PARENT.BYTE_STRING: this._push(this.createByteString(t.ref, t.length)); break; case Me.PARENT.UTF8_STRING: this._push(this.createUtf8String(t.ref, t.length)); break; case Me.PARENT.MAP: if (t.values % 2 > 0) throw new Error("Odd number of elements in the map"); this._push(this.createMap(t.ref, t.length)); break; case Me.PARENT.OBJECT: if (t.values % 2 > 0) throw new Error("Odd number of elements in the map"); this._push(this.createObject(t.ref, t.length)); break; case Me.PARENT.ARRAY: this._push(this.createArray(t.ref, t.length)); break }this._currentParent && this._currentParent.type === Me.PARENT.TAG && this._dec() } _dec() { const t = this._currentParent; t.length < 0 || (t.length--, t.length === 0 && this._closeParent()) } _push(t, n) { const r = this._currentParent; switch (r.values++, r.type) { case Me.PARENT.ARRAY: case Me.PARENT.BYTE_STRING: case Me.PARENT.UTF8_STRING: r.length > -1 ? this._ref[this._ref.length - r.length] = t : this._ref.push(t), this._dec(); break; case Me.PARENT.OBJECT: r.tmpKey != null ? (this._ref[r.tmpKey] = t, r.tmpKey = null, this._dec()) : (r.tmpKey = t, typeof r.tmpKey != "string" && (r.type = Me.PARENT.MAP, r.ref = Ut.buildMap(r.ref))); break; case Me.PARENT.MAP: r.tmpKey != null ? (this._ref.set(r.tmpKey, t), r.tmpKey = null, this._dec()) : r.tmpKey = t; break; case Me.PARENT.TAG: this._ref.push(t), n || this._dec(); break; default: throw new Error("Unknown parent type") } } _createParent(t, n, r) { this._parents[this._depth] = { type: n, length: r, ref: t, values: 0, tmpKey: null } } _reset() { this._res = [], this._parents = [{ type: Me.PARENT.ARRAY, length: -1, ref: this._res, values: 0, tmpKey: null }] } createTag(t, n) { const r = this._knownTags[t]; return r ? r(n) : new Fx(t, n) } createMap(t, n) { return t } createObject(t, n) { return t } createArray(t, n) { return t } createByteString(t, n) { return Si.concat(t) } createByteStringFromHeap(t, n) { return t === n ? Si.alloc(0) : Si.from(this._heap.slice(t, n)) } createInt(t) { return t } createInt32(t, n) { return Ut.buildInt32(t, n) } createInt64(t, n, r, i) { return Ut.buildInt64(t, n, r, i) } createFloat(t) { return t } createFloatSingle(t, n, r, i) { return P0.read([t, n, r, i], 0, !1, 23, 4) } createFloatDouble(t, n, r, i, s, o, a, f) { return P0.read([t, n, r, i, s, o, a, f], 0, !1, 52, 8) } createInt32Neg(t, n) { return -1 - Ut.buildInt32(t, n) } createInt64Neg(t, n, r, i) { const s = Ut.buildInt32(t, n), o = Ut.buildInt32(r, i); return s > Me.MAX_SAFE_HIGH ? Me.NEG_ONE.minus(new Ix(s).times(Me.SHIFT32).plus(o)) : -1 - (s * Me.SHIFT32 + o) } createTrue() { return !0 } createFalse() { return !1 } createNull() { return null } createUndefined() { } createInfinity() { return 1 / 0 } createInfinityNeg() { return -1 / 0 } createNaN() { return NaN } createNaNNeg() { return NaN } createUtf8String(t, n) { return t.join("") } createUtf8StringFromHeap(t, n) { return t === n ? "" : this._buffer.toString("utf8", t, n) } createSimpleUnassigned(t) { return new Ux(t) } pushInt(t) { this._push(this.createInt(t)) } pushInt32(t, n) { this._push(this.createInt32(t, n)) } pushInt64(t, n, r, i) { this._push(this.createInt64(t, n, r, i)) } pushFloat(t) { this._push(this.createFloat(t)) } pushFloatSingle(t, n, r, i) { this._push(this.createFloatSingle(t, n, r, i)) } pushFloatDouble(t, n, r, i, s, o, a, f) { this._push(this.createFloatDouble(t, n, r, i, s, o, a, f)) } pushInt32Neg(t, n) { this._push(this.createInt32Neg(t, n)) } pushInt64Neg(t, n, r, i) { this._push(this.createInt64Neg(t, n, r, i)) } pushTrue() { this._push(this.createTrue()) } pushFalse() { this._push(this.createFalse()) } pushNull() { this._push(this.createNull()) } pushUndefined() { this._push(this.createUndefined()) } pushInfinity() { this._push(this.createInfinity()) } pushInfinityNeg() { this._push(this.createInfinityNeg()) } pushNaN() { this._push(this.createNaN()) } pushNaNNeg() { this._push(this.createNaNNeg()) } pushArrayStart() { this._createParent([], Me.PARENT.ARRAY, -1) } pushArrayStartFixed(t) { this._createArrayStartFixed(t) } pushArrayStartFixed32(t, n) { const r = Ut.buildInt32(t, n); this._createArrayStartFixed(r) } pushArrayStartFixed64(t, n, r, i) { const s = Ut.buildInt64(t, n, r, i); this._createArrayStartFixed(s) } pushObjectStart() { this._createObjectStartFixed(-1) } pushObjectStartFixed(t) { this._createObjectStartFixed(t) } pushObjectStartFixed32(t, n) { const r = Ut.buildInt32(t, n); this._createObjectStartFixed(r) } pushObjectStartFixed64(t, n, r, i) { const s = Ut.buildInt64(t, n, r, i); this._createObjectStartFixed(s) } pushByteStringStart() { this._parents[this._depth] = { type: Me.PARENT.BYTE_STRING, length: -1, ref: [], values: 0, tmpKey: null } } pushByteString(t, n) { this._push(this.createByteStringFromHeap(t, n)) } pushUtf8StringStart() { this._parents[this._depth] = { type: Me.PARENT.UTF8_STRING, length: -1, ref: [], values: 0, tmpKey: null } } pushUtf8String(t, n) { this._push(this.createUtf8StringFromHeap(t, n)) } pushSimpleUnassigned(t) { this._push(this.createSimpleUnassigned(t)) } pushTagStart(t) { this._parents[this._depth] = { type: Me.PARENT.TAG, length: 1, ref: [t] } } pushTagStart4(t, n) { this.pushTagStart(Ut.buildInt32(t, n)) } pushTagStart8(t, n, r, i) { this.pushTagStart(Ut.buildInt64(t, n, r, i)) } pushTagUnassigned(t) { this._push(this.createTag(t)) } pushBreak() { if (this._currentParent.length > -1) throw new Error("Unexpected break"); this._closeParent() } _createObjectStartFixed(t) { if (t === 0) { this._push(this.createObject({})); return } this._createParent({}, Me.PARENT.OBJECT, t) } _createArrayStartFixed(t) { if (t === 0) { this._push(this.createArray([])); return } this._createParent(new Array(t), Me.PARENT.ARRAY, t) } _decode(t) { if (t.byteLength === 0) throw new Error("Input too short"); this._reset(), this._heap8.set(t); const n = this.parser.parse(t.byteLength); if (this._depth > 1) { for (; this._currentParent.length === 0;)this._closeParent(); if (this._depth > 1) throw new Error("Undeterminated nesting") } if (n > 0) throw new Error("Failed to parse"); if (this._res.length === 0) throw new Error("No valid result") } decodeFirst(t) { return this._decode(t), this._res[0] } decodeAll(t) { return this._decode(t), this._res } static decode(t, n) { return typeof t == "string" && (t = Si.from(t, n || "hex")), new Jc({ size: t.length }).decodeFirst(t) } static decodeAll(t, n) { return typeof t == "string" && (t = Si.from(t, n || "hex")), new Jc({ size: t.length }).decodeAll(t) } }; Dc.decodeFirst = Dc.decode; var Pm = Dc; const { Buffer: Pu } = Ro, Px = Pm, Mx = Gl; class dd extends Px { createTag(t, n) { return `${t}(${n})` } createInt(t) { return super.createInt(t).toString() } createInt32(t, n) { return super.createInt32(t, n).toString() } createInt64(t, n, r, i) { return super.createInt64(t, n, r, i).toString() } createInt32Neg(t, n) { return super.createInt32Neg(t, n).toString() } createInt64Neg(t, n, r, i) { return super.createInt64Neg(t, n, r, i).toString() } createTrue() { return "true" } createFalse() { return "false" } createFloat(t) { const n = super.createFloat(t); return Mx.isNegativeZero(t) ? "-0_1" : `${n}_1` } createFloatSingle(t, n, r, i) { return `${super.createFloatSingle(t, n, r, i)}_2` } createFloatDouble(t, n, r, i, s, o, a, f) { return `${super.createFloatDouble(t, n, r, i, s, o, a, f)}_3` } createByteString(t, n) { const r = t.join(", "); return n === -1 ? `(_ ${r})` : `h'${r}` } createByteStringFromHeap(t, n) { return `h'${Pu.from(super.createByteStringFromHeap(t, n)).toString("hex")}'` } createInfinity() { return "Infinity_1" } createInfinityNeg() { return "-Infinity_1" } createNaN() { return "NaN_1" } createNaNNeg() { return "-NaN_1" } createNull() { return "null" } createUndefined() { return "undefined" } createSimpleUnassigned(t) { return `simple(${t})` } createArray(t, n) { const r = super.createArray(t, n); return n === -1 ? `[_ ${r.join(", ")}]` : `[${r.join(", ")}]` } createMap(t, n) { const r = super.createMap(t), i = Array.from(r.keys()).reduce(M0(r), ""); return n === -1 ? `{_ ${i}}` : `{${i}}` } createObject(t, n) { const r = super.createObject(t), i = Object.keys(r).reduce(M0(r), ""); return n === -1 ? `{_ ${i}}` : `{${i}}` } createUtf8String(t, n) { const r = t.join(", "); return n === -1 ? `(_ ${r})` : `"${r}"` } createUtf8StringFromHeap(t, n) { return `"${Pu.from(super.createUtf8StringFromHeap(t, n)).toString("utf8")}"` } static diagnose(t, n) { return typeof t == "string" && (t = Pu.from(t, n || "hex")), new dd().decodeFirst(t) } } var jx = dd; function M0(e) { return (t, n) => t ? `${t}, ${n}: ${e[n]}` : `${n}: ${e[n]}` } const { Buffer: On } = Ro, { URL: $x } = Cm, ef = Hl.BigNumber, Mu = Gl, lt = Ot, dn = lt.MT, ra = lt.NUMBYTES, j0 = lt.SHIFT32, $0 = lt.SYMS, Ni = lt.TAG, zx = lt.MT.SIMPLE_FLOAT << 5 | lt.NUMBYTES.TWO, Vx = lt.MT.SIMPLE_FLOAT << 5 | lt.NUMBYTES.FOUR, qx = lt.MT.SIMPLE_FLOAT << 5 | lt.NUMBYTES.EIGHT, Hx = lt.MT.SIMPLE_FLOAT << 5 | lt.SIMPLE.TRUE, Gx = lt.MT.SIMPLE_FLOAT << 5 | lt.SIMPLE.FALSE, Lx = lt.MT.SIMPLE_FLOAT << 5 | lt.SIMPLE.UNDEFINED, z0 = lt.MT.SIMPLE_FLOAT << 5 | lt.SIMPLE.NULL, Wx = new ef("0x20000000000000"), Yx = On.from("f97e00", "hex"), Kx = On.from("f9fc00", "hex"), Zx = On.from("f97c00", "hex"); function Xx(e) { return {}.toString.call(e).slice(8, -1) } class pl { constructor(t) { t = t || {}, this.streaming = typeof t.stream == "function", this.onData = t.stream, this.semanticTypes = [[$x, this._pushUrl], [ef, this._pushBigNumber]]; const n = t.genTypes || [], r = n.length; for (let i = 0; i < r; i++)this.addSemanticType(n[i][0], n[i][1]); this._reset() } addSemanticType(t, n) { const r = this.semanticTypes.length; for (let i = 0; i < r; i++)if (this.semanticTypes[i][0] === t) { const o = this.semanticTypes[i][1]; return this.semanticTypes[i][1] = n, o } return this.semanticTypes.push([t, n]), null } push(t) { return t && (this.result[this.offset] = t, this.resultMethod[this.offset] = 0, this.resultLength[this.offset] = t.length, this.offset++, this.streaming && this.onData(this.finalize())), !0 } pushWrite(t, n, r) { return this.result[this.offset] = t, this.resultMethod[this.offset] = n, this.resultLength[this.offset] = r, this.offset++, this.streaming && this.onData(this.finalize()), !0 } _pushUInt8(t) { return this.pushWrite(t, 1, 1) } _pushUInt16BE(t) { return this.pushWrite(t, 2, 2) } _pushUInt32BE(t) { return this.pushWrite(t, 3, 4) } _pushDoubleBE(t) { return this.pushWrite(t, 4, 8) } _pushNaN() { return this.push(Yx) } _pushInfinity(t) { const n = t < 0 ? Kx : Zx; return this.push(n) } _pushFloat(t) { const n = On.allocUnsafe(2); if (Mu.writeHalf(n, t) && Mu.parseHalf(n) === t) return this._pushUInt8(zx) && this.push(n); const r = On.allocUnsafe(4); return r.writeFloatBE(t, 0), r.readFloatBE(0) === t ? this._pushUInt8(Vx) && this.push(r) : this._pushUInt8(qx) && this._pushDoubleBE(t) } _pushInt(t, n, r) { const i = n << 5; return t < 24 ? this._pushUInt8(i | t) : t <= 255 ? this._pushUInt8(i | ra.ONE) && this._pushUInt8(t) : t <= 65535 ? this._pushUInt8(i | ra.TWO) && this._pushUInt16BE(t) : t <= 4294967295 ? this._pushUInt8(i | ra.FOUR) && this._pushUInt32BE(t) : t <= Number.MAX_SAFE_INTEGER ? this._pushUInt8(i | ra.EIGHT) && this._pushUInt32BE(Math.floor(t / j0)) && this._pushUInt32BE(t % j0) : n === dn.NEG_INT ? this._pushFloat(r) : this._pushFloat(t) } _pushIntNum(t) { return t < 0 ? this._pushInt(-t - 1, dn.NEG_INT, t) : this._pushInt(t, dn.POS_INT) } _pushNumber(t) { switch (!1) { case t === t: return this._pushNaN(t); case isFinite(t): return this._pushInfinity(t); case t % 1 !== 0: return this._pushIntNum(t); default: return this._pushFloat(t) } } _pushString(t) { const n = On.byteLength(t, "utf8"); return this._pushInt(n, dn.UTF8_STRING) && this.pushWrite(t, 5, n) } _pushBoolean(t) { return this._pushUInt8(t ? Hx : Gx) } _pushUndefined(t) { return this._pushUInt8(Lx) } _pushArray(t, n) { const r = n.length; if (!t._pushInt(r, dn.ARRAY)) return !1; for (let i = 0; i < r; i++)if (!t.pushAny(n[i])) return !1; return !0 } _pushTag(t) { return this._pushInt(t, dn.TAG) } _pushDate(t, n) { return t._pushTag(Ni.DATE_EPOCH) && t.pushAny(Math.round(n / 1e3)) } _pushBuffer(t, n) { return t._pushInt(n.length, dn.BYTE_STRING) && t.push(n) } _pushNoFilter(t, n) { return t._pushBuffer(t, n.slice()) } _pushRegexp(t, n) { return t._pushTag(Ni.REGEXP) && t.pushAny(n.source) } _pushSet(t, n) { if (!t._pushInt(n.size, dn.ARRAY)) return !1; for (const r of n) if (!t.pushAny(r)) return !1; return !0 } _pushUrl(t, n) { return t._pushTag(Ni.URI) && t.pushAny(n.format()) } _pushBigint(t) { let n = Ni.POS_BIGINT; t.isNegative() && (t = t.negated().minus(1), n = Ni.NEG_BIGINT); let r = t.toString(16); r.length % 2 && (r = "0" + r); const i = On.from(r, "hex"); return this._pushTag(n) && this._pushBuffer(this, i) } _pushBigNumber(t, n) { if (n.isNaN()) return t._pushNaN(); if (!n.isFinite()) return t._pushInfinity(n.isNegative() ? -1 / 0 : 1 / 0); if (n.isInteger()) return t._pushBigint(n); if (!(t._pushTag(Ni.DECIMAL_FRAC) && t._pushInt(2, dn.ARRAY))) return !1; const r = n.decimalPlaces(), i = n.multipliedBy(new ef(10).pow(r)); return t._pushIntNum(-r) ? i.abs().isLessThan(Wx) ? t._pushIntNum(i.toNumber()) : t._pushBigint(i) : !1 } _pushMap(t, n) { return t._pushInt(n.size, dn.MAP) ? this._pushRawMap(n.size, Array.from(n)) : !1 } _pushObject(t) { if (!t) return this._pushUInt8(z0); for (var n = this.semanticTypes.length, r = 0; r < n; r++)if (t instanceof this.semanticTypes[r][0]) return this.semanticTypes[r][1].call(t, this, t); var i = t.encodeCBOR; if (typeof i == "function") return i.call(t, this); var s = Object.keys(t), o = s.length; return this._pushInt(o, dn.MAP) ? this._pushRawMap(o, s.map(a => [a, t[a]])) : !1 } _pushRawMap(t, n) { n = n.map(function (i) { return i[0] = pl.encode(i[0]), i }).sort(Mu.keySorter); for (var r = 0; r < t; r++)if (!this.push(n[r][0]) || !this.pushAny(n[r][1])) return !1; return !0 } write(t) { return this.pushAny(t) } pushAny(t) { var n = Xx(t); switch (n) { case "Number": return this._pushNumber(t); case "String": return this._pushString(t); case "Boolean": return this._pushBoolean(t); case "Object": return this._pushObject(t); case "Array": return this._pushArray(this, t); case "Uint8Array": return this._pushBuffer(this, On.isBuffer(t) ? t : On.from(t)); case "Null": return this._pushUInt8(z0); case "Undefined": return this._pushUndefined(t); case "Map": return this._pushMap(this, t); case "Set": return this._pushSet(this, t); case "URL": return this._pushUrl(this, t); case "BigNumber": return this._pushBigNumber(this, t); case "Date": return this._pushDate(this, t); case "RegExp": return this._pushRegexp(this, t); case "Symbol": switch (t) { case $0.NULL: return this._pushObject(null); case $0.UNDEFINED: return this._pushUndefined(void 0); default: throw new Error("Unknown symbol: " + t.toString()) }default: throw new Error("Unknown type: " + typeof t + ", " + (t ? t.toString() : "")) } } finalize() { if (this.offset === 0) return null; for (var t = this.result, n = this.resultLength, r = this.resultMethod, i = this.offset, s = 0, o = 0; o < i; o++)s += n[o]; var a = On.allocUnsafe(s), f = 0, h = 0; for (o = 0; o < i; o++) { switch (h = n[o], r[o]) { case 0: t[o].copy(a, f); break; case 1: a.writeUInt8(t[o], f, !0); break; case 2: a.writeUInt16BE(t[o], f, !0); break; case 3: a.writeUInt32BE(t[o], f, !0); break; case 4: a.writeDoubleBE(t[o], f, !0); break; case 5: a.write(t[o], f, h, "utf8"); break; default: throw new Error("unkown method") }f += h } var _ = a; return this._reset(), _ } _reset() { this.result = [], this.resultMethod = [], this.resultLength = [], this.offset = 0 } static encode(t) { const n = new pl; if (!n.pushAny(t)) throw new Error("Failed to encode input"); return n.finalize() } } var Qx = pl; (function (e) { e.Diagnose = jx, e.Decoder = Pm, e.Encoder = Qx, e.Simple = Im, e.Tagged = Om, e.decodeAll = e.Decoder.decodeAll, e.decodeFirst = e.Decoder.decodeFirst, e.diagnose = e.Diagnose.diagnose, e.encode = e.Encoder.encode, e.decode = e.Decoder.decode, e.leveldb = { decode: e.Decoder.decodeAll, encode: e.Encoder.encode, buffer: !0, name: "cbor" } })(km); const Mm = _h(km); function xn(e) { return Ea(ux.create().update(new Uint8Array(e)).digest()) } function Sa(e) { if (e instanceof Mm.Tagged) return Sa(e.value); if (typeof e == "string") return jm(e); if (typeof e == "number") return xn(Xe(e)); if (e instanceof ArrayBuffer || ArrayBuffer.isView(e)) return xn(e); if (Array.isArray(e)) { const t = e.map(Sa); return xn($n(...t)) } else { if (e && typeof e == "object" && e._isPrincipal) return xn(e.toUint8Array()); if (typeof e == "object" && e !== null && typeof e.toHash == "function") return Sa(e.toHash()); if (typeof e == "object") return ml(e); if (typeof e == "bigint") return xn(Xe(e)) } throw Object.assign(new Error(`Attempt to hash a value of unsupported type: ${e}`), { value: e }) } const jm = e => { const t = new TextEncoder().encode(e); return xn(t) }; function V0(e) { return ml(e) } function ml(e) { const r = Object.entries(e).filter(([, o]) => o !== void 0).map(([o, a]) => { const f = jm(o), h = Sa(a); return [f, h] }).sort(([o], [a]) => G1(o, a)), i = $n(...r.map(o => $n(...o))); return xn(i) } new TextEncoder().encode(`
ic-request`); class q0 { getPrincipal() { return Se.anonymous() } async transformRequest(t) { return Object.assign(Object.assign({}, t), { body: { content: t.body } }) } } var Dn = {}, xs = {}, $e = {}; Object.defineProperty($e, "__esModule", { value: !0 }); const Dx = 9007199254740992; function or(e, ...t) { const n = new Uint8Array(e.byteLength + t.reduce((i, s) => i + s.byteLength, 0)); n.set(new Uint8Array(e), 0); let r = e.byteLength; for (const i of t) n.set(new Uint8Array(i), r), r += i.byteLength; return n.buffer } function bn(e, t, n) { n = n.replace(/[^0-9a-fA-F]/g, ""); const r = 2 ** (t - 24); n = n.slice(-r * 2).padStart(r * 2, "0"); const i = [(e << 5) + t].concat(n.match(/../g).map(s => parseInt(s, 16))); return new Uint8Array(i).buffer } function Ll(e, t) { if (t < 24) return new Uint8Array([(e << 5) + t]).buffer; { const n = t <= 255 ? 24 : t <= 65535 ? 25 : t <= 4294967295 ? 26 : 27; return bn(e, n, t.toString(16)) } } function $m(e) { const t = []; for (let n = 0; n < e.length; n++) { let r = e.charCodeAt(n); r < 128 ? t.push(r) : r < 2048 ? t.push(192 | r >> 6, 128 | r & 63) : r < 55296 || r >= 57344 ? t.push(224 | r >> 12, 128 | r >> 6 & 63, 128 | r & 63) : (n++, r = (r & 1023) << 10 | e.charCodeAt(n) & 1023, t.push(240 | r >> 18, 128 | r >> 12 & 63, 128 | r >> 6 & 63, 128 | r & 63)) } return or(new Uint8Array(Ll(3, e.length)), new Uint8Array(t)) } function Jx(e, t) { if (e == 14277111) return or(new Uint8Array([217, 217, 247]), t); if (e < 24) return or(new Uint8Array([192 + e]), t); { const n = e <= 255 ? 24 : e <= 65535 ? 25 : e <= 4294967295 ? 26 : 27, r = 2 ** (n - 24), i = e.toString(16).slice(-r * 2).padStart(r * 2, "0"), s = [192 + n].concat(i.match(/../g).map(o => parseInt(o, 16))); return new Uint8Array(s).buffer } } $e.tagged = Jx; function Io(e) { return new Uint8Array(e).buffer } $e.raw = Io; function hd(e) { if (isNaN(e)) throw new RangeError("Invalid number."); e = Math.min(Math.max(0, e), 23); const t = [0 + e]; return new Uint8Array(t).buffer } $e.uSmall = hd; function zm(e, t) { if (e = parseInt("" + e, t), isNaN(e)) throw new RangeError("Invalid number."); return e = Math.min(Math.max(0, e), 255), e = e.toString(16), bn(0, 24, e) } $e.u8 = zm; function Vm(e, t) { if (e = parseInt("" + e, t), isNaN(e)) throw new RangeError("Invalid number."); return e = Math.min(Math.max(0, e), 65535), e = e.toString(16), bn(0, 25, e) } $e.u16 = Vm; function qm(e, t) { if (e = parseInt("" + e, t), isNaN(e)) throw new RangeError("Invalid number."); return e = Math.min(Math.max(0, e), 4294967295), e = e.toString(16), bn(0, 26, e) } $e.u32 = qm; function pd(e, t) { if (typeof e == "string" && t == 16) { if (e.match(/[^0-9a-fA-F]/)) throw new RangeError("Invalid number."); return bn(0, 27, e) } if (e = parseInt("" + e, t), isNaN(e)) throw new RangeError("Invalid number."); return e = Math.min(Math.max(0, e), Dx), e = e.toString(16), bn(0, 27, e) } $e.u64 = pd; function Hm(e) { if (isNaN(e)) throw new RangeError("Invalid number."); if (e === 0) return hd(0); e = Math.min(Math.max(0, -e), 24) - 1; const t = [32 + e]; return new Uint8Array(t).buffer } $e.iSmall = Hm; function Gm(e, t) { if (e = parseInt("" + e, t), isNaN(e)) throw new RangeError("Invalid number."); return e = Math.min(Math.max(0, -e - 1), 255), e = e.toString(16), bn(1, 24, e) } $e.i8 = Gm; function Lm(e, t) { if (e = parseInt("" + e, t), isNaN(e)) throw new RangeError("Invalid number."); return e = Math.min(Math.max(0, -e - 1), 65535), e = e.toString(16), bn(1, 25, e) } $e.i16 = Lm; function Wm(e, t) { if (e = parseInt("" + e, t), isNaN(e)) throw new RangeError("Invalid number."); return e = Math.min(Math.max(0, -e - 1), 4294967295), e = e.toString(16), bn(1, 26, e) } $e.i32 = Wm; function Ym(e, t) { if (typeof e == "string" && t == 16) { if (e.startsWith("-") ? e = e.slice(1) : e = "0", e.match(/[^0-9a-fA-F]/) || e.length > 16) throw new RangeError("Invalid number."); let n = !1, r = e.split("").reduceRight((i, s) => { if (n) return s + i; let o = parseInt(s, 16) - 1; return o >= 0 ? (n = !0, o.toString(16) + i) : "f" + i }, ""); return n ? bn(1, 27, r) : pd(0) } if (e = parseInt("" + e, t), isNaN(e)) throw new RangeError("Invalid number."); return e = Math.min(Math.max(0, -e - 1), 9007199254740992), e = e.toString(16), bn(1, 27, e) } $e.i64 = Ym; function ev(e) { return e >= 0 ? e < 24 ? hd(e) : e <= 255 ? zm(e) : e <= 65535 ? Vm(e) : e <= 4294967295 ? qm(e) : pd(e) : e >= -24 ? Hm(e) : e >= -255 ? Gm(e) : e >= -65535 ? Lm(e) : e >= -4294967295 ? Wm(e) : Ym(e) } $e.number = ev; function tv(e) { return or(Ll(2, e.byteLength), e) } $e.bytes = tv; function nv(e) { return $m(e) } $e.string = nv; function rv(e) { return or(Ll(4, e.length), ...e) } $e.array = rv; function iv(e, t = !1) { e instanceof Map || (e = new Map(Object.entries(e))); let n = Array.from(e.entries()); return t && (n = n.sort(([r], [i]) => r.localeCompare(i))), or(Ll(5, e.size), ...n.map(([r, i]) => or($m(r), i))) } $e.map = iv; function sv(e) { const t = new Float32Array([e]); return or(new Uint8Array([250]), new Uint8Array(t.buffer)) } $e.singleFloat = sv; function ov(e) { const t = new Float64Array([e]); return or(new Uint8Array([251]), new Uint8Array(t.buffer)) } $e.doubleFloat = ov; function av(e) { return e ? Km() : Zm() } $e.bool = av; function Km() { return Io(new Uint8Array([245])) } $e.true_ = Km; function Zm() { return Io(new Uint8Array([244])) } $e.false_ = Zm; function lv() { return Io(new Uint8Array([246])) } $e.null_ = lv; function uv() { return Io(new Uint8Array([247])) } $e.undefined_ = uv; var cv = ns && ns.__importStar || function (e) { if (e && e.__esModule) return e; var t = {}; if (e != null) for (var n in e) Object.hasOwnProperty.call(e, n) && (t[n] = e[n]); return t.default = e, t }; Object.defineProperty(xs, "__esModule", { value: !0 }); const hn = cv($e), fv = [ArrayBuffer, Uint8Array, Uint16Array, Uint32Array, Int8Array, Int16Array, Int32Array, Float32Array, Float64Array]; class Xm { constructor(t, n = !1) { this._serializer = t, this._stable = n, this.name = "jsonDefault", this.priority = -100 } match(t) { return ["undefined", "boolean", "number", "string", "object"].indexOf(typeof t) != -1 } encode(t) { switch (typeof t) { case "undefined": return hn.undefined_(); case "boolean": return hn.bool(t); case "number": return Math.floor(t) === t ? hn.number(t) : hn.doubleFloat(t); case "string": return hn.string(t); case "object": if (t === null) return hn.null_(); if (Array.isArray(t)) return hn.array(t.map(n => this._serializer.serializeValue(n))); if (fv.find(n => t instanceof n)) return hn.bytes(t.buffer); if (Object.getOwnPropertyNames(t).indexOf("toJSON") !== -1) return this.encode(t.toJSON()); if (t instanceof Map) { const n = new Map; for (const [r, i] of t.entries()) n.set(r, this._serializer.serializeValue(i)); return hn.map(n, this._stable) } else { const n = new Map; for (const [r, i] of Object.entries(t)) n.set(r, this._serializer.serializeValue(i)); return hn.map(n, this._stable) } default: throw new Error("Invalid value.") } } } xs.JsonDefaultCborEncoder = Xm; class Qm { constructor() { this.name = "cborEncoder", this.priority = -90 } match(t) { return typeof t == "object" && typeof t.toCBOR == "function" } encode(t) { return t.toCBOR() } } xs.ToCborEncoder = Qm; class Dm { constructor() { this._encoders = new Set } static withDefaultEncoders(t = !1) { const n = new this; return n.addEncoder(new Xm(n, t)), n.addEncoder(new Qm), n } removeEncoder(t) { for (const n of this._encoders.values()) n.name == t && this._encoders.delete(n) } addEncoder(t) { this._encoders.add(t) } getEncoderFor(t) { let n = null; for (const r of this._encoders) (!n || r.priority > n.priority) && r.match(t) && (n = r); if (n === null) throw new Error("Could not find an encoder for value."); return n } serializeValue(t) { return this.getEncoderFor(t).encode(t) } serialize(t) { return this.serializeValue(t) } } xs.CborSerializer = Dm; class dv extends Dm { serialize(t) { return hn.raw(new Uint8Array([...new Uint8Array([217, 217, 247]), ...new Uint8Array(super.serializeValue(t))])) } } xs.SelfDescribeCborSerializer = dv; (function (e) { function t(i) { for (var s in i) e.hasOwnProperty(s) || (e[s] = i[s]) } var n = ns && ns.__importStar || function (i) { if (i && i.__esModule) return i; var s = {}; if (i != null) for (var o in i) Object.hasOwnProperty.call(i, o) && (s[o] = i[o]); return s.default = i, s }; Object.defineProperty(e, "__esModule", { value: !0 }), t(xs); const r = n($e); e.value = r })(Dn); class hv { get name() { return "Principal" } get priority() { return 0 } match(t) { return t && t._isPrincipal === !0 } encode(t) { return Dn.value.bytes(t.toUint8Array()) } } class pv { get name() { return "Buffer" } get priority() { return 1 } match(t) { return t instanceof ArrayBuffer || ArrayBuffer.isView(t) } encode(t) { return Dn.value.bytes(new Uint8Array(t)) } } class mv { get name() { return "BigInt" } get priority() { return 1 } match(t) { return typeof t == "bigint" } encode(t) { return t > BigInt(0) ? Dn.value.tagged(2, Dn.value.bytes(fl(t.toString(16)))) : Dn.value.tagged(3, Dn.value.bytes(fl((BigInt("-1") * t).toString(16)))) } } const Wl = Dn.SelfDescribeCborSerializer.withDefaultEncoders(!0); Wl.addEncoder(new hv); Wl.addEncoder(new pv); Wl.addEncoder(new mv); var tf; (function (e) { e[e.Uint64LittleEndian = 71] = "Uint64LittleEndian", e[e.Semantic = 55799] = "Semantic" })(tf || (tf = {})); function ju(e) { return Wl.serialize(e) } function H0(e) { const t = e.byteLength; let n = BigInt(0); for (let r = 0; r < t; r++)n = n * BigInt(256) + BigInt(e[r]); return n } class yv extends Mm.Decoder { createByteString(t) { return $n(...t) } createByteStringFromHeap(t, n) { return t === n ? new ArrayBuffer(0) : new Uint8Array(this._heap.slice(t, n)) } } function Jn(e) { const t = new Uint8Array(e), n = new yv({ size: t.byteLength, tags: { 2: r => H0(r), 3: r => -H0(r), [tf.Semantic]: r => r } }); try { return n.decodeFirst(t) } catch (r) { throw new Error(`Failed to decode CBOR: ${r}, input: ${ht(t)}`) } } const ia = () => { if (typeof window < "u" && window.crypto && window.crypto.getRandomValues) { const e = new Uint32Array(1); return window.crypto.getRandomValues(e), e[0] } if (typeof crypto < "u" && crypto.getRandomValues) { const e = new Uint32Array(1); return crypto.getRandomValues(e), e[0] } return typeof crypto < "u" && crypto.randomInt ? crypto.randomInt(0, 4294967295) : Math.floor(Math.random() * 4294967295) }; var nf; (function (e) { e.Call = "call" })(nf || (nf = {})); function rf() { const e = new ArrayBuffer(16), t = new DataView(e), n = ia(), r = ia(), i = ia(), s = ia(); return t.setUint32(0, n), t.setUint32(4, r), t.setUint32(8, i), t.setUint32(12, s), e } const G0 = BigInt(1e6), gv = 60 * 1e3; class sa { constructor(t) { if (t < 90 * 1e3) { const a = BigInt(Date.now() + t) * G0 / BigInt(1e9); this._value = a * BigInt(1e9); return } const s = BigInt(Math.floor(Date.now() + t - gv)) * G0 / BigInt(1e9) / BigInt(60) * BigInt(60) * BigInt(1e9); this._value = s } toCBOR() { return Dn.value.u64(this._value.toString(16), 16) } toHash() { return Xe(this._value) } } function L0(e = rf) { return async t => { const n = t.request.headers; t.request.headers = n, t.endpoint === "call" && (t.body.nonce = e()) } } function Cs(e) { const t = []; return e.forEach((n, r) => { t.push([r, n]) }), t } class $u extends Ze { constructor(t, n) { super(t), this.response = n, this.name = this.constructor.name, Object.setPrototypeOf(this, new.target.prototype) } } class wv extends Ze { constructor(t, n, r, i, s, o) { super(t), this.response = n, this.requestId = r, this.senderPubkey = i, this.senderSig = s, this.ingressExpiry = o, this.name = "AgentCallError", Object.setPrototypeOf(this, new.target.prototype) } } class xv extends Ze { constructor(t, n, r, i, s, o) { super(t), this.response = n, this.requestId = r, this.senderPubkey = i, this.senderSig = s, this.ingressExpiry = o, this.name = "AgentQueryError", Object.setPrototypeOf(this, new.target.prototype) } } class vv extends Ze { constructor(t, n, r, i, s, o) { super(t), this.response = n, this.requestId = r, this.senderPubkey = i, this.senderSig = s, this.ingressExpiry = o, this.name = "AgentReadStateError", Object.setPrototypeOf(this, new.target.prototype) } }/*! noble-curves - MIT License (c) 2022 Paul Miller (paulmillr.com) */const md = BigInt(0), yl = BigInt(1); function yo(e, t) { if (typeof t != "boolean") throw new Error(e + " boolean expected, got " + t) } function Jm(e) { if (typeof e != "string") throw new Error("hex string expected, got " + typeof e); return e === "" ? md : BigInt("0x" + e) } function zn(e) { return Jm(fs(e)) } function go(e) { return It(e), Jm(fs(Uint8Array.from(e).reverse())) } function wt(e, t) { return M1(e.toString(16).padStart(t * 2, "0")) } function Yl(e, t) { return wt(e, t).reverse() } function Mt(e, t, n) { let r; if (typeof t == "string") try { r = M1(t) } catch (s) { throw new Error(e + " must be hex string or Uint8Array, cause: " + s) } else if (sd(t)) r = Uint8Array.from(t); else throw new Error(e + " must be hex string or Uint8Array"); const i = r.length; if (typeof n == "number" && i !== n) throw new Error(e + " of length " + n + " expected, got " + i); return r } const zu = e => typeof e == "bigint" && md <= e; function ey(e, t, n) { return zu(e) && zu(t) && zu(n) && t <= e && e < n } function Ps(e, t, n, r) { if (!ey(t, n, r)) throw new Error("expected valid " + e + ": " + n + " <= n < " + r + ", got " + t) } function es(e) { let t; for (t = 0; e > md; e >>= yl, t += 1); return t } function _v(e, t) { return e >> BigInt(t) & yl } const ii = e => (yl << BigInt(e)) - yl; function Ev(e) { return typeof e == "function" && Number.isSafeInteger(e.outputLen) } function Oo(e, t, n = {}) { if (!e || typeof e != "object") throw new Error("expected valid options object"); function r(i, s, o) { const a = e[i]; if (o && a === void 0) return; const f = typeof a; if (f !== s || a === null) throw new Error(`param "${i}" is invalid: expected ${s}, got ${f}`) } Object.entries(t).forEach(([i, s]) => r(i, s, !1)), Object.entries(n).forEach(([i, s]) => r(i, s, !0)) } const W0 = () => { throw new Error("not implemented") }; function wo(e) { const t = new WeakMap; return (n, ...r) => { const i = t.get(n); if (i !== void 0) return i; const s = e(n, ...r); return t.set(n, s), s } }/*! noble-curves - MIT License (c) 2022 Paul Miller (paulmillr.com) */const Ht = BigInt(0), vt = BigInt(1), Dr = BigInt(2), ty = BigInt(3), ny = BigInt(4), ry = BigInt(5), bv = BigInt(7), iy = BigInt(8), Sv = BigInt(9), sy = BigInt(16); function Qe(e, t) { const n = e % t; return n >= Ht ? n : t + n } function Tn(e, t, n) { let r = e; for (; t-- > Ht;)r *= r, r %= n; return r } function Y0(e, t) { if (e === Ht) throw new Error("invert: expected non-zero number"); if (t <= Ht) throw new Error("invert: expected positive modulus, got " + t); let n = Qe(e, t), r = t, i = Ht, s = vt; for (; n !== Ht;) { const a = r / n, f = r % n, h = i - s * a; r = n, n = f, i = s, s = h } if (r !== vt) throw new Error("invert: does not exist"); return Qe(i, t) } function yd(e, t, n) { if (!e.eql(e.sqr(t), n)) throw new Error("Cannot find square root") } function oy(e, t) { const n = (e.ORDER + vt) / ny, r = e.pow(t, n); return yd(e, r, t), r } function Nv(e, t) { const n = (e.ORDER - ry) / iy, r = e.mul(t, Dr), i = e.pow(r, n), s = e.mul(t, i), o = e.mul(e.mul(s, Dr), i), a = e.mul(s, e.sub(o, e.ONE)); return yd(e, a, t), a } function Tv(e) { const t = zr(e), n = ay(e), r = n(t, t.neg(t.ONE)), i = n(t, r), s = n(t, t.neg(r)), o = (e + bv) / sy; return (a, f) => { let h = a.pow(f, o), _ = a.mul(h, r); const v = a.mul(h, i), y = a.mul(h, s), w = a.eql(a.sqr(_), f), p = a.eql(a.sqr(v), f); h = a.cmov(h, _, w), _ = a.cmov(y, v, p); const O = a.eql(a.sqr(_), f), $ = a.cmov(h, _, O); return yd(a, $, f), $ } } function ay(e) { if (e < ty) throw new Error("sqrt is not defined for small field"); let t = e - vt, n = 0; for (; t % Dr === Ht;)t /= Dr, n++; let r = Dr; const i = zr(e); for (; gl(i, r) === 1;)if (r++ > 1e3) throw new Error("Cannot find square root: probably non-prime P"); if (n === 1) return oy; let s = i.pow(r, t); const o = (t + vt) / Dr; return function (f, h) { if (f.is0(h)) return h; if (gl(f, h) !== 1) throw new Error("Cannot find square root"); let _ = n, v = f.mul(f.ONE, s), y = f.pow(h, t), w = f.pow(h, o); for (; !f.eql(y, f.ONE);) { if (f.is0(y)) return f.ZERO; let p = 1, O = f.sqr(y); for (; !f.eql(O, f.ONE);)if (p++, O = f.sqr(O), p === _) throw new Error("Cannot find square root"); const $ = vt << BigInt(_ - p - 1), b = f.pow(v, $); _ = p, v = f.sqr(b), y = f.mul(y, v), w = f.mul(w, b) } return w } } function Bv(e) { return e % ny === ty ? oy : e % iy === ry ? Nv : e % sy === Sv ? Tv(e) : ay(e) } const Av = (e, t) => (Qe(e, t) & vt) === vt, kv = ["create", "isValid", "is0", "neg", "inv", "sqrt", "sqr", "eql", "add", "sub", "mul", "pow", "div", "addN", "subN", "mulN", "sqrN"]; function ly(e) { const t = { ORDER: "bigint", MASK: "bigint", BYTES: "number", BITS: "number" }, n = kv.reduce((r, i) => (r[i] = "function", r), t); return Oo(e, n), e } function Na(e, t, n) { if (n < Ht) throw new Error("invalid exponent, negatives unsupported"); if (n === Ht) return e.ONE; if (n === vt) return t; let r = e.ONE, i = t; for (; n > Ht;)n & vt && (r = e.mul(r, i)), i = e.sqr(i), n >>= vt; return r } function si(e, t, n = !1) { const r = new Array(t.length).fill(n ? e.ZERO : void 0), i = t.reduce((o, a, f) => e.is0(a) ? o : (r[f] = o, e.mul(o, a)), e.ONE), s = e.inv(i); return t.reduceRight((o, a, f) => e.is0(a) ? o : (r[f] = e.mul(o, r[f]), e.mul(o, a)), s), r } function gl(e, t) { const n = (e.ORDER - vt) / Dr, r = e.pow(t, n), i = e.eql(r, e.ONE), s = e.eql(r, e.ZERO), o = e.eql(r, e.neg(e.ONE)); if (!i && !s && !o) throw new Error("invalid Legendre symbol result"); return i ? 1 : s ? 0 : -1 } function Rv(e, t) { t !== void 0 && V2(t); const n = t !== void 0 ? t : e.toString(2).length, r = Math.ceil(n / 8); return { nBitLength: n, nByteLength: r } } function zr(e, t, n = !1, r = {}) { if (e <= Ht) throw new Error("invalid field: expected ORDER > 0, got " + e); let i, s, o = !1, a; if (typeof t == "object" && t != null) { if (r.sqrt || n) throw new Error("cannot specify opts in two arguments"); const y = t; y.BITS && (i = y.BITS), y.sqrt && (s = y.sqrt), typeof y.isLE == "boolean" && (n = y.isLE), typeof y.modOnDecode == "boolean" && (o = y.modOnDecode), a = y.allowedLengths } else typeof t == "number" && (i = t), r.sqrt && (s = r.sqrt); const { nBitLength: f, nByteLength: h } = Rv(e, i); if (h > 2048) throw new Error("invalid field: expected ORDER of <= 2048 bytes"); let _; const v = Object.freeze({ ORDER: e, isLE: n, BITS: f, BYTES: h, MASK: ii(f), ZERO: Ht, ONE: vt, allowedLengths: a, create: y => Qe(y, e), isValid: y => { if (typeof y != "bigint") throw new Error("invalid field element: expected bigint, got " + typeof y); return Ht <= y && y < e }, is0: y => y === Ht, isValidNot0: y => !v.is0(y) && v.isValid(y), isOdd: y => (y & vt) === vt, neg: y => Qe(-y, e), eql: (y, w) => y === w, sqr: y => Qe(y * y, e), add: (y, w) => Qe(y + w, e), sub: (y, w) => Qe(y - w, e), mul: (y, w) => Qe(y * w, e), pow: (y, w) => Na(v, y, w), div: (y, w) => Qe(y * Y0(w, e), e), sqrN: y => y * y, addN: (y, w) => y + w, subN: (y, w) => y - w, mulN: (y, w) => y * w, inv: y => Y0(y, e), sqrt: s || (y => (_ || (_ = Bv(e)), _(v, y))), toBytes: y => n ? Yl(y, h) : wt(y, h), fromBytes: (y, w = !0) => { if (a) { if (!a.includes(y.length) || y.length > h) throw new Error("Field.fromBytes: expected " + a + " bytes, got " + y.length); const O = new Uint8Array(h); O.set(y, n ? 0 : O.length - y.length), y = O } if (y.length !== h) throw new Error("Field.fromBytes: expected " + h + " bytes, got " + y.length); let p = n ? go(y) : zn(y); if (o && (p = Qe(p, e)), !w && !v.isValid(p)) throw new Error("invalid field element: outside of range 0..ORDER"); return p }, invertBatch: y => si(v, y), cmov: (y, w, p) => p ? w : y }); return Object.freeze(v) } function uy(e) { if (typeof e != "bigint") throw new Error("field order must be bigint"); const t = e.toString(2).length; return Math.ceil(t / 8) } function cy(e) { const t = uy(e); return t + Math.ceil(t / 2) } function Iv(e, t, n = !1) { const r = e.length, i = uy(t), s = cy(t); if (r < 16 || r < s || r > 1024) throw new Error("expected " + s + "-1024 bytes of input, got " + r); const o = n ? go(e) : zn(e), a = Qe(o, t - vt) + vt; return n ? Yl(a, i) : wt(a, i) }/*! noble-curves - MIT License (c) 2022 Paul Miller (paulmillr.com) */const hs = BigInt(0), Jr = BigInt(1); function wl(e, t) { const n = t.negate(); return e ? n : t } function er(e, t) { const n = si(e.Fp, t.map(r => r.Z)); return t.map((r, i) => e.fromAffine(r.toAffine(n[i]))) } function fy(e, t) { if (!Number.isSafeInteger(e) || e <= 0 || e > t) throw new Error("invalid window size, expected [1.." + t + "], got W=" + e) } function Vu(e, t) { fy(e, t); const n = Math.ceil(t / e) + 1, r = 2 ** (e - 1), i = 2 ** e, s = ii(e), o = BigInt(e); return { windows: n, windowSize: r, mask: s, maxNumber: i, shiftBy: o } } function K0(e, t, n) { const { windowSize: r, mask: i, maxNumber: s, shiftBy: o } = n; let a = Number(e & i), f = e >> o; a > r && (a -= s, f += Jr); const h = t * r, _ = h + Math.abs(a) - 1, v = a === 0, y = a < 0, w = t % 2 !== 0; return { nextN: f, offset: _, isZero: v, isNeg: y, isNegF: w, offsetF: h } } function Ov(e, t) { if (!Array.isArray(e)) throw new Error("array expected"); e.forEach((n, r) => { if (!(n instanceof t)) throw new Error("invalid point at index " + r) }) } function Uv(e, t) { if (!Array.isArray(e)) throw new Error("array of scalars expected"); e.forEach((n, r) => { if (!t.isValid(n)) throw new Error("invalid scalar at index " + r) }) } const qu = new WeakMap, dy = new WeakMap; function Hu(e) { return dy.get(e) || 1 } function Z0(e) { if (e !== hs) throw new Error("invalid wNAF") } class hy { constructor(t, n) { this.BASE = t.BASE, this.ZERO = t.ZERO, this.Fn = t.Fn, this.bits = n } _unsafeLadder(t, n, r = this.ZERO) { let i = t; for (; n > hs;)n & Jr && (r = r.add(i)), i = i.double(), n >>= Jr; return r } precomputeWindow(t, n) { const { windows: r, windowSize: i } = Vu(n, this.bits), s = []; let o = t, a = o; for (let f = 0; f < r; f++) { a = o, s.push(a); for (let h = 1; h < i; h++)a = a.add(o), s.push(a); o = a.double() } return s } wNAF(t, n, r) { if (!this.Fn.isValid(r)) throw new Error("invalid scalar"); let i = this.ZERO, s = this.BASE; const o = Vu(t, this.bits); for (let a = 0; a < o.windows; a++) { const { nextN: f, offset: h, isZero: _, isNeg: v, isNegF: y, offsetF: w } = K0(r, a, o); r = f, _ ? s = s.add(wl(y, n[w])) : i = i.add(wl(v, n[h])) } return Z0(r), { p: i, f: s } } wNAFUnsafe(t, n, r, i = this.ZERO) { const s = Vu(t, this.bits); for (let o = 0; o < s.windows && r !== hs; o++) { const { nextN: a, offset: f, isZero: h, isNeg: _ } = K0(r, o, s); if (r = a, !h) { const v = n[f]; i = i.add(_ ? v.negate() : v) } } return Z0(r), i } getPrecomputes(t, n, r) { let i = qu.get(n); return i || (i = this.precomputeWindow(n, t), t !== 1 && (typeof r == "function" && (i = r(i)), qu.set(n, i))), i } cached(t, n, r) { const i = Hu(t); return this.wNAF(i, this.getPrecomputes(i, t, r), n) } unsafe(t, n, r, i) { const s = Hu(t); return s === 1 ? this._unsafeLadder(t, n, i) : this.wNAFUnsafe(s, this.getPrecomputes(s, t, r), n, i) } createCache(t, n) { fy(n, this.bits), dy.set(t, n), qu.delete(t) } hasCache(t) { return Hu(t) !== 1 } } function Fv(e, t, n, r) { let i = t, s = e.ZERO, o = e.ZERO; for (; n > hs || r > hs;)n & Jr && (s = s.add(i)), r & Jr && (o = o.add(i)), i = i.double(), n >>= Jr, r >>= Jr; return { p1: s, p2: o } } function py(e, t, n, r) { Ov(n, e), Uv(r, t); const i = n.length, s = r.length; if (i !== s) throw new Error("arrays of points and scalars must have equal length"); const o = e.ZERO, a = es(BigInt(i)); let f = 1; a > 12 ? f = a - 3 : a > 4 ? f = a - 2 : a > 0 && (f = 2); const h = ii(f), _ = new Array(Number(h) + 1).fill(o), v = Math.floor((t.BITS - 1) / f) * f; let y = o; for (let w = v; w >= 0; w -= f) { _.fill(o); for (let O = 0; O < s; O++) { const $ = r[O], b = Number($ >> BigInt(w) & h); _[b] = _[b].add(n[O]) } let p = o; for (let O = _.length - 1, $ = o; O > 0; O--)$ = $.add(_[O]), p = p.add($); if (y = y.add(p), w !== 0) for (let O = 0; O < f; O++)y = y.double() } return y } function X0(e, t) { if (t) { if (t.ORDER !== e) throw new Error("Field.ORDER must match order: Fp == p, Fn == n"); return ly(t), t } else return zr(e) } function my(e, t, n = {}) { if (!t || typeof t != "object") throw new Error(`expected valid ${e} CURVE object`); for (const a of ["p", "n", "h"]) { const f = t[a]; if (!(typeof f == "bigint" && f > hs)) throw new Error(`CURVE.${a} must be positive bigint`) } const r = X0(t.p, n.Fp), i = X0(t.n, n.Fn), o = ["Gx", "Gy", "a", e === "weierstrass" ? "b" : "d"]; for (const a of o) if (!r.isValid(t[a])) throw new Error(`CURVE.${a} must be valid field element of CURVE.Fp`); return { Fp: r, Fn: i } } const Cv = zn; function xr(e, t) { if (xo(e), xo(t), e < 0 || e >= 1 << 8 * t) throw new Error("invalid I2OSP input: " + e); const n = Array.from({ length: t }).fill(0); for (let r = t - 1; r >= 0; r--)n[r] = e & 255, e >>>= 8; return new Uint8Array(n) } function Pv(e, t) { const n = new Uint8Array(e.length); for (let r = 0; r < e.length; r++)n[r] = e[r] ^ t[r]; return n } function xo(e) { if (!Number.isSafeInteger(e)) throw new Error("number expected") } function yy(e) { if (!sd(e) && typeof e != "string") throw new Error("DST must be Uint8Array or string"); return typeof e == "string" ? Ao(e) : e } function Mv(e, t, n, r) { It(e), xo(n), t = yy(t), t.length > 255 && (t = r(Je(Ao("H2C-OVERSIZE-DST-"), t))); const { outputLen: i, blockLen: s } = r, o = Math.ceil(n / i); if (n > 65535 || o > 255) throw new Error("expand_message_xmd: invalid lenInBytes"); const a = Je(t, xr(t.length, 1)), f = xr(0, s), h = xr(n, 2), _ = new Array(o), v = r(Je(f, e, h, xr(0, 1), a)); _[0] = r(Je(v, xr(1, 1), a)); for (let w = 1; w <= o; w++) { const p = [Pv(v, _[w - 1]), xr(w + 1, 1), a]; _[w] = r(Je(...p)) } return Je(..._).slice(0, n) } function jv(e, t, n, r, i) { if (It(e), xo(n), t = yy(t), t.length > 255) { const s = Math.ceil(2 * r / 8); t = i.create({ dkLen: s }).update(Ao("H2C-OVERSIZE-DST-")).update(t).digest() } if (n > 65535 || t.length > 255) throw new Error("expand_message_xof: invalid lenInBytes"); return i.create({ dkLen: n }).update(e).update(xr(n, 2)).update(t).update(xr(t.length, 1)).digest() } function Gu(e, t, n) { Oo(n, { p: "bigint", m: "number", k: "number", hash: "function" }); const { p: r, k: i, m: s, hash: o, expand: a, DST: f } = n; if (!Ev(n.hash)) throw new Error("expected valid hash"); It(e), xo(t); const h = r.toString(2).length, _ = Math.ceil((h + i) / 8), v = t * s * _; let y; if (a === "xmd") y = Mv(e, f, v, o); else if (a === "xof") y = jv(e, f, v, i, o); else if (a === "_internal_pass") y = e; else throw new Error('expand must be "xmd" or "xof"'); const w = new Array(t); for (let p = 0; p < t; p++) { const O = new Array(s); for (let $ = 0; $ < s; $++) { const b = _ * ($ + p * s), E = y.subarray(b, b + _); O[$] = Qe(Cv(E), r) } w[p] = O } return w } function gy(e, t) { const n = t.map(r => Array.from(r).reverse()); return (r, i) => { const [s, o, a, f] = n.map(v => v.reduce((y, w) => e.add(e.mul(y, r), w))), [h, _] = si(e, [o, f], !0); return r = e.mul(s, h), i = e.mul(i, e.mul(a, _)), { x: r, y: i } } } const $v = Ao("HashToScalar-"); function Q0(e, t, n) { if (typeof t != "function") throw new Error("mapToCurve() must be defined"); function r(s) { return e.fromAffine(t(s)) } function i(s) { const o = s.clearCofactor(); return o.equals(e.ZERO) ? e.ZERO : (o.assertValidity(), o) } return { defaults: n, hashToCurve(s, o) { const a = Object.assign({}, n, o), f = Gu(s, 2, a), h = r(f[0]), _ = r(f[1]); return i(h.add(_)) }, encodeToCurve(s, o) { const a = n.encodeDST ? { DST: n.encodeDST } : {}, f = Object.assign({}, n, a, o), h = Gu(s, 1, f), _ = r(h[0]); return i(_) }, mapToCurve(s) { if (!Array.isArray(s)) throw new Error("expected array of bigints"); for (const o of s) if (typeof o != "bigint") throw new Error("expected array of bigints"); return i(r(s)) }, hashToScalar(s, o) { const a = e.Fn.ORDER, f = Object.assign({}, n, { p: a, m: 1, DST: $v }, o); return Gu(s, 1, f)[0][0] } } }/*! noble-curves - MIT License (c) 2022 Paul Miller (paulmillr.com) */const D0 = (e, t) => (e + (e >= 0 ? t : -t) / Hn) / t; function zv(e, t, n) { const [[r, i], [s, o]] = t, a = D0(o * e, n), f = D0(-i * e, n); let h = e - a * r - f * s, _ = -a * i - f * o; const v = h < ei, y = _ < ei; v && (h = -h), y && (_ = -_); const w = ii(Math.ceil(es(n) / 2)) + Ct; if (h < ei || h >= w || _ < ei || _ >= w) throw new Error("splitScalar (endomorphism): failed, k=" + e); return { k1neg: v, k1: h, k2neg: y, k2: _ } } const ei = BigInt(0), Ct = BigInt(1), Hn = BigInt(2), Hi = BigInt(3), sf = BigInt(4); function wy(e, t, n) { function r(i) { const s = e.sqr(i), o = e.mul(s, i); return e.add(e.add(o, e.mul(i, t)), n) } return r } function xl(e, t) { const { BYTES: n } = e; let r; if (typeof t == "bigint") r = t; else { let i = Mt("private key", t); try { r = e.fromBytes(i) } catch { throw new Error(`invalid private key: expected ui8a of size ${n}, got ${typeof t}`) } } if (!e.isValidNot0(r)) throw new Error("invalid private key: out of range [1..N-1]"); return r } function Vv(e, t = {}) { const { Fp: n, Fn: r } = my("weierstrass", e, t), { h: i, n: s } = e; Oo(t, {}, { allowInfinityPoint: "boolean", clearCofactor: "function", isTorsionFree: "function", fromBytes: "function", toBytes: "function", endo: "object", wrapPrivateKey: "boolean" }); const { endo: o } = t; if (o && (!n.is0(e.a) || typeof o.beta != "bigint" || !Array.isArray(o.basises))) throw new Error('invalid endo: expected "beta": bigint and "basises": array'); function a() { if (!n.isOdd) throw new Error("compression is not supported: Field does not have .isOdd()") } function f(re, U, K) { const { x: ee, y: N } = U.toAffine(), F = n.toBytes(ee); if (yo("isCompressed", K), K) { a(); const G = !n.isOdd(N); return Je(qv(G), F) } else return Je(Uint8Array.of(4), F, n.toBytes(N)) } function h(re) { It(re); const U = n.BYTES, K = U + 1, ee = 2 * U + 1, N = re.length, F = re[0], G = re.subarray(1); if (N === K && (F === 2 || F === 3)) { const J = n.fromBytes(G); if (!n.isValid(J)) throw new Error("bad point: is not on curve, wrong x"); const ie = y(J); let z; try { z = n.sqrt(ie) } catch (se) { const oe = se instanceof Error ? ": " + se.message : ""; throw new Error("bad point: is not on curve, sqrt error" + oe) } a(); const D = n.isOdd(z); return (F & 1) === 1 !== D && (z = n.neg(z)), { x: J, y: z } } else if (N === ee && F === 4) { const J = n.fromBytes(G.subarray(U * 0, U * 1)), ie = n.fromBytes(G.subarray(U * 1, U * 2)); if (!w(J, ie)) throw new Error("bad point: is not on curve"); return { x: J, y: ie } } else throw new Error(`bad point: got length ${N}, expected compressed=${K} or uncompressed=${ee}`) } const _ = t.toBytes || f, v = t.fromBytes || h, y = wy(n, e.a, e.b); function w(re, U) { const K = n.sqr(U), ee = y(re); return n.eql(K, ee) } if (!w(e.Gx, e.Gy)) throw new Error("bad curve params: generator point"); const p = n.mul(n.pow(e.a, Hi), sf), O = n.mul(n.sqr(e.b), BigInt(27)); if (n.is0(n.add(p, O))) throw new Error("bad curve params: a or b"); function $(re, U, K = !1) { if (!n.isValid(U) || K && n.is0(U)) throw new Error(`bad point coordinate ${re}`); return U } function b(re) { if (!(re instanceof C)) throw new Error("ProjectivePoint expected") } function E(re) { if (!o || !o.basises) throw new Error("no endo"); return zv(re, o.basises, r.ORDER) } const S = wo((re, U) => { const { X: K, Y: ee, Z: N } = re; if (n.eql(N, n.ONE)) return { x: K, y: ee }; const F = re.is0(); U == null && (U = F ? n.ONE : n.inv(N)); const G = n.mul(K, U), J = n.mul(ee, U), ie = n.mul(N, U); if (F) return { x: n.ZERO, y: n.ZERO }; if (!n.eql(ie, n.ONE)) throw new Error("invZ was invalid"); return { x: G, y: J } }), M = wo(re => { if (re.is0()) { if (t.allowInfinityPoint && !n.is0(re.Y)) return; throw new Error("bad point: ZERO") } const { x: U, y: K } = re.toAffine(); if (!n.isValid(U) || !n.isValid(K)) throw new Error("bad point: x or y not field elements"); if (!w(U, K)) throw new Error("bad point: equation left != right"); if (!re.isTorsionFree()) throw new Error("bad point: not in prime-order subgroup"); return !0 }); function k(re, U, K, ee, N) { return K = new C(n.mul(K.X, re), K.Y, K.Z), U = wl(ee, U), K = wl(N, K), U.add(K) } class C { constructor(U, K, ee) { this.X = $("x", U), this.Y = $("y", K, !0), this.Z = $("z", ee), Object.freeze(this) } static fromAffine(U) { const { x: K, y: ee } = U || {}; if (!U || !n.isValid(K) || !n.isValid(ee)) throw new Error("invalid affine point"); if (U instanceof C) throw new Error("projective point not allowed"); return n.is0(K) && n.is0(ee) ? C.ZERO : new C(K, ee, n.ONE) } get x() { return this.toAffine().x } get y() { return this.toAffine().y } get px() { return this.X } get py() { return this.X } get pz() { return this.Z } static normalizeZ(U) { return er(C, U) } static fromBytes(U) { return It(U), C.fromHex(U) } static fromHex(U) { const K = C.fromAffine(v(Mt("pointHex", U))); return K.assertValidity(), K } static fromPrivateKey(U) { return C.BASE.multiply(xl(r, U)) } static msm(U, K) { return py(C, r, U, K) } _setWindowSize(U) { this.precompute(U) } precompute(U = 8, K = !0) { return Y.createCache(this, U), K || this.multiply(Hi), this } assertValidity() { M(this) } hasEvenY() { const { y: U } = this.toAffine(); if (!n.isOdd) throw new Error("Field doesn't support isOdd"); return !n.isOdd(U) } equals(U) { b(U); const { X: K, Y: ee, Z: N } = this, { X: F, Y: G, Z: J } = U, ie = n.eql(n.mul(K, J), n.mul(F, N)), z = n.eql(n.mul(ee, J), n.mul(G, N)); return ie && z } negate() { return new C(this.X, n.neg(this.Y), this.Z) } double() { const { a: U, b: K } = e, ee = n.mul(K, Hi), { X: N, Y: F, Z: G } = this; let J = n.ZERO, ie = n.ZERO, z = n.ZERO, D = n.mul(N, N), ae = n.mul(F, F), se = n.mul(G, G), oe = n.mul(N, F); return oe = n.add(oe, oe), z = n.mul(N, G), z = n.add(z, z), J = n.mul(U, z), ie = n.mul(ee, se), ie = n.add(J, ie), J = n.sub(ae, ie), ie = n.add(ae, ie), ie = n.mul(J, ie), J = n.mul(oe, J), z = n.mul(ee, z), se = n.mul(U, se), oe = n.sub(D, se), oe = n.mul(U, oe), oe = n.add(oe, z), z = n.add(D, D), D = n.add(z, D), D = n.add(D, se), D = n.mul(D, oe), ie = n.add(ie, D), se = n.mul(F, G), se = n.add(se, se), D = n.mul(se, oe), J = n.sub(J, D), z = n.mul(se, ae), z = n.add(z, z), z = n.add(z, z), new C(J, ie, z) } add(U) { b(U); const { X: K, Y: ee, Z: N } = this, { X: F, Y: G, Z: J } = U; let ie = n.ZERO, z = n.ZERO, D = n.ZERO; const ae = e.a, se = n.mul(e.b, Hi); let oe = n.mul(K, F), Ae = n.mul(ee, G), B = n.mul(N, J), Pe = n.add(K, ee), Ee = n.add(F, G); Pe = n.mul(Pe, Ee), Ee = n.add(oe, Ae), Pe = n.sub(Pe, Ee), Ee = n.add(K, N); let Ue = n.add(F, J); return Ee = n.mul(Ee, Ue), Ue = n.add(oe, B), Ee = n.sub(Ee, Ue), Ue = n.add(ee, N), ie = n.add(G, J), Ue = n.mul(Ue, ie), ie = n.add(Ae, B), Ue = n.sub(Ue, ie), D = n.mul(ae, Ee), ie = n.mul(se, B), D = n.add(ie, D), ie = n.sub(Ae, D), D = n.add(Ae, D), z = n.mul(ie, D), Ae = n.add(oe, oe), Ae = n.add(Ae, oe), B = n.mul(ae, B), Ee = n.mul(se, Ee), Ae = n.add(Ae, B), B = n.sub(oe, B), B = n.mul(ae, B), Ee = n.add(Ee, B), oe = n.mul(Ae, Ee), z = n.add(z, oe), oe = n.mul(Ue, Ee), ie = n.mul(Pe, ie), ie = n.sub(ie, oe), oe = n.mul(Pe, Ae), D = n.mul(Ue, D), D = n.add(D, oe), new C(ie, z, D) } subtract(U) { return this.add(U.negate()) } is0() { return this.equals(C.ZERO) } multiply(U) { const { endo: K } = t; if (!r.isValidNot0(U)) throw new Error("invalid scalar: out of range"); let ee, N; const F = G => Y.cached(this, G, J => er(C, J)); if (K) { const { k1neg: G, k1: J, k2neg: ie, k2: z } = E(U), { p: D, f: ae } = F(J), { p: se, f: oe } = F(z); N = ae.add(oe), ee = k(K.beta, D, se, G, ie) } else { const { p: G, f: J } = F(U); ee = G, N = J } return er(C, [ee, N])[0] } multiplyUnsafe(U) { const { endo: K } = t, ee = this; if (!r.isValid(U)) throw new Error("invalid scalar: out of range"); if (U === ei || ee.is0()) return C.ZERO; if (U === Ct) return ee; if (Y.hasCache(this)) return this.multiply(U); if (K) { const { k1neg: N, k1: F, k2neg: G, k2: J } = E(U), { p1: ie, p2: z } = Fv(C, ee, F, J); return k(K.beta, ie, z, N, G) } else return Y.unsafe(ee, U) } multiplyAndAddUnsafe(U, K, ee) { const N = this.multiplyUnsafe(K).add(U.multiplyUnsafe(ee)); return N.is0() ? void 0 : N } toAffine(U) { return S(this, U) } isTorsionFree() { const { isTorsionFree: U } = t; return i === Ct ? !0 : U ? U(C, this) : Y.unsafe(this, s).is0() } clearCofactor() { const { clearCofactor: U } = t; return i === Ct ? this : U ? U(C, this) : this.multiplyUnsafe(i) } isSmallOrder() { return this.multiplyUnsafe(i).is0() } toBytes(U = !0) { return yo("isCompressed", U), this.assertValidity(), _(C, this, U) } toRawBytes(U = !0) { return this.toBytes(U) } toHex(U = !0) { return fs(this.toBytes(U)) } toString() { return `<Point ${this.is0() ? "ZERO" : this.toHex()}>` } } C.BASE = new C(e.Gx, e.Gy, n.ONE), C.ZERO = new C(n.ZERO, n.ONE, n.ZERO), C.Fp = n, C.Fn = r; const V = r.BITS, Y = new hy(C, t.endo ? Math.ceil(V / 2) : V); return C } function J0(e) { const { CURVE: t, curveOpts: n } = Gv(e), r = Vv(t, n); return Lv(e, r) } function qv(e) { return Uint8Array.of(e ? 2 : 3) } function Hv(e, t) { const n = e.ORDER; let r = ei; for (let p = n - Ct; p % Hn === ei; p /= Hn)r += Ct; const i = r, s = Hn << i - Ct - Ct, o = s * Hn, a = (n - Ct) / o, f = (a - Ct) / Hn, h = o - Ct, _ = s, v = e.pow(t, a), y = e.pow(t, (a + Ct) / Hn); let w = (p, O) => { let $ = v, b = e.pow(O, h), E = e.sqr(b); E = e.mul(E, O); let S = e.mul(p, E); S = e.pow(S, f), S = e.mul(S, b), b = e.mul(S, O), E = e.mul(S, p); let M = e.mul(E, b); S = e.pow(M, _); let k = e.eql(S, e.ONE); b = e.mul(E, y), S = e.mul(M, $), E = e.cmov(b, E, k), M = e.cmov(S, M, k); for (let C = i; C > Ct; C--) { let V = C - Hn; V = Hn << V - Ct; let Y = e.pow(M, V); const re = e.eql(Y, e.ONE); b = e.mul(E, $), $ = e.mul($, $), Y = e.mul(M, $), E = e.cmov(b, E, re), M = e.cmov(Y, M, re) } return { isValid: k, value: E } }; if (e.ORDER % sf === Hi) { const p = (e.ORDER - Hi) / sf, O = e.sqrt(e.neg(t)); w = ($, b) => { let E = e.sqr(b); const S = e.mul($, b); E = e.mul(E, S); let M = e.pow(E, p); M = e.mul(M, S); const k = e.mul(M, O), C = e.mul(e.sqr(M), b), V = e.eql(C, $); let Y = e.cmov(k, M, V); return { isValid: V, value: Y } } } return w } function xy(e, t) { ly(e); const { A: n, B: r, Z: i } = t; if (!e.isValid(n) || !e.isValid(r) || !e.isValid(i)) throw new Error("mapToCurveSimpleSWU: invalid opts"); const s = Hv(e, i); if (!e.isOdd) throw new Error("Field does not have .isOdd()"); return o => { let a, f, h, _, v, y, w, p; a = e.sqr(o), a = e.mul(a, i), f = e.sqr(a), f = e.add(f, a), h = e.add(f, e.ONE), h = e.mul(h, r), _ = e.cmov(i, e.neg(f), !e.eql(f, e.ZERO)), _ = e.mul(_, n), f = e.sqr(h), y = e.sqr(_), v = e.mul(y, n), f = e.add(f, v), f = e.mul(f, h), y = e.mul(y, _), v = e.mul(y, r), f = e.add(f, v), w = e.mul(a, h); const { isValid: O, value: $ } = s(f, y); p = e.mul(a, o), p = e.mul(p, $), w = e.cmov(w, h, O), p = e.cmov(p, $, O); const b = e.isOdd(o) === e.isOdd(p); p = e.cmov(e.neg(p), p, b); const E = si(e, [_], !0)[0]; return w = e.mul(w, E), { x: w, y: p } } } function Gv(e) { const t = { a: e.a, b: e.b, p: e.Fp.ORDER, n: e.n, h: e.h, Gx: e.Gx, Gy: e.Gy }, n = e.Fp; let r = e.allowedPrivateKeyLengths ? Array.from(new Set(e.allowedPrivateKeyLengths.map(o => Math.ceil(o / 2)))) : void 0; const i = zr(t.n, { BITS: e.nBitLength, allowedLengths: r, modOnDecode: e.wrapPrivateKey }), s = { Fp: n, Fn: i, allowInfinityPoint: e.allowInfinityPoint, endo: e.endo, isTorsionFree: e.isTorsionFree, clearCofactor: e.clearCofactor, fromBytes: e.fromBytes, toBytes: e.toBytes }; return { CURVE: t, curveOpts: s } } function Lv(e, t) { const { Fp: n, Fn: r } = t; function i(o) { return ey(o, Ct, r.ORDER) } const s = wy(n, e.a, e.b); return Object.assign({}, { CURVE: e, Point: t, ProjectivePoint: t, normPrivateKeyToScalar: o => xl(r, o), weierstrassEquation: s, isWithinCurveOrder: i }) }/*! noble-curves - MIT License (c) 2022 Paul Miller (paulmillr.com) */const Wv = BigInt(0), oa = BigInt(1), eh = BigInt(2), Gi = BigInt(3); function Yv(e) { const t = []; for (; e > oa; e >>= oa)(e & oa) === Wv ? t.unshift(0) : (e & Gi) === Gi ? (t.unshift(-1), e += oa) : t.unshift(1); return t } function Lu(e) { if (!Array.isArray(e) || e.length === 0) throw new Error("expected non-empty array") } function Kv(e, t, n, r) { const { Fp2: i, Fp12: s } = e, { twistType: o, ateLoopSize: a, xNegative: f, postPrecompute: h } = r; let _; if (o === "multiplicative") _ = (S, M, k, C, V, Y) => s.mul014(C, S, i.mul(M, V), i.mul(k, Y)); else if (o === "divisive") _ = (S, M, k, C, V, Y) => s.mul034(C, i.mul(k, Y), i.mul(M, V), S); else throw new Error("bls: unknown twist type"); const v = i.div(i.ONE, i.mul(i.ONE, eh)); function y(S, M, k, C) { const V = i.sqr(k), Y = i.sqr(C), re = i.mulByB(i.mul(Y, Gi)), U = i.mul(re, Gi), K = i.sub(i.sub(i.sqr(i.add(k, C)), Y), V), ee = i.sub(re, V), N = i.mul(i.sqr(M), Gi), F = i.neg(K); return S.push([ee, N, F]), M = i.mul(i.mul(i.mul(i.sub(V, U), M), k), v), k = i.sub(i.sqr(i.mul(i.add(V, U), v)), i.mul(i.sqr(re), Gi)), C = i.mul(V, K), { Rx: M, Ry: k, Rz: C } } function w(S, M, k, C, V, Y) { const re = i.sub(k, i.mul(Y, C)), U = i.sub(M, i.mul(V, C)), K = i.sub(i.mul(re, V), i.mul(U, Y)), ee = i.neg(re), N = U; S.push([K, ee, N]); const F = i.sqr(U), G = i.mul(F, U), J = i.mul(F, M), ie = i.add(i.sub(G, i.mul(J, eh)), i.mul(i.sqr(re), C)); return M = i.mul(U, ie), k = i.sub(i.mul(i.sub(J, ie), re), i.mul(G, k)), C = i.mul(C, G), { Rx: M, Ry: k, Rz: C } } const p = Yv(a), O = wo(S => { const M = S, { x: k, y: C } = M.toAffine(), V = k, Y = C, re = i.neg(C); let U = V, K = Y, ee = i.ONE; const N = []; for (const F of p) { const G = []; ({ Rx: U, Ry: K, Rz: ee } = y(G, U, K, ee)), F && ({ Rx: U, Ry: K, Rz: ee } = w(G, U, K, ee, V, F === -1 ? re : Y)), N.push(G) } if (h) { const F = N[N.length - 1]; h(U, K, ee, V, Y, w.bind(null, F)) } return N }); function $(S, M = !1) { let k = s.ONE; if (S.length) { const C = S[0][0].length; for (let V = 0; V < C; V++) { k = s.sqr(k); for (const [Y, re, U] of S) for (const [K, ee, N] of Y[V]) k = _(K, ee, N, k, re, U) } } return f && (k = s.conjugate(k)), M ? s.finalExponentiate(k) : k } function b(S, M = !0) { const k = []; er(t, S.map(({ g1: C }) => C)), er(n, S.map(({ g2: C }) => C)); for (const { g1: C, g2: V } of S) { if (C.is0() || V.is0()) throw new Error("pairing is not available for ZERO point"); C.assertValidity(), V.assertValidity(); const Y = C.toAffine(); k.push([O(V), Y.x, Y.y]) } return $(k, M) } function E(S, M, k = !0) { return b([{ g1: S, g2: M }], k) } return { Fp12: s, millerLoopBatch: $, pairing: E, pairingBatch: b, calcPairingPrecomputes: O } } function th(e, t, n, r, i) { const { Fp12: s, pairingBatch: o } = e; function a(v) { return v instanceof t.Point ? v : t.Point.fromHex(v) } function f(v) { return v instanceof n.Point ? v : n.Point.fromHex(v) } function h(v) { if (!(v instanceof n.Point)) throw new Error(`expected valid message hashed to ${i ? "G1" : "G2"} curve`); return v } const _ = i ? (v, y) => ({ g1: y, g2: v }) : (v, y) => ({ g1: v, g2: y }); return { getPublicKey(v) { const y = xl(t.Point.Fn, v); return t.Point.BASE.multiply(y) }, sign(v, y, w) { if (w != null) throw new Error("sign() expects 2 arguments"); const p = xl(t.Point.Fn, y); return h(v).assertValidity(), v.multiply(p) }, verify(v, y, w, p) { if (p != null) throw new Error("verify() expects 3 arguments"); v = f(v), w = a(w); const O = w.negate(), $ = t.Point.BASE, b = h(y), E = v, S = o([_(O, b), _($, E)]); return s.eql(S, s.ONE) }, verifyBatch(v, y, w) { if (Lu(y), w.length !== y.length) throw new Error("amount of public keys and messages should be equal"); const p = f(v), O = y, $ = w.map(a), b = new Map; for (let M = 0; M < $.length; M++) { const k = $[M], C = O[M]; let V = b.get(C); V === void 0 && (V = [], b.set(C, V)), V.push(k) } const E = [], S = t.Point.BASE; try { for (const [M, k] of b) { const C = k.reduce((V, Y) => V.add(Y)); E.push(_(C, M)) } return E.push(_(S.negate(), p)), s.eql(o(E), s.ONE) } catch { return !1 } }, aggregatePublicKeys(v) { Lu(v), v = v.map(w => a(w)); const y = v.reduce((w, p) => w.add(p), t.Point.ZERO); return y.assertValidity(), y }, aggregateSignatures(v) { Lu(v), v = v.map(w => f(w)); const y = v.reduce((w, p) => w.add(p), n.Point.ZERO); return y.assertValidity(), y }, hash(v, y) { It(v); const w = y ? { DST: y } : void 0; return n.hashToCurve(v, w) }, Signature: r } } function Zv(e) { const { Fp: t, Fr: n, Fp2: r, Fp6: i, Fp12: s } = e.fields, o = J0(e.G1), a = Object.assign(o, Q0(o.Point, e.G1.mapToCurve, { ...e.htfDefaults, ...e.G1.htfDefaults })), f = J0(e.G2), h = Object.assign(f, Q0(f.Point, e.G2.mapToCurve, { ...e.htfDefaults, ...e.G2.htfDefaults })), _ = Kv(e.fields, a.Point, h.Point, { ...e.params, postPrecompute: e.postPrecompute }), { millerLoopBatch: v, pairing: y, pairingBatch: w, calcPairingPrecomputes: p } = _, O = th(_, a, h, e.G2.Signature, !1), $ = th(_, h, a, e.G1.ShortSignature, !0), b = e.randomBytes || $1, E = () => { const z = cy(n.ORDER); return Iv(b(z), n.ORDER) }, S = { randomSecretKey: E, randomPrivateKey: E, calcPairingPrecomputes: p }, { ShortSignature: M } = e.G1, { Signature: k } = e.G2; function C(z, D) { return z instanceof a.Point ? z : $.hash(Mt("point", z), D == null ? void 0 : D.DST) } function V(z, D) { return z instanceof h.Point ? z : O.hash(Mt("point", z), D == null ? void 0 : D.DST) } function Y(z) { return O.getPublicKey(z).toBytes(!0) } function re(z) { return $.getPublicKey(z).toBytes(!0) } function U(z, D, ae) { const se = V(z, ae), oe = O.sign(se, D); return z instanceof h.Point ? oe : k.toBytes(oe) } function K(z, D, ae) { const se = C(z, ae), oe = $.sign(se, D); return z instanceof a.Point ? oe : M.toBytes(oe) } function ee(z, D, ae, se) { const oe = V(D, se); return O.verify(z, oe, ae) } function N(z, D, ae, se) { const oe = C(D, se); return $.verify(z, oe, ae) } function F(z) { const D = O.aggregatePublicKeys(z); return z[0] instanceof a.Point ? D : D.toBytes(!0) } function G(z) { const D = O.aggregateSignatures(z); return z[0] instanceof h.Point ? D : k.toBytes(D) } function J(z) { const D = $.aggregateSignatures(z); return z[0] instanceof a.Point ? D : M.toBytes(D) } function ie(z, D, ae, se) { const oe = D.map(Ae => V(Ae, se)); return O.verifyBatch(z, oe, ae) } return a.Point.BASE.precompute(4), { longSignatures: O, shortSignatures: $, millerLoopBatch: v, pairing: y, pairingBatch: w, verifyBatch: ie, fields: { Fr: n, Fp: t, Fp2: r, Fp6: i, Fp12: s }, params: { ateLoopSize: e.params.ateLoopSize, twistType: e.params.twistType, r: e.params.r, G1b: e.G1.b, G2b: e.G2.b }, utils: S, getPublicKey: Y, getPublicKeyForShortSignatures: re, sign: U, signShortSignature: K, verify: ee, verifyShortSignature: N, aggregatePublicKeys: F, aggregateSignatures: G, aggregateShortSignatures: J, G1: a, G2: h, Signature: k, ShortSignature: M } }/*! noble-curves - MIT License (c) 2022 Paul Miller (paulmillr.com) */const nh = BigInt(0), Li = BigInt(1), Kn = BigInt(2), rh = BigInt(3); function Wu(e, t, n, r, i = 1, s) { const o = BigInt(s === void 0 ? r : s), a = n ** BigInt(r), f = []; for (let h = 0; h < i; h++) { const _ = BigInt(h + 1), v = []; for (let y = 0, w = Li; y < r; y++) { const p = (_ * w - _) / o % a; v.push(e.pow(t, p)), w *= n } f.push(v) } return f } function Xv(e, t, n) { const r = t.pow(n, (e.ORDER - Li) / rh), i = t.pow(n, (e.ORDER - Li) / Kn); function s(y, w) { const p = t.mul(t.frobeniusMap(y, 1), r), O = t.mul(t.frobeniusMap(w, 1), i); return [p, O] } const o = t.pow(n, (e.ORDER ** Kn - Li) / rh), a = t.pow(n, (e.ORDER ** Kn - Li) / Kn); if (!t.eql(a, t.neg(t.ONE))) throw new Error("psiFrobenius: PSI2_Y!==-1"); function f(y, w) { return [t.mul(y, o), t.neg(w)] } const h = y => (w, p) => { const O = p.toAffine(), $ = y(O.x, O.y); return w.fromAffine({ x: $[0], y: $[1] }) }, _ = h(s), v = h(f); return { psi: s, psi2: f, G2psi: _, G2psi2: v, PSI_X: r, PSI_Y: i, PSI2_X: o, PSI2_Y: a } } function Qv(e) { const { ORDER: t } = e, n = zr(t), r = n.create(e.NONRESIDUE || BigInt(-1)), i = n.div(n.ONE, Kn), s = Wu(n, r, n.ORDER, 2)[0], o = ({ c0: N, c1: F }, { c0: G, c1: J }) => ({ c0: n.add(N, G), c1: n.add(F, J) }), a = ({ c0: N, c1: F }, { c0: G, c1: J }) => ({ c0: n.sub(N, G), c1: n.sub(F, J) }), f = ({ c0: N, c1: F }, G) => { if (typeof G == "bigint") return { c0: n.mul(N, G), c1: n.mul(F, G) }; const { c0: J, c1: ie } = G; let z = n.mul(N, J), D = n.mul(F, ie); const ae = n.sub(z, D), se = n.sub(n.mul(n.add(N, F), n.add(J, ie)), n.add(z, D)); return { c0: ae, c1: se } }, h = ({ c0: N, c1: F }) => { const G = n.add(N, F), J = n.sub(N, F), ie = n.add(N, N); return { c0: n.mul(G, J), c1: n.mul(ie, F) } }, _ = N => { if (N.length !== 2) throw new Error("invalid tuple"); const F = N.map(G => n.create(G)); return { c0: F[0], c1: F[1] } }; function v(N, F) { return typeof N == "bigint" && nh <= N && N < F } const y = t * t, w = _(e.FP2_NONRESIDUE), p = { ORDER: y, isLE: n.isLE, NONRESIDUE: w, BITS: es(y), BYTES: Math.ceil(es(y) / 8), MASK: ii(es(y)), ZERO: { c0: n.ZERO, c1: n.ZERO }, ONE: { c0: n.ONE, c1: n.ZERO }, create: N => N, isValid: ({ c0: N, c1: F }) => v(N, y) && v(F, y), is0: ({ c0: N, c1: F }) => n.is0(N) && n.is0(F), isValidNot0: N => !p.is0(N) && p.isValid(N), eql: ({ c0: N, c1: F }, { c0: G, c1: J }) => n.eql(N, G) && n.eql(F, J), neg: ({ c0: N, c1: F }) => ({ c0: n.neg(N), c1: n.neg(F) }), pow: (N, F) => Na(p, N, F), invertBatch: N => si(p, N), add: o, sub: a, mul: f, sqr: h, addN: o, subN: a, mulN: f, sqrN: h, div: (N, F) => p.mul(N, typeof F == "bigint" ? n.inv(n.create(F)) : p.inv(F)), inv: ({ c0: N, c1: F }) => { const G = n.inv(n.create(N * N + F * F)); return { c0: n.mul(G, n.create(N)), c1: n.mul(G, n.create(-F)) } }, sqrt: N => { if (e.Fp2sqrt) return e.Fp2sqrt(N); const { c0: F, c1: G } = N; if (n.is0(G)) return gl(n, F) === 1 ? p.create({ c0: n.sqrt(F), c1: n.ZERO }) : p.create({ c0: n.ZERO, c1: n.sqrt(n.div(F, r)) }); const J = n.sqrt(n.sub(n.sqr(F), n.mul(n.sqr(G), r))); let ie = n.mul(n.add(J, F), i); gl(n, ie) === -1 && (ie = n.sub(ie, J)); const D = n.sqrt(ie), ae = p.create({ c0: D, c1: n.div(n.mul(G, i), D) }); if (!p.eql(p.sqr(ae), N)) throw new Error("Cannot find square root"); const se = ae, oe = p.neg(se), { re: Ae, im: B } = p.reim(se), { re: Pe, im: Ee } = p.reim(oe); return B > Ee || B === Ee && Ae > Pe ? se : oe }, isOdd: N => { const { re: F, im: G } = p.reim(N), J = F % Kn, ie = F === nh, z = G % Kn; return BigInt(J || ie && z) == Li }, fromBytes(N) { if (N.length !== p.BYTES) throw new Error("fromBytes invalid length=" + N.length); return { c0: n.fromBytes(N.subarray(0, n.BYTES)), c1: n.fromBytes(N.subarray(n.BYTES)) } }, toBytes: ({ c0: N, c1: F }) => Je(n.toBytes(N), n.toBytes(F)), cmov: ({ c0: N, c1: F }, { c0: G, c1: J }, ie) => ({ c0: n.cmov(N, G, ie), c1: n.cmov(F, J, ie) }), reim: ({ c0: N, c1: F }) => ({ re: N, im: F }), mulByNonresidue: ({ c0: N, c1: F }) => p.mul({ c0: N, c1: F }, w), mulByB: e.Fp2mulByB, fromBigTuple: _, frobeniusMap: ({ c0: N, c1: F }, G) => ({ c0: N, c1: n.mul(F, s[G % 2]) }) }, O = ({ c0: N, c1: F, c2: G }, { c0: J, c1: ie, c2: z }) => ({ c0: p.add(N, J), c1: p.add(F, ie), c2: p.add(G, z) }), $ = ({ c0: N, c1: F, c2: G }, { c0: J, c1: ie, c2: z }) => ({ c0: p.sub(N, J), c1: p.sub(F, ie), c2: p.sub(G, z) }), b = ({ c0: N, c1: F, c2: G }, J) => { if (typeof J == "bigint") return { c0: p.mul(N, J), c1: p.mul(F, J), c2: p.mul(G, J) }; const { c0: ie, c1: z, c2: D } = J, ae = p.mul(N, ie), se = p.mul(F, z), oe = p.mul(G, D); return { c0: p.add(ae, p.mulByNonresidue(p.sub(p.mul(p.add(F, G), p.add(z, D)), p.add(se, oe)))), c1: p.add(p.sub(p.mul(p.add(N, F), p.add(ie, z)), p.add(ae, se)), p.mulByNonresidue(oe)), c2: p.sub(p.add(se, p.mul(p.add(N, G), p.add(ie, D))), p.add(ae, oe)) } }, E = ({ c0: N, c1: F, c2: G }) => { let J = p.sqr(N), ie = p.mul(p.mul(N, F), Kn), z = p.mul(p.mul(F, G), Kn), D = p.sqr(G); return { c0: p.add(p.mulByNonresidue(z), J), c1: p.add(p.mulByNonresidue(D), ie), c2: p.sub(p.sub(p.add(p.add(ie, p.sqr(p.add(p.sub(N, F), G))), z), J), D) } }, [S, M] = Wu(p, w, n.ORDER, 6, 2, 3), k = { ORDER: p.ORDER, isLE: p.isLE, BITS: 3 * p.BITS, BYTES: 3 * p.BYTES, MASK: ii(3 * p.BITS), ZERO: { c0: p.ZERO, c1: p.ZERO, c2: p.ZERO }, ONE: { c0: p.ONE, c1: p.ZERO, c2: p.ZERO }, create: N => N, isValid: ({ c0: N, c1: F, c2: G }) => p.isValid(N) && p.isValid(F) && p.isValid(G), is0: ({ c0: N, c1: F, c2: G }) => p.is0(N) && p.is0(F) && p.is0(G), isValidNot0: N => !k.is0(N) && k.isValid(N), neg: ({ c0: N, c1: F, c2: G }) => ({ c0: p.neg(N), c1: p.neg(F), c2: p.neg(G) }), eql: ({ c0: N, c1: F, c2: G }, { c0: J, c1: ie, c2: z }) => p.eql(N, J) && p.eql(F, ie) && p.eql(G, z), sqrt: W0, div: (N, F) => k.mul(N, typeof F == "bigint" ? n.inv(n.create(F)) : k.inv(F)), pow: (N, F) => Na(k, N, F), invertBatch: N => si(k, N), add: O, sub: $, mul: b, sqr: E, addN: O, subN: $, mulN: b, sqrN: E, inv: ({ c0: N, c1: F, c2: G }) => { let J = p.sub(p.sqr(N), p.mulByNonresidue(p.mul(G, F))), ie = p.sub(p.mulByNonresidue(p.sqr(G)), p.mul(N, F)), z = p.sub(p.sqr(F), p.mul(N, G)), D = p.inv(p.add(p.mulByNonresidue(p.add(p.mul(G, ie), p.mul(F, z))), p.mul(N, J))); return { c0: p.mul(D, J), c1: p.mul(D, ie), c2: p.mul(D, z) } }, fromBytes: N => { if (N.length !== k.BYTES) throw new Error("fromBytes invalid length=" + N.length); return { c0: p.fromBytes(N.subarray(0, p.BYTES)), c1: p.fromBytes(N.subarray(p.BYTES, 2 * p.BYTES)), c2: p.fromBytes(N.subarray(2 * p.BYTES)) } }, toBytes: ({ c0: N, c1: F, c2: G }) => Je(p.toBytes(N), p.toBytes(F), p.toBytes(G)), cmov: ({ c0: N, c1: F, c2: G }, { c0: J, c1: ie, c2: z }, D) => ({ c0: p.cmov(N, J, D), c1: p.cmov(F, ie, D), c2: p.cmov(G, z, D) }), fromBigSix: N => { if (!Array.isArray(N) || N.length !== 6) throw new Error("invalid Fp6 usage"); return { c0: p.fromBigTuple(N.slice(0, 2)), c1: p.fromBigTuple(N.slice(2, 4)), c2: p.fromBigTuple(N.slice(4, 6)) } }, frobeniusMap: ({ c0: N, c1: F, c2: G }, J) => ({ c0: p.frobeniusMap(N, J), c1: p.mul(p.frobeniusMap(F, J), S[J % 6]), c2: p.mul(p.frobeniusMap(G, J), M[J % 6]) }), mulByFp2: ({ c0: N, c1: F, c2: G }, J) => ({ c0: p.mul(N, J), c1: p.mul(F, J), c2: p.mul(G, J) }), mulByNonresidue: ({ c0: N, c1: F, c2: G }) => ({ c0: p.mulByNonresidue(G), c1: N, c2: F }), mul1: ({ c0: N, c1: F, c2: G }, J) => ({ c0: p.mulByNonresidue(p.mul(G, J)), c1: p.mul(N, J), c2: p.mul(F, J) }), mul01({ c0: N, c1: F, c2: G }, J, ie) { let z = p.mul(N, J), D = p.mul(F, ie); return { c0: p.add(p.mulByNonresidue(p.sub(p.mul(p.add(F, G), ie), D)), z), c1: p.sub(p.sub(p.mul(p.add(J, ie), p.add(N, F)), z), D), c2: p.add(p.sub(p.mul(p.add(N, G), J), z), D) } } }, C = Wu(p, w, n.ORDER, 12, 1, 6)[0], V = ({ c0: N, c1: F }, { c0: G, c1: J }) => ({ c0: k.add(N, G), c1: k.add(F, J) }), Y = ({ c0: N, c1: F }, { c0: G, c1: J }) => ({ c0: k.sub(N, G), c1: k.sub(F, J) }), re = ({ c0: N, c1: F }, G) => { if (typeof G == "bigint") return { c0: k.mul(N, G), c1: k.mul(F, G) }; let { c0: J, c1: ie } = G, z = k.mul(N, J), D = k.mul(F, ie); return { c0: k.add(z, k.mulByNonresidue(D)), c1: k.sub(k.mul(k.add(N, F), k.add(J, ie)), k.add(z, D)) } }, U = ({ c0: N, c1: F }) => { let G = k.mul(N, F); return { c0: k.sub(k.sub(k.mul(k.add(k.mulByNonresidue(F), N), k.add(N, F)), G), k.mulByNonresidue(G)), c1: k.add(G, G) } }; function K(N, F) { const G = p.sqr(N), J = p.sqr(F); return { first: p.add(p.mulByNonresidue(J), G), second: p.sub(p.sub(p.sqr(p.add(N, F)), G), J) } } const ee = { ORDER: p.ORDER, isLE: k.isLE, BITS: 2 * k.BITS, BYTES: 2 * k.BYTES, MASK: ii(2 * k.BITS), ZERO: { c0: k.ZERO, c1: k.ZERO }, ONE: { c0: k.ONE, c1: k.ZERO }, create: N => N, isValid: ({ c0: N, c1: F }) => k.isValid(N) && k.isValid(F), is0: ({ c0: N, c1: F }) => k.is0(N) && k.is0(F), isValidNot0: N => !ee.is0(N) && ee.isValid(N), neg: ({ c0: N, c1: F }) => ({ c0: k.neg(N), c1: k.neg(F) }), eql: ({ c0: N, c1: F }, { c0: G, c1: J }) => k.eql(N, G) && k.eql(F, J), sqrt: W0, inv: ({ c0: N, c1: F }) => { let G = k.inv(k.sub(k.sqr(N), k.mulByNonresidue(k.sqr(F)))); return { c0: k.mul(N, G), c1: k.neg(k.mul(F, G)) } }, div: (N, F) => ee.mul(N, typeof F == "bigint" ? n.inv(n.create(F)) : ee.inv(F)), pow: (N, F) => Na(ee, N, F), invertBatch: N => si(ee, N), add: V, sub: Y, mul: re, sqr: U, addN: V, subN: Y, mulN: re, sqrN: U, fromBytes: N => { if (N.length !== ee.BYTES) throw new Error("fromBytes invalid length=" + N.length); return { c0: k.fromBytes(N.subarray(0, k.BYTES)), c1: k.fromBytes(N.subarray(k.BYTES)) } }, toBytes: ({ c0: N, c1: F }) => Je(k.toBytes(N), k.toBytes(F)), cmov: ({ c0: N, c1: F }, { c0: G, c1: J }, ie) => ({ c0: k.cmov(N, G, ie), c1: k.cmov(F, J, ie) }), fromBigTwelve: N => ({ c0: k.fromBigSix(N.slice(0, 6)), c1: k.fromBigSix(N.slice(6, 12)) }), frobeniusMap(N, F) { const { c0: G, c1: J, c2: ie } = k.frobeniusMap(N.c1, F), z = C[F % 12]; return { c0: k.frobeniusMap(N.c0, F), c1: k.create({ c0: p.mul(G, z), c1: p.mul(J, z), c2: p.mul(ie, z) }) } }, mulByFp2: ({ c0: N, c1: F }, G) => ({ c0: k.mulByFp2(N, G), c1: k.mulByFp2(F, G) }), conjugate: ({ c0: N, c1: F }) => ({ c0: N, c1: k.neg(F) }), mul014: ({ c0: N, c1: F }, G, J, ie) => { let z = k.mul01(N, G, J), D = k.mul1(F, ie); return { c0: k.add(k.mulByNonresidue(D), z), c1: k.sub(k.sub(k.mul01(k.add(F, N), G, p.add(J, ie)), z), D) } }, mul034: ({ c0: N, c1: F }, G, J, ie) => { const z = k.create({ c0: p.mul(N.c0, G), c1: p.mul(N.c1, G), c2: p.mul(N.c2, G) }), D = k.mul01(F, J, ie), ae = k.mul01(k.add(N, F), p.add(G, J), ie); return { c0: k.add(k.mulByNonresidue(D), z), c1: k.sub(ae, k.add(z, D)) } }, _cyclotomicSquare: e.Fp12cyclotomicSquare, _cyclotomicExp: e.Fp12cyclotomicExp, finalExponentiate: e.Fp12finalExponentiate }; return { Fp: n, Fp2: p, Fp6: k, Fp12: ee, Fp4Square: K } }/*! noble-curves - MIT License (c) 2022 Paul Miller (paulmillr.com) */const kt = BigInt(0), vl = BigInt(1), pt = BigInt(2), Kl = BigInt(3), vo = BigInt(4), vr = BigInt("0xd201000000010000"), Dv = es(vr), yi = { p: BigInt("0x1a0111ea397fe69a4b1ba7b6434bacd764774b84f38512bf6730d2a0f6b0f6241eabfffeb153ffffb9feffffffffaaab"), n: BigInt("0x73eda753299d7d483339d80809a1d80553bda402fffe5bfeffffffff00000001"), h: BigInt("0x396c8c005555e1568c00aaab0000aaab"), a: kt, b: vo, Gx: BigInt("0x17f1d3a73197d7942695638c4fa9ac0fc3688c4f9774b905a14e3a3f171bac586c55e83ff97a1aeffb3af00adb22c6bb"), Gy: BigInt("0x08b3f481e3aaa0f1a09e30ed741d8ae4fcf5e095d5d00af600db18cb2c04b3edd03cc744a2888ae40caa232946c5e7e1") }, Jv = zr(yi.n, { modOnDecode: !0 }), { Fp: ge, Fp2: me, Fp6: of, Fp4Square: Yu, Fp12: Be } = Qv({ ORDER: yi.p, FP2_NONRESIDUE: [vl, vl], Fp2mulByB: ({ c0: e, c1: t }) => { const n = ge.mul(e, vo), r = ge.mul(t, vo); return { c0: ge.sub(n, r), c1: ge.add(n, r) } }, Fp12cyclotomicSquare: ({ c0: e, c1: t }) => { const { c0: n, c1: r, c2: i } = e, { c0: s, c1: o, c2: a } = t, { first: f, second: h } = Yu(n, o), { first: _, second: v } = Yu(s, i), { first: y, second: w } = Yu(r, a), p = me.mulByNonresidue(w); return { c0: of.create({ c0: me.add(me.mul(me.sub(f, n), pt), f), c1: me.add(me.mul(me.sub(_, r), pt), _), c2: me.add(me.mul(me.sub(y, i), pt), y) }), c1: of.create({ c0: me.add(me.mul(me.add(p, s), pt), p), c1: me.add(me.mul(me.add(h, o), pt), h), c2: me.add(me.mul(me.add(v, a), pt), v) }) } }, Fp12cyclotomicExp(e, t) { let n = Be.ONE; for (let r = Dv - 1; r >= 0; r--)n = Be._cyclotomicSquare(n), _v(t, r) && (n = Be.mul(n, e)); return n }, Fp12finalExponentiate: e => { const t = vr, n = Be.div(Be.frobeniusMap(e, 6), e), r = Be.mul(Be.frobeniusMap(n, 2), n), i = Be.conjugate(Be._cyclotomicExp(r, t)), s = Be.mul(Be.conjugate(Be._cyclotomicSquare(r)), i), o = Be.conjugate(Be._cyclotomicExp(s, t)), a = Be.conjugate(Be._cyclotomicExp(o, t)), f = Be.mul(Be.conjugate(Be._cyclotomicExp(a, t)), Be._cyclotomicSquare(i)), h = Be.conjugate(Be._cyclotomicExp(f, t)), _ = Be.frobeniusMap(Be.mul(i, a), 2), v = Be.frobeniusMap(Be.mul(o, r), 3), y = Be.frobeniusMap(Be.mul(f, Be.conjugate(r)), 1), w = Be.mul(Be.mul(h, Be.conjugate(s)), r); return Be.mul(Be.mul(Be.mul(_, v), y), w) } }), { G2psi: ih, G2psi2: e_ } = Xv(ge, me, me.div(me.ONE, me.NONRESIDUE)), Ku = Object.freeze({ DST: "BLS_SIG_BLS12381G2_XMD:SHA-256_SSWU_RO_NUL_", encodeDST: "BLS_SIG_BLS12381G2_XMD:SHA-256_SSWU_RO_NUL_", p: ge.ORDER, m: 2, k: 128, expand: "xmd", hash: H1 }), gd = { p: me.ORDER, n: yi.n, h: BigInt("0x5d543a95414e7f1091d50792876a202cd91de4547085abaa68a205b2e5a7ddfa628f1cb4d9e82ef21537e293a6691ae1616ec6e786f0c70cf1c38e31c7238e5"), a: me.ZERO, b: me.fromBigTuple([vo, vo]), Gx: me.fromBigTuple([BigInt("0x024aa2b2f08f0a91260805272dc51051c6e47ad4fa403b02b4510b647ae3d1770bac0326a805bbefd48056c8c121bdb8"), BigInt("0x13e02b6052719f607dacd3a088274f65596bd0d09920b61ab5da61bbdc7f5049334cf11213945d57e5ac7d055d042b7e")]), Gy: me.fromBigTuple([BigInt("0x0ce5d527727d6e118cc9cdc6da2e351aadfd9baa8cbdd3a76d429a695160d12c923ac9cc3baca289e193548608b82801"), BigInt("0x0606c4a02ea734cc32acd2b02bc28b99cb3e287e85a763af267492ab572e99ab3f370d275cec1da1aaa9075ff05f79be")]) }, Zl = Uo(ge.toBytes(kt), { infinity: !0, compressed: !0 }); function Xl(e) { e = e.slice(); const t = e[0] & 224, n = !!(t >> 7 & 1), r = !!(t >> 6 & 1), i = !!(t >> 5 & 1); return e[0] &= 31, { compressed: n, infinity: r, sort: i, value: e } } function Uo(e, t) { if (e[0] & 224) throw new Error("setMask: non-empty mask"); return t.compressed && (e[0] |= 128), t.infinity && (e[0] |= 64), t.sort && (e[0] |= 32), e } function t_(e, t, n) { const { BYTES: r, ORDER: i } = ge, s = t.is0(), { x: o, y: a } = t.toAffine(); if (n) { if (s) return Zl.slice(); const f = !!(a * pt / i); return Uo(wt(o, r), { compressed: !0, sort: f }) } else return s ? Je(Uint8Array.of(64), new Uint8Array(2 * r - 1)) : Je(wt(o, r), wt(a, r)) } function Zu(e) { e.assertValidity(); const { BYTES: t, ORDER: n } = ge, { x: r, y: i } = e.toAffine(); if (e.is0()) return Zl.slice(); const s = !!(i * pt / n); return Uo(wt(r, t), { compressed: !0, sort: s }) } function n_(e) { const { compressed: t, infinity: n, sort: r, value: i } = Xl(e), { BYTES: s, ORDER: o } = ge; if (i.length === 48 && t) { const a = zn(i), f = ge.create(a & ge.MASK); if (n) { if (f !== kt) throw new Error("invalid G1 point: non-empty, at infinity, with compression"); return { x: kt, y: kt } } const h = ge.add(ge.pow(f, Kl), ge.create(yi.b)); let _ = ge.sqrt(h); if (!_) throw new Error("invalid G1 point: compressed point"); return _ * pt / o !== BigInt(r) && (_ = ge.neg(_)), { x: ge.create(f), y: ge.create(_) } } else if (i.length === 96 && !t) { const a = zn(i.subarray(0, s)), f = zn(i.subarray(s)); if (n) { if (a !== kt || f !== kt) throw new Error("G1: non-empty point at infinity"); return Ql.G1.Point.ZERO.toAffine() } return { x: ge.create(a), y: ge.create(f) } } else throw new Error("invalid G1 point: expected 48/96 bytes") } function sh(e) { const { infinity: t, sort: n, value: r } = Xl(Mt("signatureHex", e, 48)), i = ge.ORDER, s = Ql.G1.Point, o = zn(r); if (t) return s.ZERO; const a = ge.create(o & ge.MASK), f = ge.add(ge.pow(a, Kl), ge.create(yi.b)); let h = ge.sqrt(f); if (!h) throw new Error("invalid G1 point: compressed"); const _ = BigInt(n); h * pt / i !== _ && (h = ge.neg(h)); const v = s.fromAffine({ x: a, y: h }); return v.assertValidity(), v } function r_(e, t, n) { const { BYTES: r, ORDER: i } = ge, s = t.is0(), { x: o, y: a } = t.toAffine(); if (n) { if (s) return Je(Zl, wt(kt, r)); const f = !!(a.c1 === kt ? a.c0 * pt / i : a.c1 * pt / i); return Je(Uo(wt(o.c1, r), { compressed: !0, sort: f }), wt(o.c0, r)) } else { if (s) return Je(Uint8Array.of(64), new Uint8Array(4 * r - 1)); const { re: f, im: h } = me.reim(o), { re: _, im: v } = me.reim(a); return Je(wt(h, r), wt(f, r), wt(v, r), wt(_, r)) } } function Xu(e) { e.assertValidity(); const { BYTES: t } = ge; if (e.is0()) return Je(Zl, wt(kt, t)); const { x: n, y: r } = e.toAffine(), { re: i, im: s } = me.reim(n), { re: o, im: a } = me.reim(r), h = !!((a > kt ? a * pt : o * pt) / ge.ORDER & vl), _ = i; return Je(Uo(wt(s, t), { sort: h, compressed: !0 }), wt(_, t)) } function i_(e) { const { BYTES: t, ORDER: n } = ge, { compressed: r, infinity: i, sort: s, value: o } = Xl(e); if (!r && !i && s || !r && i && s || s && i && r) throw new Error("invalid encoding flag: " + (e[0] & 224)); const a = (f, h, _) => zn(f.slice(h, _)); if (o.length === 96 && r) { if (i) { if (o.reduce((p, O) => p !== 0 ? O + 1 : O, 0) > 0) throw new Error("invalid G2 point: compressed"); return { x: me.ZERO, y: me.ZERO } } const f = a(o, 0, t), h = a(o, t, 2 * t), _ = me.create({ c0: ge.create(h), c1: ge.create(f) }), v = me.add(me.pow(_, Kl), gd.b); let y = me.sqrt(v); const w = y.c1 === kt ? y.c0 * pt / n : y.c1 * pt / n ? vl : kt; return y = s && w > 0 ? y : me.neg(y), { x: _, y } } else if (o.length === 192 && !r) { if (i) { if (o.reduce((y, w) => y !== 0 ? w + 1 : w, 0) > 0) throw new Error("invalid G2 point: uncompressed"); return { x: me.ZERO, y: me.ZERO } } const f = a(o, 0 * t, 1 * t), h = a(o, 1 * t, 2 * t), _ = a(o, 2 * t, 3 * t), v = a(o, 3 * t, 4 * t); return { x: me.fromBigTuple([h, f]), y: me.fromBigTuple([v, _]) } } else throw new Error("invalid G2 point: expected 96/192 bytes") } function oh(e) { const { ORDER: t } = ge, { infinity: n, sort: r, value: i } = Xl(Mt("signatureHex", e)), s = Ql.G2.Point, o = i.length / 2; if (o !== 48 && o !== 96) throw new Error("invalid compressed signature length, expected 96/192 bytes"); const a = zn(i.slice(0, o)), f = zn(i.slice(o)); if (n) return s.ZERO; const h = ge.create(a & ge.MASK), _ = ge.create(f), v = me.create({ c0: _, c1: h }), y = me.add(me.pow(v, Kl), gd.b); let w = me.sqrt(y); if (!w) throw new Error("Failed to find a square root"); const { re: p, im: O } = me.reim(w), $ = BigInt(r), b = O > kt && O * pt / t !== $, E = O === kt && p * pt / t !== $; (b || E) && (w = me.neg(w)); const S = s.fromAffine({ x: v, y: w }); return S.assertValidity(), S } const Ql = Zv({ fields: { Fp: ge, Fp2: me, Fp6: of, Fp12: Be, Fr: Jv }, G1: { ...yi, Fp: ge, htfDefaults: { ...Ku, m: 1, DST: "BLS_SIG_BLS12381G1_XMD:SHA-256_SSWU_RO_NUL_" }, wrapPrivateKey: !0, allowInfinityPoint: !0, isTorsionFree: (e, t) => { const n = BigInt("0x5f19672fdf76ce51ba69c6076a0f77eaddb3a93be6f89688de17d813620a00022e01fffffffefffe"), r = new e(ge.mul(t.X, n), t.Y, t.Z); return t.multiplyUnsafe(vr).negate().multiplyUnsafe(vr).equals(r) }, clearCofactor: (e, t) => t.multiplyUnsafe(vr).add(t), mapToCurve: u_, fromBytes: n_, toBytes: t_, ShortSignature: { fromBytes(e) { return It(e), sh(e) }, fromHex(e) { return sh(e) }, toBytes(e) { return Zu(e) }, toRawBytes(e) { return Zu(e) }, toHex(e) { return fs(Zu(e)) } } }, G2: { ...gd, Fp: me, hEff: BigInt("0xbc69f08f2ee75b3584c6a0ea91b352888e2a8e9145ad7689986ff031508ffe1329c2f178731db956d82bf015d1212b02ec0ec69d7477c1ae954cbc06689f6a359894c0adebbf6b4e8020005aaa95551"), htfDefaults: { ...Ku }, wrapPrivateKey: !0, allowInfinityPoint: !0, mapToCurve: c_, isTorsionFree: (e, t) => t.multiplyUnsafe(vr).negate().equals(ih(e, t)), clearCofactor: (e, t) => { const n = vr; let r = t.multiplyUnsafe(n).negate(), i = ih(e, t), s = t.double(); return s = e_(e, s), s = s.subtract(i), i = r.add(i), i = i.multiplyUnsafe(n).negate(), s = s.add(i), s = s.subtract(r), s.subtract(t) }, fromBytes: i_, toBytes: r_, Signature: { fromBytes(e) { return It(e), oh(e) }, fromHex(e) { return oh(e) }, toBytes(e) { return Xu(e) }, toRawBytes(e) { return Xu(e) }, toHex(e) { return fs(Xu(e)) } } }, params: { ateLoopSize: vr, r: yi.n, xNegative: !0, twistType: "multiplicative" }, htfDefaults: Ku }), s_ = gy(me, [[["0x5c759507e8e333ebb5b7a9a47d7ed8532c52d39fd3a042a88b58423c50ae15d5c2638e343d9c71c6238aaaaaaaa97d6", "0x5c759507e8e333ebb5b7a9a47d7ed8532c52d39fd3a042a88b58423c50ae15d5c2638e343d9c71c6238aaaaaaaa97d6"], ["0x0", "0x11560bf17baa99bc32126fced787c88f984f87adf7ae0c7f9a208c6b4f20a4181472aaa9cb8d555526a9ffffffffc71a"], ["0x11560bf17baa99bc32126fced787c88f984f87adf7ae0c7f9a208c6b4f20a4181472aaa9cb8d555526a9ffffffffc71e", "0x8ab05f8bdd54cde190937e76bc3e447cc27c3d6fbd7063fcd104635a790520c0a395554e5c6aaaa9354ffffffffe38d"], ["0x171d6541fa38ccfaed6dea691f5fb614cb14b4e7f4e810aa22d6108f142b85757098e38d0f671c7188e2aaaaaaaa5ed1", "0x0"]], [["0x0", "0x1a0111ea397fe69a4b1ba7b6434bacd764774b84f38512bf6730d2a0f6b0f6241eabfffeb153ffffb9feffffffffaa63"], ["0xc", "0x1a0111ea397fe69a4b1ba7b6434bacd764774b84f38512bf6730d2a0f6b0f6241eabfffeb153ffffb9feffffffffaa9f"], ["0x1", "0x0"]], [["0x1530477c7ab4113b59a4c18b076d11930f7da5d4a07f649bf54439d87d27e500fc8c25ebf8c92f6812cfc71c71c6d706", "0x1530477c7ab4113b59a4c18b076d11930f7da5d4a07f649bf54439d87d27e500fc8c25ebf8c92f6812cfc71c71c6d706"], ["0x0", "0x5c759507e8e333ebb5b7a9a47d7ed8532c52d39fd3a042a88b58423c50ae15d5c2638e343d9c71c6238aaaaaaaa97be"], ["0x11560bf17baa99bc32126fced787c88f984f87adf7ae0c7f9a208c6b4f20a4181472aaa9cb8d555526a9ffffffffc71c", "0x8ab05f8bdd54cde190937e76bc3e447cc27c3d6fbd7063fcd104635a790520c0a395554e5c6aaaa9354ffffffffe38f"], ["0x124c9ad43b6cf79bfbf7043de3811ad0761b0f37a1e26286b0e977c69aa274524e79097a56dc4bd9e1b371c71c718b10", "0x0"]], [["0x1a0111ea397fe69a4b1ba7b6434bacd764774b84f38512bf6730d2a0f6b0f6241eabfffeb153ffffb9feffffffffa8fb", "0x1a0111ea397fe69a4b1ba7b6434bacd764774b84f38512bf6730d2a0f6b0f6241eabfffeb153ffffb9feffffffffa8fb"], ["0x0", "0x1a0111ea397fe69a4b1ba7b6434bacd764774b84f38512bf6730d2a0f6b0f6241eabfffeb153ffffb9feffffffffa9d3"], ["0x12", "0x1a0111ea397fe69a4b1ba7b6434bacd764774b84f38512bf6730d2a0f6b0f6241eabfffeb153ffffb9feffffffffaa99"], ["0x1", "0x0"]]].map(e => e.map(t => me.fromBigTuple(t.map(BigInt))))), o_ = gy(ge, [["0x11a05f2b1e833340b809101dd99815856b303e88a2d7005ff2627b56cdb4e2c85610c2d5f2e62d6eaeac1662734649b7", "0x17294ed3e943ab2f0588bab22147a81c7c17e75b2f6a8417f565e33c70d1e86b4838f2a6f318c356e834eef1b3cb83bb", "0xd54005db97678ec1d1048c5d10a9a1bce032473295983e56878e501ec68e25c958c3e3d2a09729fe0179f9dac9edcb0", "0x1778e7166fcc6db74e0609d307e55412d7f5e4656a8dbf25f1b33289f1b330835336e25ce3107193c5b388641d9b6861", "0xe99726a3199f4436642b4b3e4118e5499db995a1257fb3f086eeb65982fac18985a286f301e77c451154ce9ac8895d9", "0x1630c3250d7313ff01d1201bf7a74ab5db3cb17dd952799b9ed3ab9097e68f90a0870d2dcae73d19cd13c1c66f652983", "0xd6ed6553fe44d296a3726c38ae652bfb11586264f0f8ce19008e218f9c86b2a8da25128c1052ecaddd7f225a139ed84", "0x17b81e7701abdbe2e8743884d1117e53356de5ab275b4db1a682c62ef0f2753339b7c8f8c8f475af9ccb5618e3f0c88e", "0x80d3cf1f9a78fc47b90b33563be990dc43b756ce79f5574a2c596c928c5d1de4fa295f296b74e956d71986a8497e317", "0x169b1f8e1bcfa7c42e0c37515d138f22dd2ecb803a0c5c99676314baf4bb1b7fa3190b2edc0327797f241067be390c9e", "0x10321da079ce07e272d8ec09d2565b0dfa7dccdde6787f96d50af36003b14866f69b771f8c285decca67df3f1605fb7b", "0x6e08c248e260e70bd1e962381edee3d31d79d7e22c837bc23c0bf1bc24c6b68c24b1b80b64d391fa9c8ba2e8ba2d229"], ["0x8ca8d548cff19ae18b2e62f4bd3fa6f01d5ef4ba35b48ba9c9588617fc8ac62b558d681be343df8993cf9fa40d21b1c", "0x12561a5deb559c4348b4711298e536367041e8ca0cf0800c0126c2588c48bf5713daa8846cb026e9e5c8276ec82b3bff", "0xb2962fe57a3225e8137e629bff2991f6f89416f5a718cd1fca64e00b11aceacd6a3d0967c94fedcfcc239ba5cb83e19", "0x3425581a58ae2fec83aafef7c40eb545b08243f16b1655154cca8abc28d6fd04976d5243eecf5c4130de8938dc62cd8", "0x13a8e162022914a80a6f1d5f43e7a07dffdfc759a12062bb8d6b44e833b306da9bd29ba81f35781d539d395b3532a21e", "0xe7355f8e4e667b955390f7f0506c6e9395735e9ce9cad4d0a43bcef24b8982f7400d24bc4228f11c02df9a29f6304a5", "0x772caacf16936190f3e0c63e0596721570f5799af53a1894e2e073062aede9cea73b3538f0de06cec2574496ee84a3a", "0x14a7ac2a9d64a8b230b3f5b074cf01996e7f63c21bca68a81996e1cdf9822c580fa5b9489d11e2d311f7d99bbdcc5a5e", "0xa10ecf6ada54f825e920b3dafc7a3cce07f8d1d7161366b74100da67f39883503826692abba43704776ec3a79a1d641", "0x95fc13ab9e92ad4476d6e3eb3a56680f682b4ee96f7d03776df533978f31c1593174e4b4b7865002d6384d168ecdd0a", "0x000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000001"], ["0x90d97c81ba24ee0259d1f094980dcfa11ad138e48a869522b52af6c956543d3cd0c7aee9b3ba3c2be9845719707bb33", "0x134996a104ee5811d51036d776fb46831223e96c254f383d0f906343eb67ad34d6c56711962fa8bfe097e75a2e41c696", "0xcc786baa966e66f4a384c86a3b49942552e2d658a31ce2c344be4b91400da7d26d521628b00523b8dfe240c72de1f6", "0x1f86376e8981c217898751ad8746757d42aa7b90eeb791c09e4a3ec03251cf9de405aba9ec61deca6355c77b0e5f4cb", "0x8cc03fdefe0ff135caf4fe2a21529c4195536fbe3ce50b879833fd221351adc2ee7f8dc099040a841b6daecf2e8fedb", "0x16603fca40634b6a2211e11db8f0a6a074a7d0d4afadb7bd76505c3d3ad5544e203f6326c95a807299b23ab13633a5f0", "0x4ab0b9bcfac1bbcb2c977d027796b3ce75bb8ca2be184cb5231413c4d634f3747a87ac2460f415ec961f8855fe9d6f2", "0x987c8d5333ab86fde9926bd2ca6c674170a05bfe3bdd81ffd038da6c26c842642f64550fedfe935a15e4ca31870fb29", "0x9fc4018bd96684be88c9e221e4da1bb8f3abd16679dc26c1e8b6e6a1f20cabe69d65201c78607a360370e577bdba587", "0xe1bba7a1186bdb5223abde7ada14a23c42a0ca7915af6fe06985e7ed1e4d43b9b3f7055dd4eba6f2bafaaebca731c30", "0x19713e47937cd1be0dfd0b8f1d43fb93cd2fcbcb6caf493fd1183e416389e61031bf3a5cce3fbafce813711ad011c132", "0x18b46a908f36f6deb918c143fed2edcc523559b8aaf0c2462e6bfe7f911f643249d9cdf41b44d606ce07c8a4d0074d8e", "0xb182cac101b9399d155096004f53f447aa7b12a3426b08ec02710e807b4633f06c851c1919211f20d4c04f00b971ef8", "0x245a394ad1eca9b72fc00ae7be315dc757b3b080d4c158013e6632d3c40659cc6cf90ad1c232a6442d9d3f5db980133", "0x5c129645e44cf1102a159f748c4a3fc5e673d81d7e86568d9ab0f5d396a7ce46ba1049b6579afb7866b1e715475224b", "0x15e6be4e990f03ce4ea50b3b42df2eb5cb181d8f84965a3957add4fa95af01b2b665027efec01c7704b456be69c8b604"], ["0x16112c4c3a9c98b252181140fad0eae9601a6de578980be6eec3232b5be72e7a07f3688ef60c206d01479253b03663c1", "0x1962d75c2381201e1a0cbd6c43c348b885c84ff731c4d59ca4a10356f453e01f78a4260763529e3532f6102c2e49a03d", "0x58df3306640da276faaae7d6e8eb15778c4855551ae7f310c35a5dd279cd2eca6757cd636f96f891e2538b53dbf67f2", "0x16b7d288798e5395f20d23bf89edb4d1d115c5dbddbcd30e123da489e726af41727364f2c28297ada8d26d98445f5416", "0xbe0e079545f43e4b00cc912f8228ddcc6d19c9f0f69bbb0542eda0fc9dec916a20b15dc0fd2ededda39142311a5001d", "0x8d9e5297186db2d9fb266eaac783182b70152c65550d881c5ecd87b6f0f5a6449f38db9dfa9cce202c6477faaf9b7ac", "0x166007c08a99db2fc3ba8734ace9824b5eecfdfa8d0cf8ef5dd365bc400a0051d5fa9c01a58b1fb93d1a1399126a775c", "0x16a3ef08be3ea7ea03bcddfabba6ff6ee5a4375efa1f4fd7feb34fd206357132b920f5b00801dee460ee415a15812ed9", "0x1866c8ed336c61231a1be54fd1d74cc4f9fb0ce4c6af5920abc5750c4bf39b4852cfe2f7bb9248836b233d9d55535d4a", "0x167a55cda70a6e1cea820597d94a84903216f763e13d87bb5308592e7ea7d4fbc7385ea3d529b35e346ef48bb8913f55", "0x4d2f259eea405bd48f010a01ad2911d9c6dd039bb61a6290e591b36e636a5c871a5c29f4f83060400f8b49cba8f6aa8", "0xaccbb67481d033ff5852c1e48c50c477f94ff8aefce42d28c0f9a88cea7913516f968986f7ebbea9684b529e2561092", "0xad6b9514c767fe3c3613144b45f1496543346d98adf02267d5ceef9a00d9b8693000763e3b90ac11e99b138573345cc", "0x2660400eb2e4f3b628bdd0d53cd76f2bf565b94e72927c1cb748df27942480e420517bd8714cc80d1fadc1326ed06f7", "0xe0fa1d816ddc03e6b24255e0d7819c171c40f65e273b853324efcd6356caa205ca2f570f13497804415473a1d634b8f", "0x000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000001"]].map(e => e.map(t => BigInt(t)))), a_ = xy(ge, { A: ge.create(BigInt("0x144698a3b8e9433d693a02c96d4982b0ea985383ee66a8d8e8981aefd881ac98936f8da0e0f97f5cf428082d584c1d")), B: ge.create(BigInt("0x12e2908d11688030018b12e8753eee3b2016c1f0f24f4070a0b9c14fcef35ef55a23215a316ceaa5d1cc48e98e172be0")), Z: ge.create(BigInt(11)) }), l_ = xy(me, { A: me.create({ c0: ge.create(kt), c1: ge.create(BigInt(240)) }), B: me.create({ c0: ge.create(BigInt(1012)), c1: ge.create(BigInt(1012)) }), Z: me.create({ c0: ge.create(BigInt(-2)), c1: ge.create(BigInt(-1)) }) }); function u_(e) { const { x: t, y: n } = a_(ge.create(e[0])); return o_(t, n) } function c_(e) { const { x: t, y: n } = l_(me.fromBigTuple(e)); return s_(t, n) } function f_(e, t, n) { const r = typeof e == "string" ? e : ht(e), i = typeof t == "string" ? t : ht(t), s = typeof n == "string" ? n : ht(n); return Ql.verifyShortSignature(i, s, r) } const vy = e => ft(new ws(e)), wd = e => { const t = vy(e); return new Date(Number(t) / 1e6) }; var d_ = function (e, t, n, r, i) { if (r === "m") throw new TypeError("Private method is not writable"); if (r === "a" && !i) throw new TypeError("Private accessor was defined without a setter"); if (typeof t == "function" ? e !== t || !i : !t.has(e)) throw new TypeError("Cannot write private member to an object whose class did not declare it"); return r === "a" ? i.call(e, n) : i ? i.value = n : t.set(e, n), n }, h_ = function (e, t, n, r) { if (n === "a" && !r) throw new TypeError("Private accessor was defined without a getter"); if (typeof t == "function" ? e !== t || !r : !t.has(e)) throw new TypeError("Cannot read private member from an object whose class did not declare it"); return n === "m" ? r : n === "a" ? r.call(e) : r ? r.value : t.get(e) }, Ta; class Un extends Ze { constructor(t) { super(`Invalid certificate: ${t}`) } } var Kt; (function (e) { e[e.Empty = 0] = "Empty", e[e.Fork = 1] = "Fork", e[e.Labeled = 2] = "Labeled", e[e.Leaf = 3] = "Leaf", e[e.Pruned = 4] = "Pruned" })(Kt || (Kt = {})); function p_(e, t) { const n = new Uint8Array(e), r = new Uint8Array(t); for (let i = 0; i < n.length; i++)if (n[i] > r[i]) return !0; return !1 } class oi { constructor(t, n, r, i, s = 5, o = !1) { this._rootKey = n, this._canisterId = r, this._blsVerify = i, this._maxAgeInMinutes = s, Ta.set(this, !1), d_(this, Ta, o, "f"), this.cert = Jn(new Uint8Array(t)) } static async create(t) { const n = oi.createUnverified(t); return await n.verify(), n } static createUnverified(t) { let n = t.blsVerify; return n || (n = f_), new oi(t.certificate, t.rootKey, t.canisterId, n, t.maxAgeInMinutes, t.disableTimeVerification) } lookup(t) { return ps(t, this.cert.tree) } lookup_label(t) { return this.lookup([t]) } async verify() { const t = await Ba(this.cert.tree), n = await this._checkDelegationAndGetKey(this.cert.delegation), r = this.cert.signature, i = y_(n), s = $n(Ms("ic-state-root"), t); let o = !1; const a = sn(this.lookup(["time"])); if (!a) throw new Un("Certificate does not contain a time"); if (!h_(this, Ta, "f")) { const h = this._maxAgeInMinutes * 60 * 1e3, _ = Date.now(), v = _ - h, y = _ + 3e5, w = wd(a); if (w.getTime() < v) throw new Un(`Certificate is signed more than ${this._maxAgeInMinutes} minutes in the past. Certificate time: ` + w.toISOString() + " Current time: " + new Date(_).toISOString()); if (w.getTime() > y) throw new Un("Certificate is signed more than 5 minutes in the future. Certificate time: " + w.toISOString() + " Current time: " + new Date(_).toISOString()) } try { o = await this._blsVerify(new Uint8Array(i), new Uint8Array(r), new Uint8Array(s)) } catch { o = !1 } if (!o) throw new Un("Signature verification failed") } async _checkDelegationAndGetKey(t) { if (!t) return this._rootKey; const n = await oi.createUnverified({ certificate: t.certificate, rootKey: this._rootKey, canisterId: this._canisterId, blsVerify: this._blsVerify, maxAgeInMinutes: 1 / 0 }); if (n.cert.delegation) throw new Un("Delegation certificates cannot be nested"); if (await n.verify(), this._canisterId.toString() !== G_ && !_y({ canisterId: this._canisterId, subnetId: Se.fromUint8Array(new Uint8Array(t.subnet_id)), tree: n.cert.tree })) throw new Un(`Canister ${this._canisterId} not in range of delegations for subnet 0x${ht(t.subnet_id)}`); const r = sn(n.lookup(["subnet", t.subnet_id, "public_key"])); if (!r) throw new Error(`Could not find subnet key for subnet 0x${ht(t.subnet_id)}`); return r } } Ta = new WeakMap; const ks = fl("308182301d060d2b0601040182dc7c0503010201060c2b0601040182dc7c05030201036100"), m_ = 96; function y_(e) { const t = ks.byteLength + m_; if (e.byteLength !== t) throw new TypeError(`BLS DER-encoded public key must be ${t} bytes long`); const n = e.slice(0, ks.byteLength); if (!jl(n, ks)) throw new TypeError(`BLS DER-encoded public key is invalid. Expect the following prefix: ${ks}, but get ${n}`); return e.slice(ks.byteLength) } function sn(e) { if (e.status === st.Found) { if (e.value instanceof ArrayBuffer) return e.value; if (e.value instanceof Uint8Array) return e.value.buffer } } async function Ba(e) { switch (e[0]) { case Kt.Empty: return xn(Ms("ic-hashtree-empty")); case Kt.Pruned: return e[1]; case Kt.Leaf: return xn($n(Ms("ic-hashtree-leaf"), e[1])); case Kt.Labeled: return xn($n(Ms("ic-hashtree-labeled"), e[1], await Ba(e[2]))); case Kt.Fork: return xn($n(Ms("ic-hashtree-fork"), await Ba(e[1]), await Ba(e[2]))); default: throw new Error("unreachable") } } function Ms(e) { const t = new Uint8Array([e.length]), n = new TextEncoder().encode(e); return $n(t, n) } var st; (function (e) { e.Unknown = "unknown", e.Absent = "absent", e.Found = "found" })(st || (st = {})); var Zn; (function (e) { e.Less = "less", e.Greater = "greater" })(Zn || (Zn = {})); function ps(e, t) { if (e.length === 0) switch (t[0]) { case Kt.Leaf: { if (!t[1]) throw new Error("Invalid tree structure for leaf"); return t[1] instanceof ArrayBuffer ? { status: st.Found, value: t[1] } : t[1] instanceof Uint8Array ? { status: st.Found, value: t[1].buffer } : { status: st.Found, value: t[1] } } default: return { status: st.Found, value: t } }const n = typeof e[0] == "string" ? new TextEncoder().encode(e[0]) : e[0], r = Aa(n, t); switch (r.status) { case st.Found: return ps(e.slice(1), r.value); case Zn.Greater: case Zn.Less: return { status: st.Absent }; default: return r } } function af(e) { switch (e[0]) { case Kt.Empty: return []; case Kt.Fork: return af(e[1]).concat(af(e[2])); default: return [e] } } function Aa(e, t) { switch (t[0]) { case Kt.Labeled: return p_(e, t[1]) ? { status: Zn.Greater } : jl(e, t[1]) ? { status: st.Found, value: t[2] } : { status: Zn.Less }; case Kt.Fork: const n = Aa(e, t[1]); switch (n.status) { case Zn.Greater: { const r = Aa(e, t[2]); return r.status === Zn.Less ? { status: st.Absent } : r } case st.Unknown: { let r = Aa(e, t[2]); return r.status === Zn.Less ? { status: st.Unknown } : r } default: return n }case Kt.Pruned: return { status: st.Unknown }; default: return { status: st.Absent } } } function _y(e) { const { canisterId: t, subnetId: n, tree: r } = e, i = ps(["subnet", n.toUint8Array(), "canister_ranges"], r); if (i.status !== st.Found || !(i.value instanceof ArrayBuffer)) throw new Error(`Could not find canister ranges for subnet ${n}`); return Jn(i.value).map(f => [Se.fromUint8Array(f[0]), Se.fromUint8Array(f[1])]).some(f => f[0].ltEq(t) && f[1].gtEq(t)) } class g_ { constructor(t, n, r) { this.key = t, this.path = n, this.decodeStrategy = r } } const Ey = async e => { const { agent: t, paths: n } = e, r = Se.from(e.canisterId), i = [...new Set(n)], s = i.map(f => lf(f, r)), o = new Map, a = i.map((f, h) => (async () => { var _; try { const v = await t.readState(r, { paths: [s[h]] }); if (t.rootKey == null) throw new Error("Agent is missing root key"); const y = await oi.create({ certificate: v.certificate, rootKey: t.rootKey, canisterId: r, disableTimeVerification: !0 }), w = ($, b) => { if (b === "subnet") { if (t.rootKey == null) throw new Error("Agent is missing root key"); const E = by(v.certificate, r, t.rootKey); return { path: b, data: E } } else return { path: b, data: sn($.lookup(lf(b, r))) } }, { path: p, data: O } = w(y, i[h]); if (!O) console.warn(`Expected to find result for path ${p}, but instead found nothing.`), typeof p == "string" ? o.set(p, null) : o.set(p.key, null); else switch (p) { case "time": { o.set(p, wd(O)); break } case "controllers": { o.set(p, x_(O)); break } case "module_hash": { o.set(p, ah(O)); break } case "subnet": { o.set(p, O); break } case "candid": { o.set(p, new TextDecoder().decode(O)); break } default: if (typeof p != "string" && "key" in p && "path" in p) switch (p.decodeStrategy) { case "raw": o.set(p.key, O); break; case "leb128": { o.set(p.key, vy(O)); break } case "cbor": { o.set(p.key, Sy(O)); break } case "hex": { o.set(p.key, ah(O)); break } case "utf-8": o.set(p.key, w_(O)) } } } catch (v) { if (!((_ = v == null ? void 0 : v.message) === null || _ === void 0) && _.includes("Invalid certificate")) throw new Ze(v.message); typeof f != "string" && "key" in f && "path" in f ? o.set(f.key, null) : o.set(f, null), console.group(), console.warn(`Expected to find result for path ${f}, but instead found nothing.`), console.warn(v), console.groupEnd() } })()); return await Promise.all(a), o }, by = (e, t, n) => { if (!t._isPrincipal) throw new Error("Invalid canisterId"); const r = Jn(new Uint8Array(e)), i = r.tree; let s = r.delegation, o; if (s && s.subnet_id ? o = Se.fromUint8Array(new Uint8Array(s.subnet_id)) : !s && typeof n < "u" ? (o = Se.selfAuthenticating(new Uint8Array(n)), s = { subnet_id: o.toUint8Array(), certificate: new ArrayBuffer(0) }) : (o = Se.selfAuthenticating(Se.fromText("tdb26-jop6k-aogll-7ltgs-eruif-6kk7m-qpktf-gdiqx-mxtrf-vb5e6-eqe").toUint8Array()), s = { subnet_id: o.toUint8Array(), certificate: new ArrayBuffer(0) }), !_y({ canisterId: t, subnetId: o, tree: i })) throw new Error("Canister not in range"); const f = ps(["subnet", s.subnet_id, "node"], i); if (f.status !== st.Found) throw new Error("Node not found"); if (f.value instanceof ArrayBuffer) throw new Error("Invalid node tree"); const h = af(f.value), _ = new Map; return h.forEach(v => { const y = Se.from(new Uint8Array(v[1])).toText(), w = ps(["public_key"], v[2]); if (w.status !== st.Found) throw new Error("Public key not found"); const p = w.value; if (p.byteLength !== 44) throw new Error("Invalid public key length"); _.set(y, p) }), { subnetId: Se.fromUint8Array(new Uint8Array(s.subnet_id)).toText(), nodeKeys: _ } }, lf = (e, t) => { const n = new TextEncoder, r = s => new DataView(n.encode(s).buffer).buffer, i = new DataView(t.toUint8Array().buffer).buffer; switch (e) { case "time": return [r("time")]; case "controllers": return [r("canister"), i, r("controllers")]; case "module_hash": return [r("canister"), i, r("module_hash")]; case "subnet": return [r("subnet")]; case "candid": return [r("canister"), i, r("metadata"), r("candid:service")]; default: if ("key" in e && "path" in e) if (typeof e.path == "string" || e.path instanceof ArrayBuffer) { const s = e.path, o = typeof s == "string" ? r(s) : s; return [r("canister"), i, r("metadata"), o] } else return e.path }throw new Error(`An unexpeected error was encountered while encoding your path for canister status. Please ensure that your path, ${e} was formatted correctly.`) }, ah = e => ht(e), Sy = e => Jn(e), w_ = e => new TextDecoder().decode(e), x_ = e => Sy(e).map(n => Se.fromUint8Array(new Uint8Array(n))), v_ = Object.freeze(Object.defineProperty({ __proto__: null, CustomPath: g_, encodePath: lf, fetchNodeKeys: by, request: Ey }, Symbol.toStringTag, { value: "Module" }));/*! noble-curves - MIT License (c) 2022 Paul Miller (paulmillr.com) */const An = BigInt(0), rt = BigInt(1), Qu = BigInt(2), __ = BigInt(8); function E_(e, t, n, r) { const i = e.sqr(n), s = e.sqr(r), o = e.add(e.mul(t.a, i), s), a = e.add(e.ONE, e.mul(t.d, e.mul(i, s))); return e.eql(o, a) } function b_(e, t = {}) { const { Fp: n, Fn: r } = my("edwards", e, t), { h: i, n: s } = e; Oo(t, {}, { uvRatio: "function" }); const o = Qu << BigInt(r.BYTES * 8) - rt, a = O => n.create(O), f = t.uvRatio || ((O, $) => { try { return { isValid: !0, value: n.sqrt(n.div(O, $)) } } catch { return { isValid: !1, value: An } } }); if (!E_(n, e, e.Gx, e.Gy)) throw new Error("bad curve params: generator point"); function h(O, $, b = !1) { const E = b ? rt : An; return Ps("coordinate " + O, $, E, o), $ } function _(O) { if (!(O instanceof w)) throw new Error("ExtendedPoint expected") } const v = wo((O, $) => { const { X: b, Y: E, Z: S } = O, M = O.is0(); $ == null && ($ = M ? __ : n.inv(S)); const k = a(b * $), C = a(E * $), V = n.mul(S, $); if (M) return { x: An, y: rt }; if (V !== rt) throw new Error("invZ was invalid"); return { x: k, y: C } }), y = wo(O => { const { a: $, d: b } = e; if (O.is0()) throw new Error("bad point: ZERO"); const { X: E, Y: S, Z: M, T: k } = O, C = a(E * E), V = a(S * S), Y = a(M * M), re = a(Y * Y), U = a(C * $), K = a(Y * a(U + V)), ee = a(re + a(b * a(C * V))); if (K !== ee) throw new Error("bad point: equation left != right (1)"); const N = a(E * S), F = a(M * k); if (N !== F) throw new Error("bad point: equation left != right (2)"); return !0 }); class w { constructor($, b, E, S) { this.X = h("x", $), this.Y = h("y", b), this.Z = h("z", E, !0), this.T = h("t", S), Object.freeze(this) } get x() { return this.toAffine().x } get y() { return this.toAffine().y } get ex() { return this.X } get ey() { return this.Y } get ez() { return this.Z } get et() { return this.T } static normalizeZ($) { return er(w, $) } static msm($, b) { return py(w, r, $, b) } _setWindowSize($) { this.precompute($) } static fromAffine($) { if ($ instanceof w) throw new Error("extended point not allowed"); const { x: b, y: E } = $ || {}; return h("x", b), h("y", E), new w(b, E, rt, a(b * E)) } precompute($ = 8, b = !0) { return p.createCache(this, $), b || this.multiply(Qu), this } assertValidity() { y(this) } equals($) { _($); const { X: b, Y: E, Z: S } = this, { X: M, Y: k, Z: C } = $, V = a(b * C), Y = a(M * S), re = a(E * C), U = a(k * S); return V === Y && re === U } is0() { return this.equals(w.ZERO) } negate() { return new w(a(-this.X), this.Y, this.Z, a(-this.T)) } double() { const { a: $ } = e, { X: b, Y: E, Z: S } = this, M = a(b * b), k = a(E * E), C = a(Qu * a(S * S)), V = a($ * M), Y = b + E, re = a(a(Y * Y) - M - k), U = V + k, K = U - C, ee = V - k, N = a(re * K), F = a(U * ee), G = a(re * ee), J = a(K * U); return new w(N, F, J, G) } add($) { _($); const { a: b, d: E } = e, { X: S, Y: M, Z: k, T: C } = this, { X: V, Y, Z: re, T: U } = $, K = a(S * V), ee = a(M * Y), N = a(C * E * U), F = a(k * re), G = a((S + M) * (V + Y) - K - ee), J = F - N, ie = F + N, z = a(ee - b * K), D = a(G * J), ae = a(ie * z), se = a(G * z), oe = a(J * ie); return new w(D, ae, oe, se) } subtract($) { return this.add($.negate()) } multiply($) { const b = $; Ps("scalar", b, rt, s); const { p: E, f: S } = p.cached(this, b, M => er(w, M)); return er(w, [E, S])[0] } multiplyUnsafe($, b = w.ZERO) { const E = $; return Ps("scalar", E, An, s), E === An ? w.ZERO : this.is0() || E === rt ? this : p.unsafe(this, E, S => er(w, S), b) } isSmallOrder() { return this.multiplyUnsafe(i).is0() } isTorsionFree() { return p.unsafe(this, s).is0() } toAffine($) { return v(this, $) } clearCofactor() { return i === rt ? this : this.multiplyUnsafe(i) } static fromBytes($, b = !1) { return It($), w.fromHex($, b) } static fromHex($, b = !1) { const { d: E, a: S } = e, M = n.BYTES; $ = Mt("pointHex", $, M), yo("zip215", b); const k = $.slice(), C = $[M - 1]; k[M - 1] = C & -129; const V = go(k), Y = b ? o : n.ORDER; Ps("pointHex.y", V, An, Y); const re = a(V * V), U = a(re - rt), K = a(E * re - S); let { isValid: ee, value: N } = f(U, K); if (!ee) throw new Error("Point.fromHex: invalid y coordinate"); const F = (N & rt) === rt, G = (C & 128) !== 0; if (!b && N === An && G) throw new Error("Point.fromHex: x=0 and x_0=1"); return G !== F && (N = a(-N)), w.fromAffine({ x: N, y: V }) } toBytes() { const { x: $, y: b } = this.toAffine(), E = Yl(b, n.BYTES); return E[E.length - 1] |= $ & rt ? 128 : 0, E } toRawBytes() { return this.toBytes() } toHex() { return fs(this.toBytes()) } toString() { return `<Point ${this.is0() ? "ZERO" : this.toHex()}>` } } w.BASE = new w(e.Gx, e.Gy, rt, a(e.Gx * e.Gy)), w.ZERO = new w(An, rt, rt, An), w.Fp = n, w.Fn = r; const p = new hy(w, r.BYTES * 8); return w } function S_(e, t, n) { if (typeof t != "function") throw new Error('"hash" function param is required'); Oo(n, {}, { adjustScalarBytes: "function", randomBytes: "function", domain: "function", prehash: "function", mapToCurve: "function" }); const { prehash: r } = n, { BASE: i, Fp: s, Fn: o } = e, a = o.ORDER, f = n.randomBytes || $1, h = n.adjustScalarBytes || (K => K), _ = n.domain || ((K, ee, N) => { if (yo("phflag", N), ee.length || N) throw new Error("Contexts/pre-hash are not supported"); return K }); function v(K) { return o.create(K) } function y(K) { return v(go(K)) } function w(K) { const ee = s.BYTES; K = Mt("private key", K, ee); const N = Mt("hashed private key", t(K), 2 * ee), F = h(N.slice(0, ee)), G = N.slice(ee, 2 * ee), J = y(F); return { head: F, prefix: G, scalar: J } } function p(K) { const { head: ee, prefix: N, scalar: F } = w(K), G = i.multiply(F), J = G.toBytes(); return { head: ee, prefix: N, scalar: F, point: G, pointBytes: J } } function O(K) { return p(K).pointBytes } function $(K = Uint8Array.of(), ...ee) { const N = Je(...ee); return y(t(_(N, Mt("context", K), !!r))) } function b(K, ee, N = {}) { K = Mt("message", K), r && (K = r(K)); const { prefix: F, scalar: G, pointBytes: J } = p(ee), ie = $(N.context, F, K), z = i.multiply(ie).toBytes(), D = $(N.context, z, J, K), ae = v(ie + D * G); Ps("signature.s", ae, An, a); const se = s.BYTES, oe = Je(z, Yl(ae, se)); return Mt("result", oe, se * 2) } const E = { zip215: !0 }; function S(K, ee, N, F = E) { const { context: G, zip215: J } = F, ie = s.BYTES; K = Mt("signature", K, 2 * ie), ee = Mt("message", ee), N = Mt("publicKey", N, ie), J !== void 0 && yo("zip215", J), r && (ee = r(ee)); const z = go(K.slice(ie, 2 * ie)); let D, ae, se; try { D = e.fromHex(N, J), ae = e.fromHex(K.slice(0, ie), J), se = i.multiplyUnsafe(z) } catch { return !1 } if (!J && D.isSmallOrder()) return !1; const oe = $(G, ae.toBytes(), D.toBytes(), ee); return ae.add(D.multiplyUnsafe(oe)).subtract(se).clearCofactor().is0() } i.precompute(8); const M = s.BYTES, k = { secret: M, public: M, signature: 2 * M, seed: M }; function C(K = f(k.seed)) { return K } const V = { getExtendedPublicKey: p, randomSecretKey: C, isValidSecretKey: re, isValidPublicKey: U, randomPrivateKey: C, toMontgomery(K) { const { y: ee } = e.fromBytes(K), N = M === 32; if (!N && M !== 57) throw new Error("only defined for 25519 and 448"); const F = N ? s.div(rt + ee, rt - ee) : s.div(ee - rt, ee + rt); return s.toBytes(F) }, toMontgomeryPriv(K) { It(K, M); const ee = t(K.subarray(0, M)); return h(ee).subarray(0, M) }, precompute(K = 8, ee = e.BASE) { return ee.precompute(K, !1) } }; function Y(K) { const ee = V.randomSecretKey(K); return { secretKey: ee, publicKey: O(ee) } } function re(K) { try { return !!o.fromBytes(K, !1) } catch { return !1 } } function U(K, ee) { try { return !!e.fromBytes(K, ee) } catch { return !1 } } return Object.freeze({ keygen: Y, getPublicKey: O, sign: b, verify: S, utils: V, Point: e, info: { type: "edwards", lengths: k } }) } function N_(e) { const t = { a: e.a, d: e.d, p: e.Fp.ORDER, n: e.n, h: e.h, Gx: e.Gx, Gy: e.Gy }, n = e.Fp, r = zr(t.n, e.nBitLength, !0), i = { Fp: n, Fn: r, uvRatio: e.uvRatio }, s = { randomBytes: e.randomBytes, adjustScalarBytes: e.adjustScalarBytes, domain: e.domain, prehash: e.prehash, mapToCurve: e.mapToCurve }; return { CURVE: t, curveOpts: i, hash: e.hash, eddsaOpts: s } } function T_(e, t) { return Object.assign({}, t, { ExtendedPoint: t.Point, CURVE: e }) } function B_(e) { const { CURVE: t, curveOpts: n, hash: r, eddsaOpts: i } = N_(e), s = b_(t, n), o = S_(s, r, i); return T_(e, o) }/*! noble-curves - MIT License (c) 2022 Paul Miller (paulmillr.com) */BigInt(0); const A_ = BigInt(1), lh = BigInt(2); BigInt(3); const k_ = BigInt(5), R_ = BigInt(8), Dl = { p: BigInt("0x7fffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffed"), n: BigInt("0x1000000000000000000000000000000014def9dea2f79cd65812631a5cf5d3ed"), h: R_, a: BigInt("0x7fffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffec"), d: BigInt("0x52036cee2b6ffe738cc740797779e89800700a4d4141d8ab75eb4dca135978a3"), Gx: BigInt("0x216936d3cd6e53fec0a4e231fdd6dc5c692cc7609525a7b2c9562d608f25d51a"), Gy: BigInt("0x6666666666666666666666666666666666666666666666666666666666666658") }; function I_(e) { const t = BigInt(10), n = BigInt(20), r = BigInt(40), i = BigInt(80), s = Dl.p, a = e * e % s * e % s, f = Tn(a, lh, s) * a % s, h = Tn(f, A_, s) * e % s, _ = Tn(h, k_, s) * h % s, v = Tn(_, t, s) * _ % s, y = Tn(v, n, s) * v % s, w = Tn(y, r, s) * y % s, p = Tn(w, i, s) * w % s, O = Tn(p, i, s) * w % s, $ = Tn(O, t, s) * _ % s; return { pow_p_5_8: Tn($, lh, s) * e % s, b2: a } } function O_(e) { return e[0] &= 248, e[31] &= 127, e[31] |= 64, e } const uh = BigInt("19681161376707505956807079304988542015446066515923890162744021073123829784752"); function U_(e, t) { const n = Dl.p, r = Qe(t * t * t, n), i = Qe(r * r * t, n), s = I_(e * i).pow_p_5_8; let o = Qe(e * r * s, n); const a = Qe(t * o * o, n), f = o, h = Qe(o * uh, n), _ = a === e, v = a === Qe(-e, n), y = a === Qe(-e * uh, n); return _ && (o = f), (v || y) && (o = h), Av(o, n) && (o = Qe(-o, n)), { isValid: _ || v, value: o } } const F_ = zr(Dl.p, { isLE: !0 }), C_ = { ...Dl, Fp: F_, hash: lx, adjustScalarBytes: O_, uvRatio: U_ }, P_ = B_(C_); var ch = function (e, t, n, r, i) { if (r === "m") throw new TypeError("Private method is not writable"); if (r === "a" && !i) throw new TypeError("Private accessor was defined without a setter"); if (typeof t == "function" ? e !== t || !i : !t.has(e)) throw new TypeError("Cannot write private member to an object whose class did not declare it"); return r === "a" ? i.call(e, n) : i ? i.value = n : t.set(e, n), n }, Ft = function (e, t, n, r) { if (n === "a" && !r) throw new TypeError("Private accessor was defined without a getter"); if (typeof t == "function" ? e !== t || !r : !t.has(e)) throw new TypeError("Cannot read private member from an object whose class did not declare it"); return n === "m" ? r : n === "a" ? r.call(e) : r ? r.value : t.get(e) }, Tt, js, Ny, Ty; class M_ { constructor(t = {}) { Tt.set(this, void 0), js.set(this, void 0), this[Ny] = this.entries.bind(this), this[Ty] = "ExpirableMap"; const { source: n = [], expirationTime: r = 10 * 60 * 1e3 } = t, i = Date.now(); ch(this, Tt, new Map([...n].map(([s, o]) => [s, { value: o, timestamp: i }])), "f"), ch(this, js, r, "f") } prune() { const t = Date.now(); for (const [n, r] of Ft(this, Tt, "f").entries()) t - r.timestamp > Ft(this, js, "f") && Ft(this, Tt, "f").delete(n); return this } set(t, n) { this.prune(); const r = { value: n, timestamp: Date.now() }; return Ft(this, Tt, "f").set(t, r), this } get(t) { const n = Ft(this, Tt, "f").get(t); if (n !== void 0) { if (Date.now() - n.timestamp > Ft(this, js, "f")) { Ft(this, Tt, "f").delete(t); return } return n.value } } clear() { Ft(this, Tt, "f").clear() } entries() { const t = Ft(this, Tt, "f").entries(); return function* () { for (const [r, i] of t) yield [r, i.value] }() } values() { const t = Ft(this, Tt, "f").values(); return function* () { for (const r of t) yield r.value }() } keys() { return Ft(this, Tt, "f").keys() } forEach(t, n) { for (const [r, i] of Ft(this, Tt, "f").entries()) t.call(n, i.value, r, this) } has(t) { return Ft(this, Tt, "f").has(t) } delete(t) { return Ft(this, Tt, "f").delete(t) } get size() { return Ft(this, Tt, "f").size } } Tt = new WeakMap, js = new WeakMap, Ny = Symbol.iterator, Ty = Symbol.toStringTag; const fh = e => { if (e <= 127) return 1; if (e <= 255) return 2; if (e <= 65535) return 3; if (e <= 16777215) return 4; throw new Error("Length too long (> 4 bytes)") }, dh = (e, t, n) => { if (n <= 127) return e[t] = n, 1; if (n <= 255) return e[t] = 129, e[t + 1] = n, 2; if (n <= 65535) return e[t] = 130, e[t + 1] = n >> 8, e[t + 2] = n, 3; if (n <= 16777215) return e[t] = 131, e[t + 1] = n >> 16, e[t + 2] = n >> 8, e[t + 3] = n, 4; throw new Error("Length too long (> 4 bytes)") }, uf = (e, t) => { if (e[t] < 128) return 1; if (e[t] === 128) throw new Error("Invalid length 0"); if (e[t] === 129) return 2; if (e[t] === 130) return 3; if (e[t] === 131) return 4; throw new Error("Length too long (> 4 bytes)") }, j_ = (e, t) => { const n = uf(e, t); if (n === 1) return e[t]; if (n === 2) return e[t + 1]; if (n === 3) return (e[t + 1] << 8) + e[t + 2]; if (n === 4) return (e[t + 1] << 16) + (e[t + 2] << 8) + e[t + 3]; throw new Error("Length too long (> 4 bytes)") }; Uint8Array.from([48, 12, 6, 10, 43, 6, 1, 4, 1, 131, 184, 67, 1, 1]); const hh = Uint8Array.from([48, 5, 6, 3, 43, 101, 112]); Uint8Array.from([48, 16, 6, 7, 42, 134, 72, 206, 61, 2, 1, 6, 5, 43, 129, 4, 0, 10]); function $_(e, t) { const n = 2 + fh(e.byteLength + 1), r = t.byteLength + n + e.byteLength; let i = 0; const s = new Uint8Array(1 + fh(r) + r); return s[i++] = 48, i += dh(s, i, r), s.set(t, i), i += t.byteLength, s[i++] = 3, i += dh(s, i, e.byteLength + 1), s[i++] = 0, s.set(new Uint8Array(e), i), s } const z_ = (e, t) => { let n = 0; const r = (a, f) => { if (i[n++] !== a) throw new Error("Expected: " + f) }, i = new Uint8Array(e); if (r(48, "sequence"), n += uf(i, n), !jl(i.slice(n, n + t.byteLength), t)) throw new Error("Not the expected OID."); n += t.byteLength, r(3, "bit string"); const s = j_(i, n) - 1; n += uf(i, n), r(0, "0 padding"); const o = i.slice(n); if (s !== o.length) throw new Error(`DER payload mismatch: Expected length ${s} actual length ${o.length}`); return o }; var ph = function (e, t, n, r, i) { if (r === "m") throw new TypeError("Private method is not writable"); if (r === "a" && !i) throw new TypeError("Private accessor was defined without a setter"); if (typeof t == "function" ? e !== t || !i : !t.has(e)) throw new TypeError("Cannot write private member to an object whose class did not declare it"); return r === "a" ? i.call(e, n) : i ? i.value = n : t.set(e, n), n }, mh = function (e, t, n, r) { if (n === "a" && !r) throw new TypeError("Private accessor was defined without a getter"); if (typeof t == "function" ? e !== t || !r : !t.has(e)) throw new TypeError("Cannot read private member from an object whose class did not declare it"); return n === "m" ? r : n === "a" ? r.call(e) : r ? r.value : t.get(e) }, ka, Ra; class ti { constructor(t) { if (ka.set(this, void 0), Ra.set(this, void 0), t.byteLength !== ti.RAW_KEY_LENGTH) throw new Error("An Ed25519 public key must be exactly 32bytes long"); ph(this, ka, t, "f"), ph(this, Ra, ti.derEncode(t), "f") } static from(t) { return this.fromDer(t.toDer()) } static fromRaw(t) { return new ti(t) } static fromDer(t) { return new ti(this.derDecode(t)) } static derEncode(t) { return $_(t, hh).buffer } static derDecode(t) { const n = z_(t, hh); if (n.length !== this.RAW_KEY_LENGTH) throw new Error("An Ed25519 public key must be exactly 32bytes long"); return n } get rawKey() { return mh(this, ka, "f") } get derKey() { return mh(this, Ra, "f") } toDer() { return this.derKey } toRaw() { return this.rawKey } } ka = new WeakMap, Ra = new WeakMap; ti.RAW_KEY_LENGTH = 32; class V_ { constructor() { this.observers = [] } subscribe(t) { this.observers.push(t) } unsubscribe(t) { this.observers = this.observers.filter(n => n !== t) } notify(t, ...n) { this.observers.forEach(r => r(t, ...n)) } } class q_ extends V_ { constructor() { super() } print(t, ...n) { this.notify({ message: t, level: "info" }, ...n) } warn(t, ...n) { this.notify({ message: t, level: "warn" }, ...n) } error(t, n, ...r) { this.notify({ message: t, level: "error", error: n }, ...r) } } var Bn = function (e, t, n, r, i) { if (r === "m") throw new TypeError("Private method is not writable"); if (r === "a" && !i) throw new TypeError("Private accessor was defined without a setter"); if (typeof t == "function" ? e !== t || !i : !t.has(e)) throw new TypeError("Cannot write private member to an object whose class did not declare it"); return r === "a" ? i.call(e, n) : i ? i.value = n : t.set(e, n), n }, Nt = function (e, t, n, r) { if (n === "a" && !r) throw new TypeError("Private accessor was defined without a getter"); if (typeof t == "function" ? e !== t || !r : !t.has(e)) throw new TypeError("Cannot read private member from an object whose class did not declare it"); return n === "m" ? r : n === "a" ? r.call(e) : r ? r.value : t.get(e) }, kn, Ia, Oa, Ua, Fa, Ca, Pa, Ma, Bi; const By = .5, Ay = 1.5, ky = 500, Ry = 6e4, Iy = 9e5, Oy = 10; class Jl { constructor(t = Jl.default) { kn.set(this, void 0), Ia.set(this, void 0), Oa.set(this, void 0), Ua.set(this, void 0), Fa.set(this, void 0), Ca.set(this, void 0), Pa.set(this, void 0), Ma.set(this, void 0), Bi.set(this, 0); const { initialInterval: n = ky, randomizationFactor: r = By, multiplier: i = Ay, maxInterval: s = Ry, maxElapsedTime: o = Iy, maxIterations: a = Oy, date: f = Date } = t; Bn(this, kn, n, "f"), Bn(this, Ia, r, "f"), Bn(this, Oa, i, "f"), Bn(this, Ua, s, "f"), Bn(this, Ma, f, "f"), Bn(this, Fa, f.now(), "f"), Bn(this, Ca, o, "f"), Bn(this, Pa, a, "f") } get ellapsedTimeInMsec() { return Nt(this, Ma, "f").now() - Nt(this, Fa, "f") } get currentInterval() { return Nt(this, kn, "f") } get count() { return Nt(this, Bi, "f") } get randomValueFromInterval() { const t = Nt(this, Ia, "f") * Nt(this, kn, "f"), n = Nt(this, kn, "f") - t, r = Nt(this, kn, "f") + t; return Math.random() * (r - n) + n } incrementCurrentInterval() { var t; return Bn(this, kn, Math.min(Nt(this, kn, "f") * Nt(this, Oa, "f"), Nt(this, Ua, "f")), "f"), Bn(this, Bi, (t = Nt(this, Bi, "f"), t++, t), "f"), Nt(this, kn, "f") } next() { return this.ellapsedTimeInMsec >= Nt(this, Ca, "f") || Nt(this, Bi, "f") >= Nt(this, Pa, "f") ? null : (this.incrementCurrentInterval(), this.randomValueFromInterval) } } kn = new WeakMap, Ia = new WeakMap, Oa = new WeakMap, Ua = new WeakMap, Fa = new WeakMap, Ca = new WeakMap, Pa = new WeakMap, Ma = new WeakMap, Bi = new WeakMap; Jl.default = { initialInterval: ky, randomizationFactor: By, multiplier: Ay, maxInterval: Ry, maxElapsedTime: Iy, maxIterations: Oy, date: Date }; var yt = function (e, t, n, r, i) { if (r === "m") throw new TypeError("Private method is not writable"); if (r === "a" && !i) throw new TypeError("Private accessor was defined without a setter"); if (typeof t == "function" ? e !== t || !i : !t.has(e)) throw new TypeError("Cannot write private member to an object whose class did not declare it"); return r === "a" ? i.call(e, n) : i ? i.value = n : t.set(e, n), n }, ce = function (e, t, n, r) { if (n === "a" && !r) throw new TypeError("Private accessor was defined without a getter"); if (typeof t == "function" ? e !== t || !r : !t.has(e)) throw new TypeError("Cannot read private member from an object whose class did not declare it"); return n === "m" ? r : n === "a" ? r.call(e) : r ? r.value : t.get(e) }, Bt, Hr, ts, Rn, Ln, Wi, $s, Ai, pn, yn, Gr, Lr, zs, ki, Ri, Wr, Kr, Uy, ja, $a, Yr, Wn; (function (e) { e.Received = "received", e.Processing = "processing", e.Replied = "replied", e.Rejected = "rejected", e.Unknown = "unknown", e.Done = "done" })(Wn || (Wn = {})); const aa = 60 * 1e3, H_ = "308182301d060d2b0601040182dc7c0503010201060c2b0601040182dc7c05030201036100814c0e6ec71fab583b08bd81373c255c3c371b2e84863c98a4f1e08b74235d14fb5d9c0cd546d9685f913a0c0b2cc5341583bf4b4392e467db96d65b9bb4cb717112f8472e0d5a4d14505ffd7484b01291091c5f87b98883463f98091a0baaae", G_ = "aaaaa-aa", L_ = "ic0.app", W_ = ".ic0.app", Y_ = "icp0.io", K_ = ".icp0.io", Z_ = "icp-api.io", X_ = ".icp-api.io"; class Du extends Ze { constructor(t) { super(t), this.message = t } } class la extends Ze { constructor(t) { super(t), this.message = t } } function Q_() { let e; if (typeof window < "u") if (window.fetch) e = window.fetch.bind(window); else throw new Du("Fetch implementation was not available. You appear to be in a browser context, but window.fetch was not present."); else if (typeof global < "u") if (global.fetch) e = global.fetch.bind(global); else throw new Du("Fetch implementation was not available. You appear to be in a Node.js context, but global.fetch was not available."); else typeof self < "u" && self.fetch && (e = self.fetch.bind(self)); if (e) return e; throw new Du("Fetch implementation was not available. Please provide fetch to the HttpAgent constructor, or ensure it is available in the window or global context.") } function D_(e) { let t; if (e !== void 0) !e.match(/^[a-z]+:/) && typeof window < "u" ? t = new URL(window.location.protocol + "//" + e) : t = new URL(e); else { const n = ["ic0.app", "icp0.io", "127.0.0.1", "localhost"], r = [".github.dev", ".gitpod.io"], i = typeof window < "u" ? window.location : void 0, s = i == null ? void 0 : i.hostname; let o; s && typeof s == "string" && (r.some(a => s.endsWith(a)) ? o = s : o = n.find(a => s.endsWith(a))), i && o ? t = new URL(`${i.protocol}//${o}${i.port ? ":" + i.port : ""}`) : t = new URL("https://icp-api.io") } return t.toString() } class Yi {
  constructor(t = {}) { var n, r; Bt.add(this), Hr.set(this, null), ts.set(this, !1), Rn.set(this, void 0), Ln.set(this, void 0), Wi.set(this, void 0), $s.set(this, void 0), Ai.set(this, 0), pn.set(this, void 0), yn.set(this, void 0), Gr.set(this, void 0), Lr.set(this, void 0), this._isAgent = !0, this.config = {}, zs.set(this, 0), this.log = new q_, ki.set(this, []), Ri.set(this, []), Wr.set(this, new M_({ expirationTime: 5 * 60 * 1e3 })), Kr.set(this, !0), $a.set(this, (o, a) => { if (ce(this, Kr, "f") === !1) return o; if (!a) throw new Un("Invalid signature from replica signed query: no matching node key found."); const { status: f, signatures: h = [], requestId: _ } = o, v = Fs(new TextEncoder().encode("\vic-response")); for (const y of h) { const { timestamp: w, identity: p } = y, O = Se.fromUint8Array(p).toText(); let $; if (f === "replied") { const { reply: k } = o; $ = ml({ status: f, reply: k, timestamp: BigInt(w), request_id: _ }) } else if (f === "rejected") { const { reject_code: k, reject_message: C, error_code: V } = o; $ = ml({ status: f, reject_code: k, reject_message: C, error_code: V, timestamp: BigInt(w), request_id: _ }) } else throw new Error(`Unknown status: ${f}`); const b = $n(v, Fs(new Uint8Array($))), E = a == null ? void 0 : a.nodeKeys.get(O); if (!E) throw new Un("Invalid signature from replica signed query: no matching node key found."); const S = ti.fromDer(E).rawKey; if (P_.verify(y.signature, new Uint8Array(b), new Uint8Array(S))) return o; throw new Un(`Invalid signature from replica ${O} signed query.`) } return o }), this.config = t, yt(this, Ln, t.fetch || Q_() || fetch.bind(global), "f"), yt(this, Wi, t.fetchOptions, "f"), yt(this, $s, t.callOptions, "f"), yt(this, ts, (n = t.shouldFetchRootKey) !== null && n !== void 0 ? n : !1, "f"), t.rootKey ? this.rootKey = t.rootKey : ce(this, ts, "f") ? this.rootKey = null : this.rootKey = fl(H_); const i = D_(t.host); this.host = new URL(i), t.verifyQuerySignatures !== void 0 && yt(this, Kr, t.verifyQuerySignatures, "f"), yt(this, yn, (r = t.retryTimes) !== null && r !== void 0 ? r : 3, "f"); const s = () => new Jl({ maxIterations: ce(this, yn, "f") }); if (yt(this, Gr, t.backoffStrategy || s, "f"), this.host.hostname.endsWith(W_) ? this.host.hostname = L_ : this.host.hostname.endsWith(K_) ? this.host.hostname = Y_ : this.host.hostname.endsWith(X_) && (this.host.hostname = Z_), t.credentials) { const { name: o, password: a } = t.credentials; yt(this, pn, `${o}${a ? ":" + a : ""}`, "f") } if (yt(this, Rn, Promise.resolve(t.identity || new q0), "f"), t.ingressExpiryInMinutes && t.ingressExpiryInMinutes > 5) throw new Ze(`The maximum ingress expiry time is 5 minutes. Provided ingress expiry time is ${t.ingressExpiryInMinutes} minutes.`); if (t.ingressExpiryInMinutes && t.ingressExpiryInMinutes <= 0) throw new Ze(`Ingress expiry time must be greater than 0. Provided ingress expiry time is ${t.ingressExpiryInMinutes} minutes.`); yt(this, Lr, t.ingressExpiryInMinutes || 5, "f"), this.addTransform("update", L0(rf)), t.useQueryNonces && this.addTransform("query", L0(rf)), t.logToConsole && this.log.subscribe(o => { o.level === "error" ? console.error(o.message) : o.level === "warn" ? console.warn(o.message) : console.log(o.message) }) } get waterMark() { return ce(this, zs, "f") } static createSync(t = {}) { return new this(Object.assign({}, t)) } static async create(t = { shouldFetchRootKey: !1 }) { const n = Yi.createSync(t), r = [n.syncTime()]; return n.host.toString() !== "https://icp-api.io" && t.shouldFetchRootKey && r.push(n.fetchRootKey()), await Promise.all(r), n } static async from(t) { var n; try { return "config" in t ? await Yi.create(t.config) : await Yi.create({ fetch: t._fetch, fetchOptions: t._fetchOptions, callOptions: t._callOptions, host: t._host.toString(), identity: (n = t._identity) !== null && n !== void 0 ? n : void 0 }) } catch { throw new Ze("Failed to create agent from provided agent") } } isLocal() { const t = this.host.hostname; return t === "127.0.0.1" || t.endsWith("127.0.0.1") } addTransform(t, n, r = n.priority || 0) { if (t === "update") { const i = ce(this, Ri, "f").findIndex(s => (s.priority || 0) < r); ce(this, Ri, "f").splice(i >= 0 ? i : ce(this, Ri, "f").length, 0, Object.assign(n, { priority: r })) } else if (t === "query") { const i = ce(this, ki, "f").findIndex(s => (s.priority || 0) < r); ce(this, ki, "f").splice(i >= 0 ? i : ce(this, ki, "f").length, 0, Object.assign(n, { priority: r })) } } async getPrincipal() { if (!ce(this, Rn, "f")) throw new la("This identity has expired due this application's security policy. Please refresh your authentication."); return (await ce(this, Rn, "f")).getPrincipal() } async call(t, n, r) { var i, s; await ce(this, Bt, "m", Yr).call(this); const o = (i = n.callSync) !== null && i !== void 0 ? i : !0, a = await (r !== void 0 ? await r : await ce(this, Rn, "f")); if (!a) throw new la("This identity has expired due this application's security policy. Please refresh your authentication."); const f = Se.from(t), h = n.effectiveCanisterId ? Se.from(n.effectiveCanisterId) : f, _ = a.getPrincipal() || Se.anonymous(); let v = new sa(ce(this, Lr, "f") * aa); Math.abs(ce(this, Ai, "f")) > 1e3 * 30 && (v = new sa(ce(this, Lr, "f") * aa + ce(this, Ai, "f"))); const y = { request_type: nf.Call, canister_id: f, method_name: n.methodName, arg: n.arg, sender: _, ingress_expiry: v }; let w = await this._transform({ request: { body: null, method: "POST", headers: Object.assign({ "Content-Type": "application/cbor" }, ce(this, pn, "f") ? { Authorization: "Basic " + btoa(ce(this, pn, "f")) } : {}) }, endpoint: "call", body: y }), p; n != null && n.nonce ? p = O(n.nonce) : w.body.nonce ? p = O(w.body.nonce) : p = void 0, y.nonce = p; function O(S) { return new Uint8Array(S) } w = await a.transformRequest(w); const $ = ju(w.body), b = ce(this, Gr, "f").call(this), E = V0(y); try { const S = () => (this.log.print(`fetching "/api/v3/canister/${h.toText()}/call" with request:`, w), ce(this, Ln, "f").call(this, "" + new URL(`/api/v3/canister/${h.toText()}/call`, this.host), Object.assign(Object.assign(Object.assign({}, ce(this, $s, "f")), w.request), { body: $ }))), M = () => (this.log.print(`fetching "/api/v2/canister/${h.toText()}/call" with request:`, w), ce(this, Ln, "f").call(this, "" + new URL(`/api/v2/canister/${h.toText()}/call`, this.host), Object.assign(Object.assign(Object.assign({}, ce(this, $s, "f")), w.request), { body: $ }))), C = await ce(this, Bt, "m", ja).call(this, { request: o ? S : M, backoff: b, tries: 0 }), V = await C.arrayBuffer(), Y = C.status === 200 && V.byteLength > 0 ? Jn(V) : null; if (Y && "certificate" in Y) { const re = await this.parseTimeFromResponse({ certificate: Y.certificate }); yt(this, zs, re, "f") } return { requestId: E, response: { ok: C.ok, status: C.status, statusText: C.statusText, body: Y, headers: Cs(C.headers) }, requestDetails: y } } catch (S) { if (S.message.includes("v3 api not supported.")) return this.log.warn("v3 api not supported. Fall back to v2"), this.call(t, Object.assign(Object.assign({}, n), { callSync: !1 }), r); const M = `Error while making call: ${(s = S.message) !== null && s !== void 0 ? s : String(S)}`, k = new wv(M, S, ht(E), ht(w.body.sender_pubkey), ht(w.body.sender_sig), String(w.body.content.ingress_expiry._value)); throw this.log.error(M, k), k } } async query(t, n, r) { var i, s, o, a; await ce(this, Bt, "m", Yr).call(this); const f = ce(this, Gr, "f").call(this), h = n.effectiveCanisterId ? Se.from(n.effectiveCanisterId) : Se.from(t); this.log.print(`ecid ${h.toString()}`), this.log.print(`canisterId ${t.toString()}`); let _, v; const y = await (r !== void 0 ? r : ce(this, Rn, "f")); if (!y) throw new la("This identity has expired due this application's security policy. Please refresh your authentication."); const w = Se.from(t), p = (y == null ? void 0 : y.getPrincipal()) || Se.anonymous(), O = { request_type: "query", canister_id: w, method_name: n.methodName, arg: n.arg, sender: p, ingress_expiry: new sa(ce(this, Lr, "f") * aa) }, $ = V0(O); _ = await this._transform({ request: { method: "POST", headers: Object.assign({ "Content-Type": "application/cbor" }, ce(this, pn, "f") ? { Authorization: "Basic " + btoa(ce(this, pn, "f")) } : {}) }, endpoint: "read", body: O }), _ = await (y == null ? void 0 : y.transformRequest(_)); const b = ju(_.body), E = { canister: w.toText(), ecid: h, transformedRequest: _, body: b, requestId: $, backoff: f, tries: 0 }, S = async () => ({ requestDetails: O, query: await ce(this, Bt, "m", Uy).call(this, E) }), M = async () => { if (!ce(this, Kr, "f")) return; const k = ce(this, Wr, "f").get(h.toString()); return k || (await this.fetchSubnetKeys(h.toString()), ce(this, Wr, "f").get(h.toString())) }; try { const [k, C] = await Promise.all([S(), M()]); v = k; const { requestDetails: V, query: Y } = v, re = Object.assign(Object.assign({}, Y), { requestDetails: V }); if (this.log.print("Query response:", re), !ce(this, Kr, "f")) return re; try { return ce(this, $a, "f").call(this, re, C) } catch { this.log.warn("Query response verification failed. Retrying with fresh subnet keys."), ce(this, Wr, "f").delete(t.toString()), await this.fetchSubnetKeys(h.toString()); const K = ce(this, Wr, "f").get(t.toString()); if (!K) throw new Un("Invalid signature from replica signed query: no matching node key found."); return ce(this, $a, "f").call(this, re, K) } } catch (k) { const C = `Error while making call: ${(i = k.message) !== null && i !== void 0 ? i : String(k)}`, V = new xv(C, k, String($), ht((s = _ == null ? void 0 : _.body) === null || s === void 0 ? void 0 : s.sender_pubkey), ht((o = _ == null ? void 0 : _.body) === null || o === void 0 ? void 0 : o.sender_sig), String((a = _ == null ? void 0 : _.body) === null || a === void 0 ? void 0 : a.content.ingress_expiry._value)); throw this.log.error(C, V), V } } async createReadStateRequest(t, n) { await ce(this, Bt, "m", Yr).call(this); const r = await (n !== void 0 ? await n : await ce(this, Rn, "f")); if (!r) throw new la("This identity has expired due this application's security policy. Please refresh your authentication."); const i = (r == null ? void 0 : r.getPrincipal()) || Se.anonymous(), s = await this._transform({ request: { method: "POST", headers: Object.assign({ "Content-Type": "application/cbor" }, ce(this, pn, "f") ? { Authorization: "Basic " + btoa(ce(this, pn, "f")) } : {}) }, endpoint: "read_state", body: { request_type: "read_state", paths: t.paths, sender: i, ingress_expiry: new sa(ce(this, Lr, "f") * aa) } }); return r == null ? void 0 : r.transformRequest(s) } async readState(t, n, r, i) {
    var s, o, a, f; function h(O) { for (const $ of O.paths) { const [b, E] = $, S = Fs(new TextEncoder().encode("request_status")); if (jl(b, S)) return E } } const _ = h(n); await ce(this, Bt, "m", Yr).call(this); const v = typeof t == "string" ? Se.fromText(t) : t, y = i ?? await this.createReadStateRequest(n, r), w = ju(y.body); this.log.print(`fetching "/api/v2/canister/${v}/read_state" with request:`, y); const p = ce(this, Gr, "f").call(this); try {
      const O = await ce(this, Bt, "m", ja).call(this, { request: () => ce(this, Ln, "f").call(this, "" + new URL(`/api/v2/canister/${v.toString()}/read_state`, this.host), Object.assign(Object.assign(Object.assign({}, ce(this, Wi, "f")), y.request), { body: w })), backoff: p, tries: 0 }); if (!O.ok) throw new Error(`Server returned an error:
  Code: ${O.status} (${O.statusText})
  Body: ${await O.text()}
`); const $ = Jn(await O.arrayBuffer()); this.log.print("Read state response:", $); const b = await this.parseTimeFromResponse($); return b > 0 && (this.log.print("Read state response time:", b), yt(this, zs, b, "f")), $
    } catch (O) { const $ = `Caught exception while attempting to read state: ${(s = O.message) !== null && s !== void 0 ? s : String(O)}`, b = new vv($, O, String(_), ht((o = y == null ? void 0 : y.body) === null || o === void 0 ? void 0 : o.sender_pubkey), ht((a = y == null ? void 0 : y.body) === null || a === void 0 ? void 0 : a.sender_sig), String((f = y == null ? void 0 : y.body) === null || f === void 0 ? void 0 : f.content.ingress_expiry._value)); throw this.log.error($, b), b }
  } async parseTimeFromResponse(t) { let n; if (t.certificate) { const r = Jn(t.certificate); if (r && "tree" in r) n = r.tree; else throw new Error("Could not decode time from response"); const i = ps(["time"], n); if (i.status !== st.Found) throw new Error("Time was not found in the response or was not in its expected format."); if (!(i.value instanceof ArrayBuffer) && !ArrayBuffer.isView(i)) throw new Error("Time was not found in the response or was not in its expected format."); const s = wd(Fs(i.value)); return this.log.print("Time from response:", s), this.log.print("Time from response in milliseconds:", Number(s)), Number(s) } else this.log.warn("No certificate found in response"); return 0 } async syncTime(t) { await ce(this, Bt, "m", Yr).call(this); const n = await P2(() => Promise.resolve().then(() => v_), void 0, import.meta.url), r = Date.now(); try { t || this.log.print("Syncing time with the IC. No canisterId provided, so falling back to ryjl3-tyaaa-aaaaa-aaaba-cai"); const i = Yi.createSync({ identity: new q0, host: this.host.toString(), fetch: ce(this, Ln, "f"), retryTimes: 0 }), o = (await n.request({ canisterId: t ?? Se.from("ryjl3-tyaaa-aaaaa-aaaba-cai"), agent: i, paths: ["time"] })).get("time"); o && (yt(this, Ai, Number(o) - Number(r), "f"), this.log.notify({ message: `Syncing time: offset of ${ce(this, Ai, "f")}`, level: "info" })) } catch (i) { this.log.error("Caught exception while attempting to sync time", i) } } async status() { const t = ce(this, pn, "f") ? { Authorization: "Basic " + btoa(ce(this, pn, "f")) } : {}; this.log.print('fetching "/api/v2/status"'); const n = ce(this, Gr, "f").call(this), r = await ce(this, Bt, "m", ja).call(this, { backoff: n, request: () => ce(this, Ln, "f").call(this, "" + new URL("/api/v2/status", this.host), Object.assign({ headers: t }, ce(this, Wi, "f"))), tries: 0 }); return Jn(await r.arrayBuffer()) } async fetchRootKey() { let t; return ce(this, Hr, "f") ? t = await ce(this, Hr, "f") : (yt(this, Hr, new Promise((n, r) => { this.status().then(i => { const s = i.root_key; this.rootKey = s, n(s) }).catch(r) }), "f"), t = await ce(this, Hr, "f")), yt(this, Hr, null, "f"), t } invalidateIdentity() { yt(this, Rn, null, "f") } replaceIdentity(t) { yt(this, Rn, Promise.resolve(t), "f") } async fetchSubnetKeys(t) { await ce(this, Bt, "m", Yr).call(this); const n = Se.from(t), i = (await Ey({ canisterId: n, paths: ["subnet"], agent: this })).get("subnet"); if (i && typeof i == "object" && "nodeKeys" in i) return ce(this, Wr, "f").set(n.toText(), i), i } _transform(t) { let n = Promise.resolve(t); if (t.endpoint === "call") for (const r of ce(this, Ri, "f")) n = n.then(i => r(i).then(s => s || i)); else for (const r of ce(this, ki, "f")) n = n.then(i => r(i).then(s => s || i)); return n }
} Hr = new WeakMap, ts = new WeakMap, Rn = new WeakMap, Ln = new WeakMap, Wi = new WeakMap, $s = new WeakMap, Ai = new WeakMap, pn = new WeakMap, yn = new WeakMap, Gr = new WeakMap, Lr = new WeakMap, zs = new WeakMap, ki = new WeakMap, Ri = new WeakMap, Wr = new WeakMap, Kr = new WeakMap, $a = new WeakMap, Bt = new WeakSet, Uy = async function e(t) {
  var n, r; const { ecid: i, transformedRequest: s, body: o, requestId: a, backoff: f, tries: h } = t, _ = h === 0 ? 0 : f.next(); if (this.log.print(`fetching "/api/v2/canister/${i.toString()}/query" with tries:`, { tries: h, backoff: f, delay: _ }), _ === null) throw new Ze(`Timestamp failed to pass the watermark after retrying the configured ${ce(this, yn, "f")} times. We cannot guarantee the integrity of the response since it could be a replay attack.`); _ > 0 && await new Promise(p => setTimeout(p, _)); let v; try {
    this.log.print(`fetching "/api/v2/canister/${i.toString()}/query" with request:`, s); const p = await ce(this, Ln, "f").call(this, "" + new URL(`/api/v2/canister/${i.toString()}/query`, this.host), Object.assign(Object.assign(Object.assign({}, ce(this, Wi, "f")), s.request), { body: o })); if (p.status === 200) { const O = Jn(await p.arrayBuffer()); v = Object.assign(Object.assign({}, O), { httpDetails: { ok: p.ok, status: p.status, statusText: p.statusText, headers: Cs(p.headers) }, requestId: a }) } else throw new $u(`Gateway returned an error:
  Code: ${p.status} (${p.statusText})
  Body: ${await p.text()}
`, { ok: p.ok, status: p.status, statusText: p.statusText, headers: Cs(p.headers) })
  } catch (p) {
    if (h < ce(this, yn, "f")) return this.log.warn(`Caught exception while attempting to make query:
  ${p}
  Retrying query.`), await ce(this, Bt, "m", e).call(this, Object.assign(Object.assign({}, t), { tries: h + 1 })); throw p
  } const y = (r = (n = v.signatures) === null || n === void 0 ? void 0 : n[0]) === null || r === void 0 ? void 0 : r.timestamp; if (!ce(this, Kr, "f")) return v; if (!y) throw new Error("Timestamp not found in query response. This suggests a malformed or malicious response."); const w = Number(BigInt(y) / BigInt(1e6)); if (this.log.print("watermark and timestamp", { waterMark: this.waterMark, timestamp: w }), Number(this.waterMark) > w) { const p = new Ze("Timestamp is below the watermark. Retrying query."); if (this.log.error("Timestamp is below", p, { timestamp: y, waterMark: this.waterMark }), h < ce(this, yn, "f")) return await ce(this, Bt, "m", e).call(this, Object.assign(Object.assign({}, t), { tries: h + 1 })); throw new Ze(`Timestamp failed to pass the watermark after retrying the configured ${ce(this, yn, "f")} times. We cannot guarantee the integrity of the response since it could be a replay attack.`) } return v
}, ja = async function e(t) {
  const { request: n, backoff: r, tries: i } = t, s = i === 0 ? 0 : r.next(); if (s === null) throw new Ze(`Timestamp failed to pass the watermark after retrying the configured ${ce(this, yn, "f")} times. We cannot guarantee the integrity of the response since it could be a replay attack.`); s > 0 && await new Promise(h => setTimeout(h, s)); let o; try { o = await n() } catch (h) {
    if (ce(this, yn, "f") > i) return this.log.warn(`Caught exception while attempting to make request:
  ${h}
  Retrying request.`), await ce(this, Bt, "m", e).call(this, { request: n, backoff: r, tries: i + 1 }); throw h
  } if (o.ok) return o; const a = await o.clone().text(), f = `Server returned an error:
  Code: ${o.status} (${o.statusText})
  Body: ${a}
`; if (o.status === 404 && o.url.includes("api/v3")) throw new $u("v3 api not supported. Fall back to v2", { ok: o.ok, status: o.status, statusText: o.statusText, headers: Cs(o.headers) }); if (i < ce(this, yn, "f")) return await ce(this, Bt, "m", e).call(this, { request: n, backoff: r, tries: i + 1 }); throw new $u(f, { ok: o.ok, status: o.status, statusText: o.statusText, headers: Cs(o.headers) })
}, Yr = async function () { if (!this.rootKey) if (this.rootKey === null && ce(this, ts, "f")) await this.fetchRootKey(); else throw new Ze(`Invalid root key detected. The root key for this agent is ${this.rootKey} and the shouldFetchRootKey value is set to ${ce(this, ts, "f")}. The root key should only be unknown if you are in local development. Otherwise you should avoid fetching and use the default IC Root Key or the known root key of your environment.`) }; var yh; (function (e) { e.Error = "err", e.GetPrincipal = "gp", e.GetPrincipalResponse = "gpr", e.Query = "q", e.QueryResponse = "qr", e.Call = "c", e.CallResponse = "cr", e.ReadState = "rs", e.ReadStateResponse = "rsr", e.Status = "s", e.StatusResponse = "sr" })(yh || (yh = {})); function gh() { const e = typeof window > "u" ? typeof global > "u" ? typeof self > "u" ? void 0 : self.ic.agent : global.ic.agent : window.ic.agent; if (!e) throw new Error("No Agent could be found."); return e } const J_ = 5 * 60 * 1e3; function Fy() { return i8(t8(e8(), 1e3), r8(1e3, 1.2), n8(J_)) } function e8() { let e = !0; return async () => e ? (e = !1, !0) : !1 } function t8(e, t) { return async (n, r, i) => { if (await e(n, r, i)) return new Promise(s => setTimeout(s, t)) } } function n8(e) {
  const t = Date.now() + e; return async (n, r, i) => {
    if (Date.now() > t) throw new Error(`Request timed out after ${e} msec:
  Request ID: ${ht(r)}
  Request status: ${i}
`)
  }
} function r8(e, t) { let n = e; return () => new Promise(r => setTimeout(() => { n *= t, r() }, n)) } function i8(...e) { return async (t, n, r) => { for (const i of e) await i(t, n, r) } } async function Cy(e, t, n, r = Fy(), i, s) {
  var o; const a = [new TextEncoder().encode("request_status"), n], f = i ?? await ((o = e.createReadStateRequest) === null || o === void 0 ? void 0 : o.call(e, { paths: [a] })), h = await e.readState(t, { paths: [a] }, void 0, f); if (e.rootKey == null) throw new Error("Agent root key not initialized before polling"); const _ = await oi.create({ certificate: h.certificate, rootKey: e.rootKey, canisterId: t, blsVerify: s }), v = sn(_.lookup([...a, new TextEncoder().encode("status")])); let y; switch (typeof v > "u" ? y = Wn.Unknown : y = new TextDecoder().decode(v), y) {
    case Wn.Replied: return { reply: sn(_.lookup([...a, "reply"])), certificate: _ }; case Wn.Received: case Wn.Unknown: case Wn.Processing: return await r(t, n, y), Cy(e, t, n, r, f, s); case Wn.Rejected: {
      const w = new Uint8Array(sn(_.lookup([...a, "reject_code"])))[0], p = new TextDecoder().decode(sn(_.lookup([...a, "reject_message"]))); throw new Error(`Call was rejected:
  Request ID: ${ht(n)}
  Reject code: ${w}
  Reject text: ${p}
`)
    } case Wn.Done: throw new Error(`Call was marked as done but we never saw the reply:
  Request ID: ${ht(n)}
`)
  }throw new Error("unreachable")
} const s8 = ({ IDL: e }) => { const t = e.Variant({ mainnet: e.Null, testnet: e.Null }), n = e.Text, r = e.Record({ network: t, address: n, min_confirmations: e.Opt(e.Nat32) }), i = e.Nat64, s = i, o = e.Nat32, a = e.Record({ start_height: o, end_height: e.Opt(o), network: t }), f = e.Vec(e.Nat8), h = e.Record({ tip_height: o, block_headers: e.Vec(f) }), _ = e.Record({ network: t }), v = e.Nat64, y = e.Vec(v), w = e.Record({ network: t, filter: e.Opt(e.Variant({ page: e.Vec(e.Nat8), min_confirmations: e.Nat32 })), address: n }), p = e.Vec(e.Nat8), O = e.Record({ txid: e.Vec(e.Nat8), vout: e.Nat32 }), $ = e.Record({ height: e.Nat32, value: i, outpoint: O }), b = e.Record({ next_page: e.Opt(e.Vec(e.Nat8)), tip_height: o, tip_block_hash: p, utxos: e.Vec($) }), E = e.Record({ transaction: e.Vec(e.Nat8), network: t }), S = e.Principal, M = e.Record({ canister_id: S, num_requested_changes: e.Opt(e.Nat64) }), k = e.Variant({ from_user: e.Record({ user_id: e.Principal }), from_canister: e.Record({ canister_version: e.Opt(e.Nat64), canister_id: e.Principal }) }), C = e.Vec(e.Nat8), V = e.Variant({ creation: e.Record({ controllers: e.Vec(e.Principal) }), code_deployment: e.Record({ mode: e.Variant({ reinstall: e.Null, upgrade: e.Null, install: e.Null }), module_hash: e.Vec(e.Nat8) }), load_snapshot: e.Record({ canister_version: e.Nat64, taken_at_timestamp: e.Nat64, snapshot_id: C }), controllers_change: e.Record({ controllers: e.Vec(e.Principal) }), code_uninstall: e.Null }), Y = e.Record({ timestamp_nanos: e.Nat64, canister_version: e.Nat64, origin: k, details: V }), re = e.Record({ controllers: e.Vec(e.Principal), module_hash: e.Opt(e.Vec(e.Nat8)), recent_changes: e.Vec(Y), total_num_changes: e.Nat64 }), U = e.Record({ canister_id: S }), K = e.Variant({ controllers: e.Null, public: e.Null, allowed_viewers: e.Vec(e.Principal) }), ee = e.Record({ freezing_threshold: e.Nat, controllers: e.Vec(e.Principal), reserved_cycles_limit: e.Nat, log_visibility: K, wasm_memory_limit: e.Nat, memory_allocation: e.Nat, compute_allocation: e.Nat }), N = e.Record({ status: e.Variant({ stopped: e.Null, stopping: e.Null, running: e.Null }), memory_size: e.Nat, cycles: e.Nat, settings: ee, query_stats: e.Record({ response_payload_bytes_total: e.Nat, num_instructions_total: e.Nat, num_calls_total: e.Nat, request_payload_bytes_total: e.Nat }), idle_cycles_burned_per_day: e.Nat, module_hash: e.Opt(e.Vec(e.Nat8)), reserved_cycles: e.Nat }), F = e.Record({ canister_id: S }), G = e.Record({ freezing_threshold: e.Opt(e.Nat), controllers: e.Opt(e.Vec(e.Principal)), reserved_cycles_limit: e.Opt(e.Nat), log_visibility: e.Opt(K), wasm_memory_limit: e.Opt(e.Nat), memory_allocation: e.Opt(e.Nat), compute_allocation: e.Opt(e.Nat) }), J = e.Record({ settings: e.Opt(G), sender_canister_version: e.Opt(e.Nat64) }), ie = e.Record({ canister_id: S }), z = e.Record({ canister_id: S }), D = e.Record({ canister_id: S, snapshot_id: C }), ae = e.Record({ canister_id: S }), se = e.Variant({ secp256k1: e.Null }), oe = e.Record({ key_id: e.Record({ name: e.Text, curve: se }), canister_id: e.Opt(S), derivation_path: e.Vec(e.Vec(e.Nat8)) }), Ae = e.Record({ public_key: e.Vec(e.Nat8), chain_code: e.Vec(e.Nat8) }), B = e.Record({ canister_id: S }), Pe = e.Record({ idx: e.Nat64, timestamp_nanos: e.Nat64, content: e.Vec(e.Nat8) }), Ee = e.Record({ canister_log_records: e.Vec(Pe) }), Ue = e.Record({ value: e.Text, name: e.Text }), fe = e.Record({ status: e.Nat, body: e.Vec(e.Nat8), headers: e.Vec(Ue) }), ye = e.Record({ url: e.Text, method: e.Variant({ get: e.Null, head: e.Null, post: e.Null }), max_response_bytes: e.Opt(e.Nat64), body: e.Opt(e.Vec(e.Nat8)), transform: e.Opt(e.Record({ function: e.Func([e.Record({ context: e.Vec(e.Nat8), response: fe })], [fe], ["query"]), context: e.Vec(e.Nat8) })), headers: e.Vec(Ue) }), A = e.Variant({ reinstall: e.Null, upgrade: e.Opt(e.Record({ wasm_memory_persistence: e.Opt(e.Variant({ keep: e.Null, replace: e.Null })), skip_pre_upgrade: e.Opt(e.Bool) })), install: e.Null }), I = e.Record({ hash: e.Vec(e.Nat8) }), j = e.Record({ arg: e.Vec(e.Nat8), wasm_module_hash: e.Vec(e.Nat8), mode: A, chunk_hashes_list: e.Vec(I), target_canister: S, store_canister: e.Opt(S), sender_canister_version: e.Opt(e.Nat64) }), Z = e.Vec(e.Nat8), W = e.Record({ arg: e.Vec(e.Nat8), wasm_module: Z, mode: A, canister_id: S, sender_canister_version: e.Opt(e.Nat64) }), X = e.Record({ canister_id: S }), m = e.Record({ id: C, total_size: e.Nat64, taken_at_timestamp: e.Nat64 }), l = e.Vec(m), u = e.Record({ canister_id: S, sender_canister_version: e.Opt(e.Nat64), snapshot_id: C }), x = e.Record({ start_at_timestamp_nanos: e.Nat64, subnet_id: e.Principal }), T = e.Record({ num_block_failures_total: e.Nat64, node_id: e.Principal, num_blocks_proposed_total: e.Nat64 }), P = e.Vec(e.Record({ timestamp_nanos: e.Nat64, node_metrics: e.Vec(T) })), Q = e.Record({ settings: e.Opt(G), specified_id: e.Opt(S), amount: e.Opt(e.Nat), sender_canister_version: e.Opt(e.Nat64) }), le = e.Record({ canister_id: S }), de = e.Record({ canister_id: S, amount: e.Nat }), pe = e.Vec(e.Nat8), _e = e.Variant({ ed25519: e.Null, bip340secp256k1: e.Null }), g = e.Record({ key_id: e.Record({ algorithm: _e, name: e.Text }), canister_id: e.Opt(S), derivation_path: e.Vec(e.Vec(e.Nat8)) }), c = e.Record({ public_key: e.Vec(e.Nat8), chain_code: e.Vec(e.Nat8) }), d = e.Record({ key_id: e.Record({ name: e.Text, curve: se }), derivation_path: e.Vec(e.Vec(e.Nat8)), message_hash: e.Vec(e.Nat8) }), R = e.Record({ signature: e.Vec(e.Nat8) }), L = e.Variant({ bip341: e.Record({ merkle_root_hash: e.Vec(e.Nat8) }) }), ne = e.Record({ aux: e.Opt(L), key_id: e.Record({ algorithm: _e, name: e.Text }), derivation_path: e.Vec(e.Vec(e.Nat8)), message: e.Vec(e.Nat8) }), te = e.Record({ signature: e.Vec(e.Nat8) }), xe = e.Record({ canister_id: S }), be = e.Record({ canister_id: S }), ve = e.Record({ canister_id: S }), we = e.Vec(I), Oe = e.Record({ subnet_id: e.Principal }), ze = e.Record({ replica_version: e.Text }), tu = e.Record({ replace_snapshot: e.Opt(C), canister_id: S }), nu = m, ru = e.Record({ canister_id: S, sender_canister_version: e.Opt(e.Nat64) }), iu = e.Record({ canister_id: e.Principal, settings: G, sender_canister_version: e.Opt(e.Nat64) }), su = e.Record({ chunk: e.Vec(e.Nat8), canister_id: e.Principal }), ur = I; return e.Service({ bitcoin_get_balance: e.Func([r], [s], []), bitcoin_get_block_headers: e.Func([a], [h], []), bitcoin_get_current_fee_percentiles: e.Func([_], [y], []), bitcoin_get_utxos: e.Func([w], [b], []), bitcoin_send_transaction: e.Func([E], [], []), canister_info: e.Func([M], [re], []), canister_status: e.Func([U], [N], []), clear_chunk_store: e.Func([F], [], []), create_canister: e.Func([J], [ie], []), delete_canister: e.Func([z], [], []), delete_canister_snapshot: e.Func([D], [], []), deposit_cycles: e.Func([ae], [], []), ecdsa_public_key: e.Func([oe], [Ae], []), fetch_canister_logs: e.Func([B], [Ee], ["query"]), http_request: e.Func([ye], [fe], []), install_chunked_code: e.Func([j], [], []), install_code: e.Func([W], [], []), list_canister_snapshots: e.Func([X], [l], []), load_canister_snapshot: e.Func([u], [], []), node_metrics_history: e.Func([x], [P], []), provisional_create_canister_with_cycles: e.Func([Q], [le], []), provisional_top_up_canister: e.Func([de], [], []), raw_rand: e.Func([], [pe], []), schnorr_public_key: e.Func([g], [c], []), sign_with_ecdsa: e.Func([d], [R], []), sign_with_schnorr: e.Func([ne], [te], []), start_canister: e.Func([xe], [], []), stop_canister: e.Func([be], [], []), stored_chunks: e.Func([ve], [we], []), subnet_info: e.Func([Oe], [ze], []), take_canister_snapshot: e.Func([tu], [nu], []), uninstall_code: e.Func([ru], [], []), update_settings: e.Func([iu], [], []), upload_chunk: e.Func([su], [ur], []) }) }; class Py extends Ze {
  constructor(t, n, r, i) {
    super(["Call failed:", `  Canister: ${t.toText()}`, `  Method: ${n} (${r})`, ...Object.getOwnPropertyNames(i).map(s => `  "${s}": ${JSON.stringify(i[s])}`)].join(`
`)), this.canisterId = t, this.methodName = n, this.type = r, this.props = i
  }
} class o8 extends Py { constructor(t, n, r) { var i; super(t, n, "query", { Status: r.status, Code: (i = Wc[r.reject_code]) !== null && i !== void 0 ? i : `Unknown Code "${r.reject_code}"`, Message: r.reject_message }), this.result = r } } class wh extends Py { constructor(t, n, r, i, s, o, a) { super(t, n, "update", Object.assign({ "Request ID": ht(r) }, i.body ? Object.assign(Object.assign({}, a ? { "Error code": a } : {}), { "Reject code": String(s), "Reject message": o }) : { "HTTP status code": i.status.toString(), "HTTP status text": i.statusText })), this.requestId = r, this.response = i, this.reject_code = s, this.reject_message = o, this.error_code = a } } const tn = Symbol.for("ic-agent-metadata"); class eu { constructor(t) { this[tn] = Object.freeze(t) } static agentOf(t) { return t[tn].config.agent } static interfaceOf(t) { return t[tn].service } static canisterIdOf(t) { return Se.from(t[tn].config.canisterId) } static async install(t, n) { const r = t.mode === void 0 ? { install: null } : t.mode, i = t.arg ? [...new Uint8Array(t.arg)] : [], s = [...new Uint8Array(t.module)], o = typeof n.canisterId == "string" ? Se.fromText(n.canisterId) : n.canisterId; await xh(n).install_code({ mode: r, arg: i, wasm_module: s, canister_id: o, sender_canister_version: [] }) } static async createCanister(t, n) { function r(s) { return [{ controllers: s.controllers ? [s.controllers] : [], compute_allocation: s.compute_allocation ? [s.compute_allocation] : [], freezing_threshold: s.freezing_threshold ? [s.freezing_threshold] : [], memory_allocation: s.memory_allocation ? [s.memory_allocation] : [], reserved_cycles_limit: [], log_visibility: [], wasm_memory_limit: [] }] } const { canister_id: i } = await xh(t || {}).provisional_create_canister_with_cycles({ amount: [], settings: r(n || {}), specified_id: [], sender_canister_version: [] }); return i } static async createAndInstallCanister(t, n, r) { const i = await this.createCanister(r); return await this.install(Object.assign({}, n), Object.assign(Object.assign({}, r), { canisterId: i })), this.createActor(t, Object.assign(Object.assign({}, r), { canisterId: i })) } static createActorClass(t, n) { const r = t({ IDL: bx }); class i extends eu { constructor(o) { if (!o.canisterId) throw new Ze(`Canister ID is required, but received ${typeof o.canisterId} instead. If you are using automatically generated declarations, this may be because your application is not setting the canister ID in process.env correctly.`); const a = typeof o.canisterId == "string" ? Se.fromText(o.canisterId) : o.canisterId; super({ config: Object.assign(Object.assign(Object.assign({}, My), o), { canisterId: a }), service: r }); for (const [f, h] of r._fields) n != null && n.httpDetails && h.annotations.push(cf), n != null && n.certificate && h.annotations.push(jy), this[f] = a8(this, f, h, o.blsVerify) } } return i } static createActor(t, n) { if (!n.canisterId) throw new Ze(`Canister ID is required, but received ${typeof n.canisterId} instead. If you are using automatically generated declarations, this may be because your application is not setting the canister ID in process.env correctly.`); return new (this.createActorClass(t))(n) } static createActorWithHttpDetails(t, n) { return new (this.createActorClass(t, { httpDetails: !0 }))(n) } static createActorWithExtendedDetails(t, n, r = { httpDetails: !0, certificate: !0 }) { return new (this.createActorClass(t, r))(n) } } function Ti(e, t) { const n = nm(e, F1.Buffer.from(t)); switch (n.length) { case 0: return; case 1: return n[0]; default: return n } } const My = { pollingStrategyFactory: Fy }, cf = "http-details", jy = "certificate"; function a8(e, t, n, r) { let i; n.annotations.includes("query") || n.annotations.includes("composite_query") ? i = async (o, ...a) => { var f, h; o = Object.assign(Object.assign({}, o), (h = (f = e[tn].config).queryTransform) === null || h === void 0 ? void 0 : h.call(f, t, a, Object.assign(Object.assign({}, e[tn].config), o))); const _ = o.agent || e[tn].config.agent || gh(), v = Se.from(o.canisterId || e[tn].config.canisterId), y = Kc(n.argTypes, a), w = await _.query(v, { methodName: t, arg: y, effectiveCanisterId: o.effectiveCanisterId }), p = Object.assign(Object.assign({}, w.httpDetails), { requestDetails: w.requestDetails }); switch (w.status) { case "rejected": throw new o8(v, t, w); case "replied": return n.annotations.includes(cf) ? { httpDetails: p, result: Ti(n.retTypes, w.reply.arg) } : Ti(n.retTypes, w.reply.arg) } } : i = async (o, ...a) => { var f, h; o = Object.assign(Object.assign({}, o), (h = (f = e[tn].config).callTransform) === null || h === void 0 ? void 0 : h.call(f, t, a, Object.assign(Object.assign({}, e[tn].config), o))); const _ = o.agent || e[tn].config.agent || gh(), { canisterId: v, effectiveCanisterId: y, pollingStrategyFactory: w } = Object.assign(Object.assign(Object.assign({}, My), e[tn].config), o), p = Se.from(v), O = y !== void 0 ? Se.from(y) : p, $ = Kc(n.argTypes, a), { requestId: b, response: E, requestDetails: S } = await _.call(p, { methodName: t, arg: $, effectiveCanisterId: O }); let M, k; if (E.body && E.body.certificate) { if (_.rootKey == null) throw new Error("Agent is missing root key"); const re = E.body.certificate; k = await oi.create({ certificate: dl(re), rootKey: _.rootKey, canisterId: Se.from(v), blsVerify: r }); const U = [new TextEncoder().encode("request_status"), b]; switch (new TextDecoder().decode(sn(k.lookup([...U, "status"])))) { case "replied": M = sn(k.lookup([...U, "reply"])); break; case "rejected": { const ee = new Uint8Array(sn(k.lookup([...U, "reject_code"])))[0], N = new TextDecoder().decode(sn(k.lookup([...U, "reject_message"]))), F = sn(k.lookup([...U, "error_code"])), G = F ? new TextDecoder().decode(F) : void 0; throw new wh(p, t, b, E, ee, N, G) } } } else if (E.body && "reject_message" in E.body) { const { reject_code: re, reject_message: U, error_code: K } = E.body; throw new wh(p, t, b, E, re, U, K) } if (E.status === 202) { const re = w(), U = await Cy(_, O, b, re, r); k = U.certificate, M = U.reply } const C = n.annotations.includes(cf), V = n.annotations.includes(jy), Y = Object.assign(Object.assign({}, E), { requestDetails: S }); if (M !== void 0) return C && V ? { httpDetails: Y, certificate: k, result: Ti(n.retTypes, M) } : V ? { certificate: k, result: Ti(n.retTypes, M) } : C ? { httpDetails: Y, result: Ti(n.retTypes, M) } : Ti(n.retTypes, M); if (n.retTypes.length === 0) return C ? { httpDetails: E, result: void 0 } : void 0; throw new Error(`Call was returned undefined, but type [${n.retTypes.join(",")}].`) }; const s = (...o) => i({}, ...o); return s.withOptions = o => (...a) => i(o, ...a), s } function xh(e) { function t(n, r) { if (e.effectiveCanisterId) return { effectiveCanisterId: Se.from(e.effectiveCanisterId) }; const i = r[0]; let s = Se.fromHex(""); return i && typeof i == "object" && i.target_canister && n === "install_chunked_code" && (s = Se.from(i.target_canister)), i && typeof i == "object" && i.canister_id && (s = Se.from(i.canister_id)), { effectiveCanisterId: s } } return eu.createActor(s8, Object.assign(Object.assign(Object.assign({}, e), { canisterId: Se.fromHex("") }), { callTransform: t, queryTransform: t })) } const l8 = ({ IDL: e }) => { const t = e.Record({ query_base_cost: e.Nat64, storage_cost_per_kb: e.Nat64, computation_multiplier: e.Float32 }), n = e.Variant({ SystemPromptUpdate: e.Record({ prompt_name: e.Text, new_prompt: e.Text }), UpdateCyclesRates: e.Record({ new_rates: t }), TreasuryManagement: e.Record({ action: e.Text, amount: e.Nat64 }), AddAIProvider: e.Record({ provider_name: e.Text, api_endpoint: e.Text }) }), r = e.Variant({ Ok: e.Nat64, Err: e.Text }), i = e.Variant({ Ok: e.Text, Err: e.Text }), s = e.Record({ storage_used_bytes: e.Nat64, total_queries: e.Nat64, total_users: e.Nat64, uptime_start: e.Nat64, total_cycles_consumed: e.Nat64 }), o = e.Record({ id: e.Nat64, title: e.Text, description: e.Text, deadline: e.Nat64, created_at: e.Nat64, proposer: e.Principal, votes_for: e.Nat64, total_voting_power: e.Nat64, executed: e.Bool, proposal_type: n, votes_against: e.Nat64 }), a = e.Variant({ Premium: e.Null, Private: e.Null, Public: e.Null, Community: e.Null }), f = e.Record({ creator: e.Principal, content: e.Text, access_level: a, size_bytes: e.Nat64, content_type: e.Text, created_at: e.Nat64, cycles_cost_to_create: e.Nat64 }), h = e.Variant({ Ok: f, Err: e.Text }), _ = e.Variant({ Premium: e.Record({ cycles_included: e.Nat64, priority_access: e.Bool }), Enterprise: e.Record({ cycles_included: e.Nat64, private_models: e.Bool, custom_endpoints: e.Bool }), Basic: e.Record({ cycles_included: e.Nat64 }) }), v = e.Record({ cycles_balance: e.Nat64, total_cycles_spent: e.Nat64, stored_content_count: e.Nat64, subscription_tier: e.Opt(_), token_balance: e.Nat64, conversation_count: e.Nat64 }), y = e.Variant({ Ok: v, Err: e.Text }); return e.Service({ create_sns_proposal: e.Func([e.Text, e.Text, n], [r], []), deposit_user_cycles: e.Func([e.Principal], [i], []), get_ai_token_balance: e.Func([e.Principal], [e.Nat64], ["query"]), get_available_providers: e.Func([], [e.Vec(e.Text)], ["query"]), get_canister_metrics: e.Func([], [s], ["query"]), get_sns_proposals: e.Func([], [e.Vec(o)], ["query"]), get_stored_content: e.Func([e.Text], [h], ["query"]), get_user_cycles_balance: e.Func([e.Principal], [e.Nat64], ["query"]), get_user_dashboard: e.Func([e.Principal], [y], ["query"]), greet: e.Func([e.Text], [e.Text], ["query"]), icp_ai_prompt: e.Func([e.Text, e.Opt(e.Text), e.Opt(e.Text), e.Opt(e.Bool)], [i], []), mint_ai_tokens: e.Func([e.Principal, e.Nat64], [i], []), prompt: e.Func([e.Text], [i], []), set_api_key: e.Func([e.Text], [], []), set_provider_api_key: e.Func([e.Text, e.Text], [], []), store_ai_content: e.Func([e.Text, e.Text, a], [i], []), vote_sns_proposal: e.Func([e.Nat64, e.Bool], [i], []) }) }, u8 = "uxrrr-q7777-77774-qaaaq-cai", c8 = (e, t = {}) => { const n = t.agent || new Yi({ ...t.agentOptions }); return t.agent && t.agentOptions && console.warn("Detected both agent and agentOptions passed to createActor. Ignoring agentOptions and proceeding with the provided agent."), n.fetchRootKey().catch(r => { console.warn("Unable to fetch root key. Check to ensure that your local replica is running"), console.error(r) }), eu.createActor(l8, { agent: n, canisterId: e, ...t.actorOptions }) }, _l = c8(u8), f8 = ({ userPrincipal: e, onConnect: t, onDisconnect: n }) => H.jsx("header", { className: "bg-gradient-to-r from-blue-600 via-purple-600 to-indigo-700 shadow-lg", children: H.jsx("div", { className: "max-w-7xl mx-auto px-4 sm:px-6 lg:px-8", children: H.jsxs("div", { className: "flex justify-between items-center py-4", children: [H.jsxs("div", { className: "flex items-center space-x-3", children: [H.jsx("div", { className: "w-10 h-10 bg-white rounded-lg flex items-center justify-center shadow-md", children: H.jsx("svg", { className: "w-6 h-6 text-blue-600", fill: "currentColor", viewBox: "0 0 20 20", children: H.jsx("path", { fillRule: "evenodd", d: "M12.316 3.051a1 1 0 01.633 1.265l-4 12a1 1 0 11-1.898-.632l4-12a1 1 0 011.265-.633zM5.707 6.293a1 1 0 010 1.414L3.414 10l2.293 2.293a1 1 0 11-1.414 1.414l-3-3a1 1 0 010-1.414l3-3a1 1 0 011.414 0zm8.586 0a1 1 0 011.414 0l3 3a1 1 0 010 1.414l-3 3a1 1 0 11-1.414-1.414L16.586 10l-2.293-2.293a1 1 0 010-1.414z", clipRule: "evenodd" }) }) }), H.jsxs("div", { children: [H.jsx("h1", { className: "text-xl font-bold text-white", children: "AnveshakAI" }), H.jsx("p", { className: "text-blue-100 text-sm", children: "Powered by Internet Computer" })] })] }), H.jsx("div", { className: "flex items-center space-x-4", children: e ? H.jsxs("div", { className: "flex items-center space-x-3 bg-white/10 backdrop-blur-sm rounded-lg px-4 py-2", children: [H.jsx("div", { className: "w-8 h-8 bg-green-400 rounded-full flex items-center justify-center", children: H.jsx("svg", { className: "w-4 h-4 text-white", fill: "currentColor", viewBox: "0 0 20 20", children: H.jsx("path", { fillRule: "evenodd", d: "M10 9a3 3 0 100-6 3 3 0 000 6zm-7 9a7 7 0 1114 0H3z", clipRule: "evenodd" }) }) }), H.jsxs("div", { className: "text-white", children: [H.jsx("p", { className: "text-sm font-medium", children: "Connected" }), H.jsxs("p", { className: "text-xs text-blue-100 font-mono", children: [e.slice(0, 8), "...", e.slice(-8)] })] }), H.jsx("button", { onClick: n, className: "text-white/70 hover:text-white transition-colors", title: "Disconnect", children: H.jsx("svg", { className: "w-4 h-4", fill: "none", stroke: "currentColor", viewBox: "0 0 24 24", children: H.jsx("path", { strokeLinecap: "round", strokeLinejoin: "round", strokeWidth: 2, d: "M17 16l4-4m0 0l-4-4m4 4H7m6 4v1a3 3 0 01-3 3H6a3 3 0 01-3-3V7a3 3 0 013-3h4a3 3 0 013 3v1" }) }) })] }) : H.jsx("button", { onClick: t, className: "bg-white text-blue-600 px-4 py-2 rounded-lg font-medium hover:bg-blue-50 transition-colors shadow-md", children: "Connect Identity" }) })] }) }) }), d8 = ({ onGetStarted: e }) => H.jsx("section", { className: "bg-gradient-to-br from-blue-50 via-indigo-50 to-purple-50 py-16", children: H.jsx("div", { className: "max-w-7xl mx-auto px-4 sm:px-6 lg:px-8", children: H.jsxs("div", { className: "text-center", children: [H.jsxs("div", { className: "animate-fadeIn", children: [H.jsx("h1", { className: "text-5xl md:text-6xl font-bold text-gray-900 mb-6", children: "AnveshakAI - Decentralized AI Assistant" }), H.jsx("p", { className: "text-xl md:text-2xl text-gray-600 mb-8 max-w-4xl mx-auto", children: "Your intelligent companion powered by the Internet Computer blockchain. Experience AI with true decentralization, privacy, and ownership." })] }), H.jsxs("div", { className: "grid md:grid-cols-3 gap-8 mb-12 animate-slideInFromBottom", children: [H.jsxs("div", { className: "bg-white rounded-xl p-6 shadow-lg hover:shadow-xl transition-shadow", children: [H.jsx("div", { className: "w-12 h-12 bg-blue-100 rounded-lg flex items-center justify-center mx-auto mb-4", children: H.jsx("svg", { className: "w-6 h-6 text-blue-600", fill: "none", stroke: "currentColor", viewBox: "0 0 24 24", children: H.jsx("path", { strokeLinecap: "round", strokeLinejoin: "round", strokeWidth: 2, d: "M9 12l2 2 4-4m5.618-4.016A11.955 11.955 0 0112 2.944a11.955 11.955 0 01-8.618 3.04A12.02 12.02 0 003 9c0 5.591 3.824 10.29 9 11.622 5.176-1.332 9-6.03 9-11.622 0-1.042-.133-2.052-.382-3.016z" }) }) }), H.jsx("h3", { className: "text-lg font-semibold text-gray-900 mb-2", children: "Decentralized & Secure" }), H.jsx("p", { className: "text-gray-600", children: "Built on Internet Computer with Internet Identity authentication for maximum security and privacy." })] }), H.jsxs("div", { className: "bg-white rounded-xl p-6 shadow-lg hover:shadow-xl transition-shadow", children: [H.jsx("div", { className: "w-12 h-12 bg-purple-100 rounded-lg flex items-center justify-center mx-auto mb-4", children: H.jsx("svg", { className: "w-6 h-6 text-purple-600", fill: "none", stroke: "currentColor", viewBox: "0 0 24 24", children: H.jsx("path", { strokeLinecap: "round", strokeLinejoin: "round", strokeWidth: 2, d: "M13 10V3L4 14h7v7l9-11h-7z" }) }) }), H.jsx("h3", { className: "text-lg font-semibold text-gray-900 mb-2", children: "Lightning Fast" }), H.jsx("p", { className: "text-gray-600", children: "Powered by cycles-based payments and on-chain storage for instant responses and data persistence." })] }), H.jsxs("div", { className: "bg-white rounded-xl p-6 shadow-lg hover:shadow-xl transition-shadow", children: [H.jsx("div", { className: "w-12 h-12 bg-green-100 rounded-lg flex items-center justify-center mx-auto mb-4", children: H.jsx("svg", { className: "w-6 h-6 text-green-600", fill: "none", stroke: "currentColor", viewBox: "0 0 24 24", children: H.jsx("path", { strokeLinecap: "round", strokeLinejoin: "round", strokeWidth: 2, d: "M19 11H5m14 0a2 2 0 012 2v6a2 2 0 01-2 2H5a2 2 0 01-2-2v-6a2 2 0 012-2m14 0V9a2 2 0 00-2-2M5 11V9a2 2 0 012-2m0 0V5a2 2 0 012-2h6a2 2 0 012 2v2M7 7h10" }) }) }), H.jsx("h3", { className: "text-lg font-semibold text-gray-900 mb-2", children: "Multi-Domain Intelligence" }), H.jsx("p", { className: "text-gray-600", children: "Handle medical, legal, development, and cross-domain queries with specialized AI capabilities." })] })] }), H.jsx("div", { className: "animate-fadeIn", children: H.jsx("button", { onClick: e, className: "bg-gradient-to-r from-blue-600 to-purple-600 text-white px-8 py-4 rounded-xl text-lg font-semibold hover:from-blue-700 hover:to-purple-700 transition-all transform hover:scale-105 shadow-lg", children: "Get Started Now" }) })] }) }) }), h8 = () => { const e = [{ icon: H.jsx("svg", { className: "w-8 h-8", fill: "none", stroke: "currentColor", viewBox: "0 0 24 24", children: H.jsx("path", { strokeLinecap: "round", strokeLinejoin: "round", strokeWidth: 2, d: "M9 5H7a2 2 0 00-2 2v10a2 2 0 002 2h8a2 2 0 002-2V7a2 2 0 00-2-2h-2M9 5a2 2 0 002 2h2a2 2 0 002-2M9 5a2 2 0 012-2h2a2 2 0 012 2m-3 7h3m-3 4h3m-6-4h.01M9 16h.01" }) }), title: "Medical Intelligence", description: "Upload medical textbooks and research papers to get diagnostic assistance, treatment recommendations, and medical insights.", color: "text-red-600", bgColor: "bg-red-50", borderColor: "border-red-200" }, { icon: H.jsx("svg", { className: "w-8 h-8", fill: "none", stroke: "currentColor", viewBox: "0 0 24 24", children: H.jsx("path", { strokeLinecap: "round", strokeLinejoin: "round", strokeWidth: 2, d: "M3 6l3 1m0 0l-3 9a5.002 5.002 0 006.001 0M6 7l3 9M6 7l6-2m6 2l3-1m-3 1l-3 9a5.002 5.002 0 006.001 0M18 7l3 9m-3-9l-6-2m0-2v2m0 16V5m0 16l-3-9m3 9l3-9" }) }), title: "Legal Analysis", description: "Upload legal documents and contracts to receive in-depth analysis, summaries, and legal insights for better decision making.", color: "text-blue-600", bgColor: "bg-blue-50", borderColor: "border-blue-200" }, { icon: H.jsx("svg", { className: "w-8 h-8", fill: "none", stroke: "currentColor", viewBox: "0 0 24 24", children: H.jsx("path", { strokeLinecap: "round", strokeLinejoin: "round", strokeWidth: 2, d: "M10 20l4-16m4 4l4 4-4 4M6 16l-4-4 4-4" }) }), title: "Development Assistant", description: "Upload codebases to get explanations, identify potential issues, and receive suggestions for improvements and optimizations.", color: "text-green-600", bgColor: "bg-green-50", borderColor: "border-green-200" }, { icon: H.jsx("svg", { className: "w-8 h-8", fill: "none", stroke: "currentColor", viewBox: "0 0 24 24", children: H.jsx("path", { strokeLinecap: "round", strokeLinejoin: "round", strokeWidth: 2, d: "M19 11H5m14 0a2 2 0 012 2v6a2 2 0 01-2 2H5a2 2 0 01-2-2v-6a2 2 0 012-2m14 0V9a2 2 0 00-2-2M5 11V9a2 2 0 012-2m0 0V5a2 2 0 012-2h6a2 2 0 012 2v2M7 7h10" }) }), title: "Cross-Domain Intelligence", description: "Handle a mix of document types for complex queries that span multiple fields of knowledge and expertise areas.", color: "text-purple-600", bgColor: "bg-purple-50", borderColor: "border-purple-200" }, { icon: H.jsx("svg", { className: "w-8 h-8", fill: "none", stroke: "currentColor", viewBox: "0 0 24 24", children: H.jsx("path", { strokeLinecap: "round", strokeLinejoin: "round", strokeWidth: 2, d: "M12 6.253v13m0-13C10.832 5.477 9.246 5 7.5 5S4.168 5.477 3 6.253v13C4.168 18.477 5.754 18 7.5 18s3.332.477 4.5 1.253m0-13C13.168 5.477 14.754 5 16.5 5c1.746 0 3.332.477 4.5 1.253v13C19.832 18.477 18.246 18 16.5 18c-1.746 0-3.332.477-4.5 1.253" }) }), title: "Educational Support", description: "Get help with learning materials, research assistance, and educational content creation across various academic disciplines.", color: "text-indigo-600", bgColor: "bg-indigo-50", borderColor: "border-indigo-200" }, { icon: H.jsx("svg", { className: "w-8 h-8", fill: "none", stroke: "currentColor", viewBox: "0 0 24 24", children: H.jsx("path", { strokeLinecap: "round", strokeLinejoin: "round", strokeWidth: 2, d: "M9 12l2 2 4-4m6 2a9 9 0 11-18 0 9 9 0 0118 0z" }) }), title: "Quality Assurance", description: "Verify information accuracy, fact-check content, and ensure quality standards across all your AI-assisted work.", color: "text-orange-600", bgColor: "bg-orange-50", borderColor: "border-orange-200" }]; return H.jsx("section", { className: "py-16 bg-white", children: H.jsxs("div", { className: "max-w-7xl mx-auto px-4 sm:px-6 lg:px-8", children: [H.jsxs("div", { className: "text-center mb-12", children: [H.jsx("h2", { className: "text-3xl md:text-4xl font-bold text-gray-900 mb-4", children: "Comprehensive AI Capabilities" }), H.jsx("p", { className: "text-xl text-gray-600 max-w-3xl mx-auto", children: "Our Anveshak AI is designed to handle diverse scenarios across multiple domains, providing specialized intelligence for your specific needs." })] }), H.jsx("div", { className: "grid md:grid-cols-2 lg:grid-cols-3 gap-8", children: e.map((t, n) => H.jsxs("div", { className: `${t.bgColor} ${t.borderColor} border-2 rounded-xl p-6 hover:shadow-lg transition-all duration-300 hover:scale-105`, children: [H.jsx("div", { className: `${t.color} ${t.bgColor} w-16 h-16 rounded-lg flex items-center justify-center mb-4`, children: t.icon }), H.jsx("h3", { className: "text-xl font-semibold text-gray-900 mb-3", children: t.title }), H.jsx("p", { className: "text-gray-600 leading-relaxed", children: t.description })] }, n)) })] }) }) }, p8 = () => { const e = [{ icon: H.jsx("svg", { className: "w-6 h-6", fill: "none", stroke: "currentColor", viewBox: "0 0 24 24", children: H.jsx("path", { strokeLinecap: "round", strokeLinejoin: "round", strokeWidth: 2, d: "M9 12l2 2 4-4m5.618-4.016A11.955 11.955 0 0112 2.944a11.955 11.955 0 01-8.618 3.04A12.02 12.02 0 003 9c0 5.591 3.824 10.29 9 11.622 5.176-1.332 9-6.03 9-11.622 0-1.042-.133-2.052-.382-3.016z" }) }), title: "Internet Identity", description: "Secure, anonymous authentication without passwords or personal data collection." }, { icon: H.jsx("svg", { className: "w-6 h-6", fill: "none", stroke: "currentColor", viewBox: "0 0 24 24", children: H.jsx("path", { strokeLinecap: "round", strokeLinejoin: "round", strokeWidth: 2, d: "M13 10V3L4 14h7v7l9-11h-7z" }) }), title: "Cycles-Based Payments", description: "Efficient, low-cost transactions using Internet Computer's native cycles system." }, { icon: H.jsx("svg", { className: "w-6 h-6", fill: "none", stroke: "currentColor", viewBox: "0 0 24 24", children: H.jsx("path", { strokeLinecap: "round", strokeLinejoin: "round", strokeWidth: 2, d: "M4 7v10c0 2.21 3.582 4 8 4s8-1.79 8-4V7M4 7c0 2.21 3.582 4 8 4s8-1.79 8-4M4 7c0-2.21 3.582-4 8-4s8 1.79 8 4" }) }), title: "On-Chain Storage", description: "Your conversations and data stored securely on the blockchain with full ownership." }, { icon: H.jsx("svg", { className: "w-6 h-6", fill: "none", stroke: "currentColor", viewBox: "0 0 24 24", children: H.jsx("path", { strokeLinecap: "round", strokeLinejoin: "round", strokeWidth: 2, d: "M19 11H5m14 0a2 2 0 012 2v6a2 2 0 01-2 2H5a2 2 0 01-2-2v-6a2 2 0 012-2m14 0V9a2 2 0 00-2-2M5 11V9a2 2 0 012-2m0 0V5a2 2 0 012-2h6a2 2 0 012 2v2M7 7h10" }) }), title: "Multi-Provider AI", description: "Access to multiple AI providers with seamless switching and optimization." }]; return H.jsx("section", { className: "py-16 bg-gray-50", children: H.jsxs("div", { className: "max-w-7xl mx-auto px-4 sm:px-6 lg:px-8", children: [H.jsxs("div", { className: "text-center mb-12", children: [H.jsx("h2", { className: "text-3xl md:text-4xl font-bold text-gray-900 mb-4", children: "Built on Web3 Technology" }), H.jsx("p", { className: "text-xl text-gray-600 max-w-3xl mx-auto", children: "Experience the future of AI with blockchain-native features that prioritize your privacy, security, and data ownership." })] }), H.jsx("div", { className: "grid md:grid-cols-2 lg:grid-cols-4 gap-8", children: e.map((t, n) => H.jsxs("div", { className: "bg-white rounded-xl p-6 shadow-md hover:shadow-lg transition-shadow text-center", children: [H.jsx("div", { className: "w-12 h-12 bg-blue-100 rounded-lg flex items-center justify-center mx-auto mb-4 text-blue-600", children: t.icon }), H.jsx("h3", { className: "text-lg font-semibold text-gray-900 mb-2", children: t.title }), H.jsx("p", { className: "text-gray-600 text-sm", children: t.description })] }, n)) }), H.jsx("div", { className: "mt-16 bg-gradient-to-r from-blue-600 to-purple-600 rounded-2xl p-8 text-white", children: H.jsxs("div", { className: "grid md:grid-cols-4 gap-8 text-center", children: [H.jsxs("div", { children: [H.jsx("div", { className: "text-3xl font-bold mb-2", children: "100%" }), H.jsx("div", { className: "text-blue-100", children: "Decentralized" })] }), H.jsxs("div", { children: [H.jsx("div", { className: "text-3xl font-bold mb-2", children: "0" }), H.jsx("div", { className: "text-blue-100", children: "Data Collection" })] }), H.jsxs("div", { children: [H.jsx("div", { className: "text-3xl font-bold mb-2", children: "" }), H.jsx("div", { className: "text-blue-100", children: "Scalability" })] }), H.jsxs("div", { children: [H.jsx("div", { className: "text-3xl font-bold mb-2", children: "24/7" }), H.jsx("div", { className: "text-blue-100", children: "Availability" })] })] }) })] }) }) }, m8 = () => H.jsx("footer", { className: "bg-gray-900 text-white py-12", children: H.jsxs("div", { className: "max-w-7xl mx-auto px-4 sm:px-6 lg:px-8", children: [H.jsxs("div", { className: "grid md:grid-cols-4 gap-8", children: [H.jsxs("div", { className: "col-span-2", children: [H.jsxs("div", { className: "flex items-center space-x-3 mb-4", children: [H.jsx("div", { className: "w-8 h-8 bg-blue-600 rounded-lg flex items-center justify-center", children: H.jsx("svg", { className: "w-5 h-5 text-white", fill: "currentColor", viewBox: "0 0 20 20", children: H.jsx("path", { fillRule: "evenodd", d: "M12.316 3.051a1 1 0 01.633 1.265l-4 12a1 1 0 11-1.898-.632l4-12a1 1 0 011.265-.633zM5.707 6.293a1 1 0 010 1.414L3.414 10l2.293 2.293a1 1 0 11-1.414 1.414l-3-3a1 1 0 010-1.414l3-3a1 1 0 011.414 0zm8.586 0a1 1 0 011.414 0l3 3a1 1 0 010 1.414l-3 3a1 1 0 11-1.414-1.414L16.586 10l-2.293-2.293a1 1 0 010-1.414z", clipRule: "evenodd" }) }) }), H.jsx("h3", { className: "text-xl font-bold", children: "Anveshak AI" })] }), H.jsx("p", { className: "text-gray-400 mb-4 max-w-md", children: "The first truly decentralized AI assistant built on Internet Computer. Experience AI with complete privacy, security, and data ownership." }), H.jsxs("div", { className: "flex space-x-4", children: [H.jsx("a", { href: "#", className: "text-gray-400 hover:text-white transition-colors", children: H.jsx("svg", { className: "w-5 h-5", fill: "currentColor", viewBox: "0 0 20 20", children: H.jsx("path", { fillRule: "evenodd", d: "M20 10c0-5.523-4.477-10-10-10S0 4.477 0 10c0 4.991 3.657 9.128 8.438 9.878v-6.987h-2.54V10h2.54V7.797c0-2.506 1.492-3.89 3.777-3.89 1.094 0 2.238.195 2.238.195v2.46h-1.26c-1.243 0-1.63.771-1.63 1.562V10h2.773l-.443 2.89h-2.33v6.988C16.343 19.128 20 14.991 20 10z", clipRule: "evenodd" }) }) }), H.jsx("a", { href: "#", className: "text-gray-400 hover:text-white transition-colors", children: H.jsx("svg", { className: "w-5 h-5", fill: "currentColor", viewBox: "0 0 20 20", children: H.jsx("path", { d: "M6.29 18.251c7.547 0 11.675-6.253 11.675-11.675 0-.178 0-.355-.012-.53A8.348 8.348 0 0020 3.92a8.19 8.19 0 01-2.357.646 4.118 4.118 0 001.804-2.27 8.224 8.224 0 01-2.605.996 4.107 4.107 0 00-6.993 3.743 11.65 11.65 0 01-8.457-4.287 4.106 4.106 0 001.27 5.477A4.073 4.073 0 01.8 7.713v.052a4.105 4.105 0 003.292 4.022 4.095 4.095 0 01-1.853.07 4.108 4.108 0 003.834 2.85A8.233 8.233 0 010 16.407a11.616 11.616 0 006.29 1.84" }) }) }), H.jsx("a", { href: "#", className: "text-gray-400 hover:text-white transition-colors", children: H.jsx("svg", { className: "w-5 h-5", fill: "currentColor", viewBox: "0 0 20 20", children: H.jsx("path", { fillRule: "evenodd", d: "M10 0C4.477 0 0 4.484 0 10.017c0 4.425 2.865 8.18 6.839 9.504.5.092.682-.217.682-.483 0-.237-.008-.868-.013-1.703-2.782.605-3.369-1.343-3.369-1.343-.454-1.158-1.11-1.466-1.11-1.466-.908-.62.069-.608.069-.608 1.003.07 1.531 1.032 1.531 1.032.892 1.53 2.341 1.088 2.91.832.092-.647.35-1.088.636-1.338-2.22-.253-4.555-1.113-4.555-4.951 0-1.093.39-1.988 1.029-2.688-.103-.253-.446-1.272.098-2.65 0 0 .84-.27 2.75 1.026A9.564 9.564 0 0110 4.844c.85.004 1.705.115 2.504.337 1.909-1.296 2.747-1.027 2.747-1.027.546 1.379.203 2.398.1 2.651.64.7 1.028 1.595 1.028 2.688 0 3.848-2.339 4.695-4.566 4.942.359.31.678.921.678 1.856 0 1.338-.012 2.419-.012 2.747 0 .268.18.58.688.482A10.019 10.019 0 0020 10.017C20 4.484 15.522 0 10 0z", clipRule: "evenodd" }) }) })] })] }), H.jsxs("div", { children: [H.jsx("h4", { className: "text-lg font-semibold mb-4", children: "Quick Links" }), H.jsxs("ul", { className: "space-y-2", children: [H.jsx("li", { children: H.jsx("a", { href: "#", className: "text-gray-400 hover:text-white transition-colors", children: "Documentation" }) }), H.jsx("li", { children: H.jsx("a", { href: "#", className: "text-gray-400 hover:text-white transition-colors", children: "API Reference" }) }), H.jsx("li", { children: H.jsx("a", { href: "#", className: "text-gray-400 hover:text-white transition-colors", children: "Tutorials" }) }), H.jsx("li", { children: H.jsx("a", { href: "#", className: "text-gray-400 hover:text-white transition-colors", children: "Community" }) })] })] }), H.jsxs("div", { children: [H.jsx("h4", { className: "text-lg font-semibold mb-4", children: "Support" }), H.jsxs("ul", { className: "space-y-2", children: [H.jsx("li", { children: H.jsx("a", { href: "#", className: "text-gray-400 hover:text-white transition-colors", children: "Help Center" }) }), H.jsx("li", { children: H.jsx("a", { href: "#", className: "text-gray-400 hover:text-white transition-colors", children: "Contact Us" }) }), H.jsx("li", { children: H.jsx("a", { href: "#", className: "text-gray-400 hover:text-white transition-colors", children: "Privacy Policy" }) }), H.jsx("li", { children: H.jsx("a", { href: "#", className: "text-gray-400 hover:text-white transition-colors", children: "Terms of Service" }) })] })] })] }), H.jsxs("div", { className: "border-t border-gray-800 mt-8 pt-8 flex flex-col md:flex-row justify-between items-center", children: [H.jsx("p", { className: "text-gray-400 text-sm", children: " 2024 Anveshak AI. Built on Internet Computer Protocol." }), H.jsxs("div", { className: "flex items-center space-x-4 mt-4 md:mt-0", children: [H.jsx("span", { className: "text-gray-400 text-sm", children: "Powered by" }), H.jsxs("div", { className: "flex items-center space-x-2", children: [H.jsx("div", { className: "w-6 h-6 bg-blue-600 rounded-full flex items-center justify-center", children: H.jsx("span", { className: "text-white text-xs font-bold", children: "IC" }) }), H.jsx("span", { className: "text-white text-sm font-medium", children: "Internet Computer" })] })] })] })] }) }), y8 = ({ userPrincipal: e, onConnect: t, onDisconnect: n, onGetStarted: r }) => H.jsxs("div", { className: "min-h-screen bg-white", children: [H.jsx(f8, { userPrincipal: e, onConnect: t, onDisconnect: n }), H.jsxs("main", { children: [H.jsx(d8, { onGetStarted: r }), H.jsx(h8, {}), H.jsx(p8, {})] }), H.jsx(m8, {})] }), vh = "" + new URL("../bot.svg", import.meta.url).href, g8 = "" + new URL("../user.svg", import.meta.url).href, w8 = ({ userPrincipal: e, onBackToWelcome: t, initialChat: n = [], selectedProvider: r = "gemini", assistantType: i = "casual", storeOnChain: s = !1, icpMode: o = !1 }) => { const [a, f] = ct.useState(n.length > 0 ? n : [{ system: { content: " Welcome to your ICP-Native Anveshak AI! I'm powered by the Internet Computer with Internet Identity authentication, cycles-based payments, and on-chain storage. Your original chatting experience is preserved while adding Web3 capabilities. What would you like to explore today?", provider: "system" } }]), [h, _] = ct.useState(""), [v, y] = ct.useState(!1), w = ct.useRef(null); ct.useEffect(() => { w.current && (w.current.scrollTop = w.current.scrollHeight) }, [a]); const p = async O => { if (O.preventDefault(), !h.trim() || v) return; const $ = h.trim(); _(""), y(!0), f(b => [...b, { user: { content: $ } }]); try { let b; o ? b = await _l.icp_ai_prompt($, r ? [r] : [], i ? [i] : [], s ? [s] : []) : b = await _l.prompt($), b.Ok ? f(E => [...E, { assistant: { content: b.Ok, provider: r || "gemini" } }]) : f(E => [...E, { assistant: { content: `Error: ${b.Err}`, provider: "error" } }]) } catch (b) { console.error("Error sending message:", b), f(E => [...E, { assistant: { content: `Error: Failed to send message. ${b.message}`, provider: "error" } }]) } finally { y(!1) } }; return H.jsxs("div", { className: "min-h-screen bg-gray-50 flex flex-col", children: [H.jsx("div", { className: "bg-white shadow-sm border-b", children: H.jsxs("div", { className: "max-w-4xl mx-auto px-4 py-4 flex items-center justify-between", children: [H.jsxs("button", { onClick: t, className: "flex items-center space-x-2 text-gray-600 hover:text-gray-900 transition-colors", children: [H.jsx("svg", { className: "w-5 h-5", fill: "none", stroke: "currentColor", viewBox: "0 0 24 24", children: H.jsx("path", { strokeLinecap: "round", strokeLinejoin: "round", strokeWidth: 2, d: "M15 19l-7-7 7-7" }) }), H.jsx("span", { children: "Back to Welcome" })] }), H.jsxs("div", { className: "text-center", children: [H.jsx("h1", { className: "text-xl font-semibold text-gray-900", children: "AI Assistant" }), H.jsx("p", { className: "text-sm text-gray-500", children: o ? `ICP Mode  ${r}` : "Classic Mode" })] }), e && H.jsxs("div", { className: "flex items-center space-x-2 text-sm text-gray-600", children: [H.jsx("div", { className: "w-2 h-2 bg-green-400 rounded-full" }), H.jsx("span", { children: "Connected" })] })] }) }), H.jsxs("div", { className: "flex-1 flex flex-col max-w-4xl mx-auto w-full", children: [H.jsxs("div", { ref: w, className: "flex-1 overflow-y-auto p-4 space-y-4", children: [a.map((O, $) => H.jsxs("div", { className: "animate-fadeIn", children: [O.user && H.jsxs("div", { className: "flex items-start space-x-3 justify-end", children: [H.jsx("div", { className: "bg-blue-600 text-white rounded-2xl rounded-tr-sm px-4 py-2 max-w-xs lg:max-w-md", children: H.jsx("p", { className: "text-sm", children: O.user.content }) }), H.jsx("img", { src: g8, alt: "User", className: "w-8 h-8 rounded-full" })] }), O.assistant && H.jsxs("div", { className: "flex items-start space-x-3", children: [H.jsx("img", { src: vh, alt: "Assistant", className: "w-8 h-8 rounded-full" }), H.jsxs("div", { className: "bg-white rounded-2xl rounded-tl-sm px-4 py-2 max-w-xs lg:max-w-md shadow-sm border", children: [H.jsx("p", { className: "text-sm text-gray-800 whitespace-pre-wrap", children: O.assistant.content }), O.assistant.provider && H.jsxs("p", { className: "text-xs text-gray-500 mt-1", children: ["via ", O.assistant.provider] })] })] }), O.system && H.jsx("div", { className: "flex justify-center", children: H.jsx("div", { className: "bg-gradient-to-r from-blue-100 to-purple-100 rounded-xl px-4 py-2 max-w-2xl", children: H.jsx("p", { className: "text-sm text-gray-700 text-center", children: O.system.content }) }) })] }, $)), v && H.jsxs("div", { className: "flex items-start space-x-3", children: [H.jsx("img", { src: vh, alt: "Assistant", className: "w-8 h-8 rounded-full" }), H.jsx("div", { className: "bg-white rounded-2xl rounded-tl-sm px-4 py-2 shadow-sm border", children: H.jsxs("div", { className: "flex space-x-1", children: [H.jsx("div", { className: "w-2 h-2 bg-gray-400 rounded-full animate-pulse" }), H.jsx("div", { className: "w-2 h-2 bg-gray-400 rounded-full animate-pulse", style: { animationDelay: "0.1s" } }), H.jsx("div", { className: "w-2 h-2 bg-gray-400 rounded-full animate-pulse", style: { animationDelay: "0.2s" } })] }) })] })] }), H.jsx("div", { className: "border-t bg-white p-4", children: H.jsxs("form", { onSubmit: p, className: "flex space-x-3", children: [H.jsx("input", { type: "text", value: h, onChange: O => _(O.target.value), placeholder: "Type your message...", className: "flex-1 border border-gray-300 rounded-xl px-4 py-2 focus:outline-none focus:ring-2 focus:ring-blue-500 focus:border-transparent", disabled: v }), H.jsx("button", { type: "submit", disabled: v || !h.trim(), className: "bg-blue-600 text-white px-6 py-2 rounded-xl hover:bg-blue-700 disabled:opacity-50 disabled:cursor-not-allowed transition-colors", children: "Send" })] }) })] })] }) }, x8 = () => { const [e, t] = ct.useState("welcome"), [n, r] = ct.useState([{ system: { content: " Welcome to your ICP-Native Anveshak AI! I'm powered by the Internet Computer with Internet Identity authentication, cycles-based payments, and on-chain storage. Your original chatting experience is preserved while adding Web3 capabilities. What would you like to explore today?", provider: "system" } }]), [i, s] = ct.useState("gemini"), [o, a] = ct.useState("casual"), [f, h] = ct.useState(["gemini"]), [_, v] = ct.useState(null), [y, w] = ct.useState(!1), [p, O] = ct.useState(null), [$, b] = ct.useState(!1); ct.useEffect(() => { E(), v("rdmx6-jaaaa-aaaah-qcaiq-cai"), S() }, []); const E = async () => { try { const Y = await _l.get_available_providers(); h(Y.length > 0 ? Y : ["gemini"]) } catch (Y) { console.log("Could not load providers:", Y) } }, S = async () => { if (_) try { const Y = await _l.get_user_dashboard(_); Y.Ok && O(Y.Ok) } catch (Y) { console.log("Could not load user dashboard:", Y) } }, M = () => { v("rdmx6-jaaaa-aaaah-qcaiq-cai"), S() }, k = () => { v(null), O(null) }, C = () => { t("chat") }, V = () => { t("welcome") }; return e === "welcome" ? H.jsx(y8, { userPrincipal: _, onConnect: M, onDisconnect: k, onGetStarted: C }) : H.jsx(w8, { userPrincipal: _, onBackToWelcome: V, initialChat: n, selectedProvider: i, assistantType: o, storeOnChain: y, icpMode: $ }) }; Ju.createRoot(document.getElementById("root")).render(H.jsx(pg.StrictMode, { children: H.jsx(x8, {}) }));
